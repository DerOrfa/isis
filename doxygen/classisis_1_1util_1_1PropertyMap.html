<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ISIS Core Library: isis::util::PropertyMap Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">ISIS Core Library&#160;<span id="projectnumber">0.4.7 (api 0.0.0)</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceisis.html">isis</a>      </li>
      <li class="navelem"><a class="el" href="namespaceisis_1_1util.html">util</a>      </li>
      <li class="navelem"><a class="el" href="classisis_1_1util_1_1PropertyMap.html">PropertyMap</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a>  </div>
  <div class="headertitle">
<h1>isis::util::PropertyMap Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="isis::util::PropertyMap" --><!-- doxytag: inherits="std::map" -->
<p>This class forms a mapping tree to store all kinds of properties (path : value), where:</p>
<ul>
<li>value is:<ul>
<li>a <a class="el" href="classisis_1_1util_1_1PropertyValue.html" title="A very generic class to store values of properties.">util::PropertyValue</a>-container holding the value of the property (this may be empty/unset)</li>
<li>another <a class="el" href="classisis_1_1util_1_1PropertyMap.html" title="This class forms a mapping tree to store all kinds of properties (path : value), where:value is:a uti...">PropertyMap</a> containing a subtree (a branch of the mapping tree)</li>
</ul>
</li>
<li>path is one or more case insensitive key names separated by "/" to locate both, branches or properties, in the tree. </li>
</ul>
 
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="propmap_8hpp_source.html">propmap.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for isis::util::PropertyMap:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classisis_1_1util_1_1PropertyMap.png" usemap="#isis::util::PropertyMap_map" alt=""/>
  <map id="isis::util::PropertyMap_map" name="isis::util::PropertyMap_map">
<area href="classisis_1_1data_1_1__internal_1_1ChunkBase.html" alt="isis::data::_internal::ChunkBase" shape="rect" coords="118,56,345,80"/>
<area href="classisis_1_1data_1_1Image.html" alt="isis::data::Image" shape="rect" coords="474,56,701,80"/>
<area href="classisis_1_1data_1_1Chunk.html" alt="isis::data::Chunk" shape="rect" coords="118,112,345,136"/>
<area href="classisis_1_1data_1_1TypedImage.html" alt="isis::data::TypedImage&lt; T &gt;" shape="rect" coords="474,112,701,136"/>
<area href="classisis_1_1data_1_1MemChunk.html" alt="isis::data::MemChunk&lt; TYPE &gt;" shape="rect" coords="0,168,227,192"/>
<area href="classisis_1_1data_1_1MemChunkNonDel.html" alt="isis::data::MemChunkNonDel&lt; TYPE &gt;" shape="rect" coords="237,168,464,192"/>
<area href="classisis_1_1data_1_1MemImage.html" alt="isis::data::MemImage&lt; T &gt;" shape="rect" coords="474,168,701,192"/>
</map>
 </div></div>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>invalidP</b></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">true when entry is a leaf, needed and empty <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>listP</b></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">true when entry is not a scalar <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structisis_1_1util_1_1PropertyMap_1_1PropPath.html">PropPath</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">"Path" type used to locate entries in the tree  <a href="structisis_1_1util_1_1PropertyMap_1_1PropPath.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>treeInvalidP</b></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">true when entry is a leaf, needed and empty of entry is a invalid branch <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>trueP</b></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">allways true <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structisis_1_1util_1_1PropertyMap_1_1walkTree.html">walkTree</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; <a class="el" href="classisis_1_1util_1_1PropertyMap.html#a22562fc95dac243746790a5c6a2aad85">KeyType</a>, <br class="typebreak"/>
std::pair&lt; <a class="el" href="classisis_1_1util_1_1PropertyValue.html">PropertyValue</a>, <br class="typebreak"/>
<a class="el" href="classisis_1_1util_1_1PropertyValue.html">PropertyValue</a> &gt;, key_compare &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1util_1_1PropertyMap.html#a0bfc17a3afe4a2a010e75c80f8883102">DiffMap</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">a flat map matching keys to pairs of values  <a href="#a0bfc17a3afe4a2a010e75c80f8883102"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; <a class="el" href="classisis_1_1util_1_1PropertyMap.html#a22562fc95dac243746790a5c6a2aad85">KeyType</a>, <br class="typebreak"/>
<a class="el" href="classisis_1_1util_1_1PropertyValue.html">PropertyValue</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1util_1_1PropertyMap.html#a402a5b6b4fed6b673af4fe6fdbd1e957">FlatMap</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">a flat map, matching complete paths as keys to the corresponding values  <a href="#a402a5b6b4fed6b673af4fe6fdbd1e957"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::set&lt; <a class="el" href="classisis_1_1util_1_1PropertyMap.html#a22562fc95dac243746790a5c6a2aad85">KeyType</a>, <br class="typebreak"/>
key_compare &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1util_1_1PropertyMap.html#a2c8c8105e5fef4b913e634cbf6532a1c">KeyList</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">a list to store keys only (without the corresponding values)  <a href="#a2c8c8105e5fef4b913e634cbf6532a1c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef key_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1util_1_1PropertyMap.html#a22562fc95dac243746790a5c6a2aad85">KeyType</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">type of the keys forming a path  <a href="#a22562fc95dac243746790a5c6a2aad85"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classisis_1_1util_1_1PropertyMap.html">PropertyMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1util_1_1PropertyMap.html#a85ff9d6b80c5bd55628fd49da3023568">branch</a> (const <a class="el" href="structisis_1_1util_1_1PropertyMap_1_1PropPath.html">PropPath</a> &amp;path)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the branch referenced by the path, create it if its not there.  <a href="#a85ff9d6b80c5bd55628fd49da3023568"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classisis_1_1util_1_1PropertyMap.html">PropertyMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1util_1_1PropertyMap.html#a7d0ac1e2070a996c40b57db1ab2dc93e">branch</a> (const <a class="el" href="structisis_1_1util_1_1PropertyMap_1_1PropPath.html">PropPath</a> &amp;path) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the branch referenced by the path.  <a href="#a7d0ac1e2070a996c40b57db1ab2dc93e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classisis_1_1util_1_1PropertyMap.html#a22562fc95dac243746790a5c6a2aad85">KeyType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1util_1_1PropertyMap.html#abb3518fa3c1e35033b4dee5cf9b2ca60">find</a> (<a class="el" href="classisis_1_1util_1_1PropertyMap.html#a22562fc95dac243746790a5c6a2aad85">KeyType</a> key, bool allowProperty=true, bool allowBranch=false) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for a property/branch in the whole Tree.  <a href="#abb3518fa3c1e35033b4dee5cf9b2ca60"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classisis_1_1util_1_1PropertyMap.html#a2c8c8105e5fef4b913e634cbf6532a1c">KeyList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1util_1_1PropertyMap.html#a72fdd04ff2b327bfb0c1c382737df54c">findLists</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">find all non scalar entries  <a href="#a72fdd04ff2b327bfb0c1c382737df54c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classisis_1_1util_1_1PropertyMap.html#a0bfc17a3afe4a2a010e75c80f8883102">DiffMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1util_1_1PropertyMap.html#a92da4079cea64f8f92353322653e46bd">getDifference</a> (const <a class="el" href="classisis_1_1util_1_1PropertyMap.html">PropertyMap</a> &amp;second) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a difference map of this tree and another.  <a href="#a92da4079cea64f8f92353322653e46bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classisis_1_1util_1_1PropertyMap.html#a402a5b6b4fed6b673af4fe6fdbd1e957">FlatMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1util_1_1PropertyMap.html#a77d485a4e4c1f236302b9b56eaaa9d47">getFlatMap</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classisis_1_1util_1_1PropertyMap.html#a2c8c8105e5fef4b913e634cbf6532a1c">KeyList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1util_1_1PropertyMap.html#aa023972e1eb29afcea14916c2ae53288">getKeys</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of the paths of all properties.  <a href="#aa023972e1eb29afcea14916c2ae53288"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classisis_1_1util_1_1PropertyMap.html#a2c8c8105e5fef4b913e634cbf6532a1c">KeyList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1util_1_1PropertyMap.html#ad84de96685231d402bf9e8741a72db91">getMissing</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of missing properties.  <a href="#ad84de96685231d402bf9e8741a72db91"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classisis_1_1util_1_1PropertyMap.html#ae3f42731036b6f53afbdbb063e03d958">getPropertyAs</a> (const <a class="el" href="structisis_1_1util_1_1PropertyMap_1_1PropPath.html">PropPath</a> &amp;path) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Request a property via the given key in the given type.  <a href="#ae3f42731036b6f53afbdbb063e03d958"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1util_1_1PropertyMap.html#a5685f66f48885d31f53d8714cd3ebbd0">hasBranch</a> (const <a class="el" href="structisis_1_1util_1_1PropertyMap_1_1PropPath.html">PropPath</a> &amp;path) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">check if branch of the tree is available  <a href="#a5685f66f48885d31f53d8714cd3ebbd0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1util_1_1PropertyMap.html#ace197e0a37714072c4b8a9c9096018a1">hasProperty</a> (const <a class="el" href="structisis_1_1util_1_1PropertyMap_1_1PropPath.html">PropPath</a> &amp;path) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">check if a property is available  <a href="#ace197e0a37714072c4b8a9c9096018a1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1util_1_1PropertyMap.html#a4a6bae8173d0a0e910903a634be674af">isEmpty</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1util_1_1PropertyMap.html#a7f4ea1b7c43edfce313d70dc7f68addc">isValid</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if every property marked as needed is set.  <a href="#a7f4ea1b7c43edfce313d70dc7f68addc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classisis_1_1util_1_1PropertyMap.html#a2c8c8105e5fef4b913e634cbf6532a1c">PropertyMap::KeyList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1util_1_1PropertyMap.html#a8f5f0388f7901b9f4ee4afeb7732ba42">join</a> (const <a class="el" href="classisis_1_1util_1_1PropertyMap.html">isis::util::PropertyMap</a> &amp;other, bool overwrite=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add Properties from another tree.  <a href="#a8f5f0388f7901b9f4ee4afeb7732ba42"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1util_1_1PropertyMap.html#a1e93ada16242a03c04b787bc6ae6f413">operator==</a> (const <a class="el" href="classisis_1_1util_1_1PropertyMap.html">PropertyMap</a> &amp;src) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1util_1_1PropertyMap.html#a9485ad2dbf2e7f5f8ec393c41d9ebd73">print</a> (std::ostream &amp;out, bool label=false) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">"Print" the property tree.  <a href="#a9485ad2dbf2e7f5f8ec393c41d9ebd73"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1util_1_1PropertyMap.html#afcc2f4657fbd500284e60e0ef442bbe6">PropertyMap</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1util_1_1PropertyMap.html#aa9c3813f90144fbea1a8012bee99cc54">PropertyMap</a> (const Container &amp;src)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classisis_1_1util_1_1PropertyValue.html">PropertyValue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1util_1_1PropertyMap.html#a4c656dc09e8b6b41f96dd9e396ac20df">propertyValue</a> (const <a class="el" href="structisis_1_1util_1_1PropertyMap_1_1PropPath.html">PropPath</a> &amp;path) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the property referenced by the path.  <a href="#a4c656dc09e8b6b41f96dd9e396ac20df"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classisis_1_1util_1_1PropertyValue.html">PropertyValue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1util_1_1PropertyMap.html#aeabcb29b04b303b2264501b4b05bfcac">propertyValue</a> (const <a class="el" href="structisis_1_1util_1_1PropertyMap_1_1PropPath.html">PropPath</a> &amp;path)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the property referenced by the path, create it if its not there.  <a href="#aeabcb29b04b303b2264501b4b05bfcac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1util_1_1PropertyMap.html#a00b589b778915334bc9ef9c36e296c7d">remove</a> (const <a class="el" href="classisis_1_1util_1_1PropertyMap.html">PropertyMap</a> &amp;removeMap, bool keep_needed=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">remove every property which is also in the given tree (regardless of the value)  <a href="#a00b589b778915334bc9ef9c36e296c7d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1util_1_1PropertyMap.html#a4db5950cdd32941a590cb75fcc00f3ad">remove</a> (const <a class="el" href="structisis_1_1util_1_1PropertyMap_1_1PropPath.html">PropPath</a> &amp;path)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the property adressed by the path.  <a href="#a4db5950cdd32941a590cb75fcc00f3ad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1util_1_1PropertyMap.html#a858eed4423e3984ca1f2e6537228b6d8">remove</a> (const <a class="el" href="classisis_1_1util_1_1PropertyMap.html#a2c8c8105e5fef4b913e634cbf6532a1c">KeyList</a> &amp;removeList, bool keep_needed=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">remove every property which is also in the given list (regardless of the value)  <a href="#a858eed4423e3984ca1f2e6537228b6d8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1util_1_1PropertyMap.html#a2d1267ed81e4d76c6a875e8d22bb42c2">rename</a> (const <a class="el" href="structisis_1_1util_1_1PropertyMap_1_1PropPath.html">PropPath</a> &amp;from, const <a class="el" href="structisis_1_1util_1_1PropertyMap_1_1PropPath.html">PropPath</a> &amp;to)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Rename a given property/branch.  <a href="#a2d1267ed81e4d76c6a875e8d22bb42c2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classisis_1_1util_1_1PropertyValue.html">PropertyValue</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classisis_1_1util_1_1PropertyMap.html#adee60064ebd5e24f31c31dcf8750eb29">setPropertyAs</a> (const <a class="el" href="structisis_1_1util_1_1PropertyMap_1_1PropPath.html">PropPath</a> &amp;path, const T &amp;val)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the given property to a given value/type.  <a href="#adee60064ebd5e24f31c31dcf8750eb29"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1util_1_1PropertyMap.html#a8c1624769a45f6aca280cf45b0577d33">transform</a> (const <a class="el" href="structisis_1_1util_1_1PropertyMap_1_1PropPath.html">PropPath</a> &amp;from, const <a class="el" href="structisis_1_1util_1_1PropertyMap_1_1PropPath.html">PropPath</a> &amp;to, int dstID, bool delSource=true)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform an existing property into another.  <a href="#a8c1624769a45f6aca280cf45b0577d33"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename DST &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classisis_1_1util_1_1PropertyMap.html#a5fa02559317b63e5c6a18cffadefabdd">transform</a> (const <a class="el" href="structisis_1_1util_1_1PropertyMap_1_1PropPath.html">PropPath</a> &amp;from, const <a class="el" href="structisis_1_1util_1_1PropertyMap_1_1PropPath.html">PropPath</a> &amp;to, bool delSource=true)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform an existing property into another (statically typed version).  <a href="#a5fa02559317b63e5c6a18cffadefabdd"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1util_1_1PropertyMap.html#a67214438f607248a64bb22a8574d322e">addNeeded</a> (const <a class="el" href="classisis_1_1util_1_1PropertyMap.html#a22562fc95dac243746790a5c6a2aad85">KeyType</a> &amp;path)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a property with status needed.  <a href="#a67214438f607248a64bb22a8574d322e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1util_1_1PropertyMap.html#afc8dc03ba6f2f6988b133ab57e1aa26c">addNeededFromString</a> (const std::string &amp;needed)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Make Properties given by a space separated list needed.  <a href="#afc8dc03ba6f2f6988b133ab57e1aa26c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Predicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classisis_1_1util_1_1PropertyMap.html#a2c8c8105e5fef4b913e634cbf6532a1c">KeyList</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classisis_1_1util_1_1PropertyMap.html#ac6446eac6db55a9e7351fb37924c9386">genKeyList</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">create a list of keys for every entry for which the given scalar predicate is true.  <a href="#ac6446eac6db55a9e7351fb37924c9386"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1util_1_1PropertyMap.html#a380618b20d3c787500207317400ea383">makeFlatMap</a> (<a class="el" href="classisis_1_1util_1_1PropertyMap.html#a402a5b6b4fed6b673af4fe6fdbd1e957">FlatMap</a> &amp;out, <a class="el" href="classisis_1_1util_1_1PropertyMap.html#a22562fc95dac243746790a5c6a2aad85">KeyType</a> key_prefix=&quot;&quot;) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">copy the tree into a flat key/property-map  <a href="#a380618b20d3c787500207317400ea383"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const std::vector<br class="typebreak"/>
&lt; <a class="el" href="classisis_1_1util_1_1PropertyValue.html">PropertyValue</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1util_1_1PropertyMap.html#ac1fcaf297115450ea4eaf67b2a68513c">propertyValueVec</a> (const <a class="el" href="structisis_1_1util_1_1PropertyMap_1_1PropPath.html">PropPath</a> &amp;path) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the property vector referenced by the path.  <a href="#ac1fcaf297115450ea4eaf67b2a68513c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classisis_1_1util_1_1PropertyValue.html">PropertyValue</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1util_1_1PropertyMap.html#af85f7af2c66875efbbb475d5e03f7ed3">propertyValueVec</a> (const <a class="el" href="structisis_1_1util_1_1PropertyMap_1_1PropPath.html">PropPath</a> &amp;path)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the property vector referenced by the path-key, create it if its not there.  <a href="#af85f7af2c66875efbbb475d5e03f7ed3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1util_1_1PropertyMap.html#ad743c0b3afee400fb579b931064196aa">removeEqual</a> (const <a class="el" href="classisis_1_1util_1_1PropertyMap.html">isis::util::PropertyMap</a> &amp;other, bool removeNeeded=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove every <a class="el" href="classisis_1_1util_1_1PropertyValue.html" title="A very generic class to store values of properties.">PropertyValue</a> which is also in the other <a class="el" href="classisis_1_1util_1_1PropertyMap.html" title="This class forms a mapping tree to store all kinds of properties (path : value), where:value is:a uti...">PropertyMap</a> and where operator== returns true.  <a href="#ad743c0b3afee400fb579b931064196aa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1util_1_1PropertyMap.html#a8761e90a0f2c2dcd021f2325a4b8f263">toCommonUnique</a> (<a class="el" href="classisis_1_1util_1_1PropertyMap.html">PropertyMap</a> &amp;common, std::set&lt; <a class="el" href="classisis_1_1util_1_1PropertyMap.html#a22562fc95dac243746790a5c6a2aad85">KeyType</a> &gt; &amp;uniques, bool init) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get common and unique properties from the tree.  <a href="#a8761e90a0f2c2dcd021f2325a4b8f263"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>This class forms a mapping tree to store all kinds of properties (path : value), where:</p>
<ul>
<li>value is:<ul>
<li>a <a class="el" href="classisis_1_1util_1_1PropertyValue.html" title="A very generic class to store values of properties.">util::PropertyValue</a>-container holding the value of the property (this may be empty/unset)</li>
<li>another <a class="el" href="classisis_1_1util_1_1PropertyMap.html" title="This class forms a mapping tree to store all kinds of properties (path : value), where:value is:a uti...">PropertyMap</a> containing a subtree (a branch of the mapping tree)</li>
</ul>
</li>
<li>path is one or more case insensitive key names separated by "/" to locate both, branches or properties, in the tree. </li>
</ul>
<p>Nevertheless there are separate access functions for branches and properties. Trying to access a branch as a property value,or to access a property value as a branch will cause error messages and give empty results.</p>
<p>Paths can be created from other paths and from strings (c-strings and <a class="el" href="namespaceisis_1_1util.html#a85956c20207215d2b77e4c0935e494d5">util::istring</a>, but not std::string). So both can be used for functions which expect paths, but the usage of c-strings is slower.</p>
<p>To describe the minimum of needed metadata needed by specific data structures / subclasses properties can be marked as "needed" and there are functions to verify that they are not empty. </p>

<p>Definition at line <a class="el" href="propmap_8hpp_source.html#l00054">54</a> of file <a class="el" href="propmap_8hpp_source.html">propmap.hpp</a>.</p>
</div><hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a0bfc17a3afe4a2a010e75c80f8883102"></a><!-- doxytag: member="isis::util::PropertyMap::DiffMap" ref="a0bfc17a3afe4a2a010e75c80f8883102" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;<a class="el" href="classisis_1_1util_1_1PropertyMap.html#a22562fc95dac243746790a5c6a2aad85">KeyType</a>, std::pair&lt;<a class="el" href="classisis_1_1util_1_1PropertyValue.html">PropertyValue</a>, <a class="el" href="classisis_1_1util_1_1PropertyValue.html">PropertyValue</a>&gt;, key_compare&gt; <a class="el" href="classisis_1_1util_1_1PropertyMap.html#a0bfc17a3afe4a2a010e75c80f8883102">isis::util::PropertyMap::DiffMap</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>a flat map matching keys to pairs of values </p>

<p>Definition at line <a class="el" href="propmap_8hpp_source.html#l00062">62</a> of file <a class="el" href="propmap_8hpp_source.html">propmap.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a402a5b6b4fed6b673af4fe6fdbd1e957"></a><!-- doxytag: member="isis::util::PropertyMap::FlatMap" ref="a402a5b6b4fed6b673af4fe6fdbd1e957" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;<a class="el" href="classisis_1_1util_1_1PropertyMap.html#a22562fc95dac243746790a5c6a2aad85">KeyType</a>, <a class="el" href="classisis_1_1util_1_1PropertyValue.html">PropertyValue</a>&gt; <a class="el" href="classisis_1_1util_1_1PropertyMap.html#a402a5b6b4fed6b673af4fe6fdbd1e957">isis::util::PropertyMap::FlatMap</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>a flat map, matching complete paths as keys to the corresponding values </p>

<p>Definition at line <a class="el" href="propmap_8hpp_source.html#l00064">64</a> of file <a class="el" href="propmap_8hpp_source.html">propmap.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2c8c8105e5fef4b913e634cbf6532a1c"></a><!-- doxytag: member="isis::util::PropertyMap::KeyList" ref="a2c8c8105e5fef4b913e634cbf6532a1c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::set&lt;<a class="el" href="classisis_1_1util_1_1PropertyMap.html#a22562fc95dac243746790a5c6a2aad85">KeyType</a>, key_compare&gt; <a class="el" href="classisis_1_1util_1_1PropertyMap.html#a2c8c8105e5fef4b913e634cbf6532a1c">isis::util::PropertyMap::KeyList</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>a list to store keys only (without the corresponding values) </p>

<p>Definition at line <a class="el" href="propmap_8hpp_source.html#l00060">60</a> of file <a class="el" href="propmap_8hpp_source.html">propmap.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a22562fc95dac243746790a5c6a2aad85"></a><!-- doxytag: member="isis::util::PropertyMap::KeyType" ref="a22562fc95dac243746790a5c6a2aad85" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef key_type <a class="el" href="classisis_1_1util_1_1PropertyMap.html#a22562fc95dac243746790a5c6a2aad85">isis::util::PropertyMap::KeyType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>type of the keys forming a path </p>

<p>Definition at line <a class="el" href="propmap_8hpp_source.html#l00058">58</a> of file <a class="el" href="propmap_8hpp_source.html">propmap.hpp</a>.</p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aa9c3813f90144fbea1a8012bee99cc54"></a><!-- doxytag: member="isis::util::PropertyMap::PropertyMap" ref="aa9c3813f90144fbea1a8012bee99cc54" args="(const Container &amp;src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">isis::util::PropertyMap::PropertyMap </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="propmap_8cpp_source.html#l00055">55</a> of file <a class="el" href="propmap_8cpp_source.html">propmap.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="afcc2f4657fbd500284e60e0ef442bbe6"></a><!-- doxytag: member="isis::util::PropertyMap::PropertyMap" ref="afcc2f4657fbd500284e60e0ef442bbe6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">isis::util::PropertyMap::PropertyMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="propmap_8cpp_source.html#l00063">63</a> of file <a class="el" href="propmap_8cpp_source.html">propmap.cpp</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a67214438f607248a64bb22a8574d322e"></a><!-- doxytag: member="isis::util::PropertyMap::addNeeded" ref="a67214438f607248a64bb22a8574d322e" args="(const KeyType &amp;path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void isis::util::PropertyMap::addNeeded </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classisis_1_1util_1_1PropertyMap.html#a22562fc95dac243746790a5c6a2aad85">KeyType</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a property with status needed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>identifies the property to be added or if already existsing to be flagged as needed </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="propmap_8cpp_source.html#l00490">490</a> of file <a class="el" href="propmap_8cpp_source.html">propmap.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="afc8dc03ba6f2f6988b133ab57e1aa26c"></a><!-- doxytag: member="isis::util::PropertyMap::addNeededFromString" ref="afc8dc03ba6f2f6988b133ab57e1aa26c" args="(const std::string &amp;needed)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void isis::util::PropertyMap::addNeededFromString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>needed</em></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make Properties given by a space separated list needed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">needed</td><td>string made of space serparated property-names which will (if neccessary) be added to the <a class="el" href="classisis_1_1util_1_1PropertyMap.html" title="This class forms a mapping tree to store all kinds of properties (path : value), where:value is:a uti...">PropertyMap</a> and flagged as needed. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="propmap_8cpp_source.html#l00496">496</a> of file <a class="el" href="propmap_8cpp_source.html">propmap.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a85ff9d6b80c5bd55628fd49da3023568"></a><!-- doxytag: member="isis::util::PropertyMap::branch" ref="a85ff9d6b80c5bd55628fd49da3023568" args="(const PropPath &amp;path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisis_1_1util_1_1PropertyMap.html">PropertyMap</a> &amp; isis::util::PropertyMap::branch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structisis_1_1util_1_1PropertyMap_1_1PropPath.html">PropPath</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Access the branch referenced by the path, create it if its not there. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>the path to the branch </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to the branching <a class="el" href="classisis_1_1util_1_1PropertyMap.html" title="This class forms a mapping tree to store all kinds of properties (path : value), where:value is:a uti...">PropertyMap</a> </dd></dl>

<p>Definition at line <a class="el" href="propmap_8cpp_source.html#l00207">207</a> of file <a class="el" href="propmap_8cpp_source.html">propmap.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7d0ac1e2070a996c40b57db1ab2dc93e"></a><!-- doxytag: member="isis::util::PropertyMap::branch" ref="a7d0ac1e2070a996c40b57db1ab2dc93e" args="(const PropPath &amp;path) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classisis_1_1util_1_1PropertyMap.html">PropertyMap</a> &amp; isis::util::PropertyMap::branch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structisis_1_1util_1_1PropertyMap_1_1PropPath.html">PropPath</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Access the branch referenced by the path. </p>
<p>If the branch does not exist, an empty dummy will returned. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>the path to the branch </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to the branching <a class="el" href="classisis_1_1util_1_1PropertyMap.html" title="This class forms a mapping tree to store all kinds of properties (path : value), where:value is:a uti...">PropertyMap</a> </dd></dl>

<p>Definition at line <a class="el" href="propmap_8cpp_source.html#l00194">194</a> of file <a class="el" href="propmap_8cpp_source.html">propmap.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="abb3518fa3c1e35033b4dee5cf9b2ca60"></a><!-- doxytag: member="isis::util::PropertyMap::find" ref="abb3518fa3c1e35033b4dee5cf9b2ca60" args="(KeyType key, bool allowProperty=true, bool allowBranch=false) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisis_1_1util_1_1PropertyMap.html#a22562fc95dac243746790a5c6a2aad85">isis::util::PropertyMap::KeyType</a> isis::util::PropertyMap::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classisis_1_1util_1_1PropertyMap.html#a22562fc95dac243746790a5c6a2aad85">KeyType</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowProperty</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowBranch</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Search for a property/branch in the whole Tree. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the single key for the branch/property to search for (paths will be stripped to the rightmost key) </td></tr>
    <tr><td class="paramname">allowProperty</td><td>if false the search will ignore properties </td></tr>
    <tr><td class="paramname">allowBranch</td><td>if false the search will ignore branches (it will still search into the branches, but the branches themself won't be considered a valid finding) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>full path to the property (including the properties name) if it is found, empty string elsewhise </dd></dl>

<p>Definition at line <a class="el" href="istring_8cpp_source.html#l00056">56</a> of file <a class="el" href="istring_8cpp_source.html">istring.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a72fdd04ff2b327bfb0c1c382737df54c"></a><!-- doxytag: member="isis::util::PropertyMap::findLists" ref="a72fdd04ff2b327bfb0c1c382737df54c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisis_1_1util_1_1PropertyMap.html#a2c8c8105e5fef4b913e634cbf6532a1c">PropertyMap::KeyList</a> isis::util::PropertyMap::findLists </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>find all non scalar entries </p>

<p>Definition at line <a class="el" href="propmap_8cpp_source.html#l00474">474</a> of file <a class="el" href="propmap_8cpp_source.html">propmap.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac6446eac6db55a9e7351fb37924c9386"></a><!-- doxytag: member="isis::util::PropertyMap::genKeyList" ref="ac6446eac6db55a9e7351fb37924c9386" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classisis_1_1util_1_1PropertyMap.html#a2c8c8105e5fef4b913e634cbf6532a1c">KeyList</a> isis::util::PropertyMap::genKeyList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>create a list of keys for every entry for which the given scalar predicate is true. </p>

<p>Definition at line <a class="el" href="propmap_8hpp_source.html#l00119">119</a> of file <a class="el" href="propmap_8hpp_source.html">propmap.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a92da4079cea64f8f92353322653e46bd"></a><!-- doxytag: member="isis::util::PropertyMap::getDifference" ref="a92da4079cea64f8f92353322653e46bd" args="(const PropertyMap &amp;second) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisis_1_1util_1_1PropertyMap.html#a0bfc17a3afe4a2a010e75c80f8883102">PropertyMap::DiffMap</a> isis::util::PropertyMap::getDifference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classisis_1_1util_1_1PropertyMap.html">PropertyMap</a> &amp;&#160;</td>
          <td class="paramname"><em>second</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a difference map of this tree and another. </p>
<p>Out of the names of differing properties a mapping from paths to std::pair&lt;<a class="el" href="classisis_1_1util_1_1PropertyValue.html" title="A very generic class to store values of properties.">PropertyValue</a>,<a class="el" href="classisis_1_1util_1_1PropertyValue.html" title="A very generic class to store values of properties.">PropertyValue</a>&gt; is created with following rules:</p>
<ul>
<li>if a Property is empty in this tree but set in second,<ul>
<li>it will be added with the first <a class="el" href="classisis_1_1util_1_1PropertyValue.html" title="A very generic class to store values of properties.">PropertyValue</a> emtpy and the second <a class="el" href="classisis_1_1util_1_1PropertyValue.html" title="A very generic class to store values of properties.">PropertyValue</a> taken from second</li>
</ul>
</li>
<li>if a Property is set in this tree but empty in second,<ul>
<li>it will be added with the first <a class="el" href="classisis_1_1util_1_1PropertyValue.html" title="A very generic class to store values of properties.">PropertyValue</a> taken from this and the second <a class="el" href="classisis_1_1util_1_1PropertyValue.html" title="A very generic class to store values of properties.">PropertyValue</a> empty</li>
</ul>
</li>
<li>if a Property is set in both, but not equal,<ul>
<li>it will be added with the first <a class="el" href="classisis_1_1util_1_1PropertyValue.html" title="A very generic class to store values of properties.">PropertyValue</a> taken from this and the second <a class="el" href="classisis_1_1util_1_1PropertyValue.html" title="A very generic class to store values of properties.">PropertyValue</a> taken from second</li>
</ul>
</li>
<li>if a Property is set in both and equal, or is empty in both,<ul>
<li>it wont be added <dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">second</td><td>the other tree to compare with </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a map of property paths and pairs of the corresponding different values </dd></dl>
</li>
</ul>
</li>
</ul>

<p>Definition at line <a class="el" href="propmap_8cpp_source.html#l00278">278</a> of file <a class="el" href="propmap_8cpp_source.html">propmap.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a77d485a4e4c1f236302b9b56eaaa9d47"></a><!-- doxytag: member="isis::util::PropertyMap::getFlatMap" ref="a77d485a4e4c1f236302b9b56eaaa9d47" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisis_1_1util_1_1PropertyMap.html#a402a5b6b4fed6b673af4fe6fdbd1e957">PropertyMap::FlatMap</a> isis::util::PropertyMap::getFlatMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>a flat representation of the whole property tree </dd></dl>

<p>Definition at line <a class="el" href="propmap_8cpp_source.html#l00431">431</a> of file <a class="el" href="propmap_8cpp_source.html">propmap.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa023972e1eb29afcea14916c2ae53288"></a><!-- doxytag: member="isis::util::PropertyMap::getKeys" ref="aa023972e1eb29afcea14916c2ae53288" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classisis_1_1util_1_1PropertyMap.html#a2c8c8105e5fef4b913e634cbf6532a1c">PropertyMap::KeyList</a> isis::util::PropertyMap::getKeys </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a list of the paths of all properties. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a flat list of the paths to all properties in the <a class="el" href="classisis_1_1util_1_1PropertyMap.html" title="This class forms a mapping tree to store all kinds of properties (path : value), where:value is:a uti...">PropertyMap</a> </dd></dl>

<p>Definition at line <a class="el" href="propmap_8cpp_source.html#l00467">467</a> of file <a class="el" href="propmap_8cpp_source.html">propmap.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad84de96685231d402bf9e8741a72db91"></a><!-- doxytag: member="isis::util::PropertyMap::getMissing" ref="ad84de96685231d402bf9e8741a72db91" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classisis_1_1util_1_1PropertyMap.html#a2c8c8105e5fef4b913e634cbf6532a1c">PropertyMap::KeyList</a> isis::util::PropertyMap::getMissing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a list of missing properties. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a list of the paths for all properties which are marked as needed and but are empty. </dd></dl>

<p>Definition at line <a class="el" href="propmap_8cpp_source.html#l00482">482</a> of file <a class="el" href="propmap_8cpp_source.html">propmap.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae3f42731036b6f53afbdbb063e03d958"></a><!-- doxytag: member="isis::util::PropertyMap::getPropertyAs" ref="ae3f42731036b6f53afbdbb063e03d958" args="(const PropPath &amp;path) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T isis::util::PropertyMap::getPropertyAs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structisis_1_1util_1_1PropertyMap_1_1PropPath.html">PropPath</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Request a property via the given key in the given type. </p>
<p>If the requested type is not equal to type the property is stored with, an automatic conversion is done. If that conversion failes an error is send to Runtime. </p>
<div class="fragment"><pre class="fragment"> getPropertyAs&lt;isis::util::fvector4&gt;( <span class="stringliteral">&quot;MyPropertyName&quot;</span> );
</pre></div> <dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>the path to the property </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the property with given type, if not set yet T() is returned. </dd></dl>

<p>Definition at line <a class="el" href="propmap_8hpp_source.html#l00497">497</a> of file <a class="el" href="propmap_8hpp_source.html">propmap.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5685f66f48885d31f53d8714cd3ebbd0"></a><!-- doxytag: member="isis::util::PropertyMap::hasBranch" ref="a5685f66f48885d31f53d8714cd3ebbd0" args="(const PropPath &amp;path) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isis::util::PropertyMap::hasBranch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structisis_1_1util_1_1PropertyMap_1_1PropPath.html">PropPath</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>check if branch of the tree is available </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>the path to the branch </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the given branch does exist and is not empty, false otherwise </dd></dl>

<p>Definition at line <a class="el" href="propmap_8cpp_source.html#l00546">546</a> of file <a class="el" href="propmap_8cpp_source.html">propmap.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ace197e0a37714072c4b8a9c9096018a1"></a><!-- doxytag: member="isis::util::PropertyMap::hasProperty" ref="ace197e0a37714072c4b8a9c9096018a1" args="(const PropPath &amp;path) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isis::util::PropertyMap::hasProperty </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structisis_1_1util_1_1PropertyMap_1_1PropPath.html">PropPath</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>check if a property is available </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>the path to the property </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the given property does exist and is not empty, false otherwise </dd></dl>

<p>Definition at line <a class="el" href="propmap_8cpp_source.html#l00506">506</a> of file <a class="el" href="propmap_8cpp_source.html">propmap.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4a6bae8173d0a0e910903a634be674af"></a><!-- doxytag: member="isis::util::PropertyMap::isEmpty" ref="a4a6bae8173d0a0e910903a634be674af" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isis::util::PropertyMap::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the <a class="el" href="classisis_1_1util_1_1PropertyMap.html" title="This class forms a mapping tree to store all kinds of properties (path : value), where:value is:a uti...">PropertyMap</a> is empty, false otherwhise </dd></dl>

<p>Reimplemented in <a class="el" href="classisis_1_1data_1_1Image.html#a9fb0c9f8351fddc6a2fea609d487aa2b">isis::data::Image</a>.</p>

<p>Definition at line <a class="el" href="propmap_8cpp_source.html#l00273">273</a> of file <a class="el" href="propmap_8cpp_source.html">propmap.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7f4ea1b7c43edfce313d70dc7f68addc"></a><!-- doxytag: member="isis::util::PropertyMap::isValid" ref="a7f4ea1b7c43edfce313d70dc7f68addc" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isis::util::PropertyMap::isValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if every property marked as needed is set. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if ALL needed properties are NOT empty, false otherwhise. </dd></dl>

<p>Definition at line <a class="el" href="propmap_8cpp_source.html#l00266">266</a> of file <a class="el" href="propmap_8cpp_source.html">propmap.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8f5f0388f7901b9f4ee4afeb7732ba42"></a><!-- doxytag: member="isis::util::PropertyMap::join" ref="a8f5f0388f7901b9f4ee4afeb7732ba42" args="(const isis::util::PropertyMap &amp;other, bool overwrite=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisis_1_1util_1_1PropertyMap.html#a2c8c8105e5fef4b913e634cbf6532a1c">PropertyMap::KeyList</a> isis::util::PropertyMap::join </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classisis_1_1util_1_1PropertyMap.html">isis::util::PropertyMap</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>overwrite</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add Properties from another tree. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the other tree to join with </td></tr>
    <tr><td class="paramname">overwrite</td><td>if existing properties shall be replaced </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a list of the rejected properties that couldn't be inserted, for success this should be empty </dd></dl>

<p>Definition at line <a class="el" href="propmap_8cpp_source.html#l00381">381</a> of file <a class="el" href="propmap_8cpp_source.html">propmap.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a380618b20d3c787500207317400ea383"></a><!-- doxytag: member="isis::util::PropertyMap::makeFlatMap" ref="a380618b20d3c787500207317400ea383" args="(FlatMap &amp;out, KeyType key_prefix=&quot;&quot;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void isis::util::PropertyMap::makeFlatMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classisis_1_1util_1_1PropertyMap.html#a402a5b6b4fed6b673af4fe6fdbd1e957">FlatMap</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classisis_1_1util_1_1PropertyMap.html#a22562fc95dac243746790a5c6a2aad85">KeyType</a>&#160;</td>
          <td class="paramname"><em>key_prefix</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>copy the tree into a flat key/property-map </p>

<p>Definition at line <a class="el" href="propmap_8cpp_source.html#l00418">418</a> of file <a class="el" href="propmap_8cpp_source.html">propmap.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1e93ada16242a03c04b787bc6ae6f413"></a><!-- doxytag: member="isis::util::PropertyMap::operator==" ref="a1e93ada16242a03c04b787bc6ae6f413" args="(const PropertyMap &amp;src) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isis::util::PropertyMap::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classisis_1_1util_1_1PropertyMap.html">PropertyMap</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="propmap_8cpp_source.html#l00057">57</a> of file <a class="el" href="propmap_8cpp_source.html">propmap.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9485ad2dbf2e7f5f8ec393c41d9ebd73"></a><!-- doxytag: member="isis::util::PropertyMap::print" ref="a9485ad2dbf2e7f5f8ec393c41d9ebd73" args="(std::ostream &amp;out, bool label=false) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; isis::util::PropertyMap::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>label</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>"Print" the property tree. </p>
<p>Will send the name and the result of PropertyValue-&gt;toString(label) to the given ostream. Is equivalent to common streaming operation but has the option to print the type of the printed properties. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to use </td></tr>
    <tr><td class="paramname">label</td><td>print the type of the property (see <a class="el" href="classisis_1_1util_1_1Value.html#a0794ebacbce8236ecef00e9785f6a27a" title="Get the string representation of the Value.">Value::toString()</a>) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="propmap_8cpp_source.html#l00585">585</a> of file <a class="el" href="propmap_8cpp_source.html">propmap.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4c656dc09e8b6b41f96dd9e396ac20df"></a><!-- doxytag: member="isis::util::PropertyMap::propertyValue" ref="a4c656dc09e8b6b41f96dd9e396ac20df" args="(const PropPath &amp;path) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classisis_1_1util_1_1PropertyValue.html">PropertyValue</a> &amp; isis::util::PropertyMap::propertyValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structisis_1_1util_1_1PropertyMap_1_1PropPath.html">PropPath</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Access the property referenced by the path. </p>
<p>If the property does not exist, an empty dummy will returned. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>the path to the property </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to the <a class="el" href="classisis_1_1util_1_1PropertyValue.html" title="A very generic class to store values of properties.">PropertyValue</a> </dd></dl>

<p>Definition at line <a class="el" href="propmap_8cpp_source.html#l00182">182</a> of file <a class="el" href="propmap_8cpp_source.html">propmap.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aeabcb29b04b303b2264501b4b05bfcac"></a><!-- doxytag: member="isis::util::PropertyMap::propertyValue" ref="aeabcb29b04b303b2264501b4b05bfcac" args="(const PropPath &amp;path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisis_1_1util_1_1PropertyValue.html">PropertyValue</a> &amp; isis::util::PropertyMap::propertyValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structisis_1_1util_1_1PropertyMap_1_1PropPath.html">PropPath</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Access the property referenced by the path, create it if its not there. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>the path to the property </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to the <a class="el" href="classisis_1_1util_1_1PropertyValue.html" title="A very generic class to store values of properties.">PropertyValue</a> </dd></dl>

<p>Definition at line <a class="el" href="propmap_8cpp_source.html#l00187">187</a> of file <a class="el" href="propmap_8cpp_source.html">propmap.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="af85f7af2c66875efbbb475d5e03f7ed3"></a><!-- doxytag: member="isis::util::PropertyMap::propertyValueVec" ref="af85f7af2c66875efbbb475d5e03f7ed3" args="(const PropPath &amp;path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classisis_1_1util_1_1PropertyValue.html">PropertyValue</a> &gt; &amp; isis::util::PropertyMap::propertyValueVec </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structisis_1_1util_1_1PropertyMap_1_1PropPath.html">PropPath</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Access the property vector referenced by the path-key, create it if its not there. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>the path to the property </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to the <a class="el" href="classisis_1_1util_1_1PropertyValue.html" title="A very generic class to store values of properties.">PropertyValue</a> </dd></dl>

<p>Definition at line <a class="el" href="propmap_8cpp_source.html#l00174">174</a> of file <a class="el" href="propmap_8cpp_source.html">propmap.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac1fcaf297115450ea4eaf67b2a68513c"></a><!-- doxytag: member="isis::util::PropertyMap::propertyValueVec" ref="ac1fcaf297115450ea4eaf67b2a68513c" args="(const PropPath &amp;path) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classisis_1_1util_1_1PropertyValue.html">PropertyValue</a> &gt; &amp; isis::util::PropertyMap::propertyValueVec </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structisis_1_1util_1_1PropertyMap_1_1PropPath.html">PropPath</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Access the property vector referenced by the path. </p>
<p>If the property does not exist, an empty dummy will be returned. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>the path to the property </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to the <a class="el" href="classisis_1_1util_1_1PropertyValue.html" title="A very generic class to store values of properties.">PropertyValue</a> </dd></dl>

<p>Definition at line <a class="el" href="propmap_8cpp_source.html#l00161">161</a> of file <a class="el" href="propmap_8cpp_source.html">propmap.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a858eed4423e3984ca1f2e6537228b6d8"></a><!-- doxytag: member="isis::util::PropertyMap::remove" ref="a858eed4423e3984ca1f2e6537228b6d8" args="(const KeyList &amp;removeList, bool keep_needed=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isis::util::PropertyMap::remove </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classisis_1_1util_1_1PropertyMap.html#a2c8c8105e5fef4b913e634cbf6532a1c">KeyList</a> &amp;&#160;</td>
          <td class="paramname"><em>removeList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>keep_needed</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>remove every property which is also in the given list (regardless of the value) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">removeList</td><td>a list of paths naming the properties to be removed </td></tr>
    <tr><td class="paramname">keep_needed</td><td>when true needed properties are kept even if they would be removed otherwise </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if all properties removed succesfully, false otherwise </dd></dl>

<p>Definition at line <a class="el" href="propmap_8cpp_source.html#l00218">218</a> of file <a class="el" href="propmap_8cpp_source.html">propmap.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a00b589b778915334bc9ef9c36e296c7d"></a><!-- doxytag: member="isis::util::PropertyMap::remove" ref="a00b589b778915334bc9ef9c36e296c7d" args="(const PropertyMap &amp;removeMap, bool keep_needed=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isis::util::PropertyMap::remove </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classisis_1_1util_1_1PropertyMap.html">PropertyMap</a> &amp;&#160;</td>
          <td class="paramname"><em>removeMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>keep_needed</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>remove every property which is also in the given tree (regardless of the value) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">removeMap</td><td>the tree of properties to be removed </td></tr>
    <tr><td class="paramname">keep_needed</td><td>when true needed properties are kept even if they would be removed otherwise </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if all properties removed succesfully, false otherwise </dd></dl>

<p>Definition at line <a class="el" href="propmap_8cpp_source.html#l00232">232</a> of file <a class="el" href="propmap_8cpp_source.html">propmap.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4db5950cdd32941a590cb75fcc00f3ad"></a><!-- doxytag: member="isis::util::PropertyMap::remove" ref="a4db5950cdd32941a590cb75fcc00f3ad" args="(const PropPath &amp;path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isis::util::PropertyMap::remove </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structisis_1_1util_1_1PropertyMap_1_1PropPath.html">PropPath</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove the property adressed by the path. </p>
<p>This actually only removes properties. Non-empty branches are not deleted. And if an branch becomes empty after deletion of its last entry, it is deleted automatically. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>the path to the property </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if successful, false otherwise </dd></dl>

<p>Definition at line <a class="el" href="propmap_8cpp_source.html#l00213">213</a> of file <a class="el" href="propmap_8cpp_source.html">propmap.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad743c0b3afee400fb579b931064196aa"></a><!-- doxytag: member="isis::util::PropertyMap::removeEqual" ref="ad743c0b3afee400fb579b931064196aa" args="(const isis::util::PropertyMap &amp;other, bool removeNeeded=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void isis::util::PropertyMap::removeEqual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classisis_1_1util_1_1PropertyMap.html">isis::util::PropertyMap</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>removeNeeded</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove every <a class="el" href="classisis_1_1util_1_1PropertyValue.html" title="A very generic class to store values of properties.">PropertyValue</a> which is also in the other <a class="el" href="classisis_1_1util_1_1PropertyMap.html" title="This class forms a mapping tree to store all kinds of properties (path : value), where:value is:a uti...">PropertyMap</a> and where operator== returns true. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the other property tree to compare to </td></tr>
    <tr><td class="paramname">removeNeeded</td><td>if a property should also be deleted it is needed </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="propmap_8cpp_source.html#l00342">342</a> of file <a class="el" href="propmap_8cpp_source.html">propmap.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2d1267ed81e4d76c6a875e8d22bb42c2"></a><!-- doxytag: member="isis::util::PropertyMap::rename" ref="a2d1267ed81e4d76c6a875e8d22bb42c2" args="(const PropPath &amp;from, const PropPath &amp;to)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isis::util::PropertyMap::rename </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structisis_1_1util_1_1PropertyMap_1_1PropPath.html">PropPath</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structisis_1_1util_1_1PropertyMap_1_1PropPath.html">PropPath</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rename a given property/branch. </p>
<p>This is implemented as copy+delete and can also be used between branches.</p>
<ul>
<li>if the target exist a warning will be send, but it will still be overwritten</li>
<li>if the source does not exist a warning will be send and nothing is done <dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>the path of the existing property to be moved </td></tr>
    <tr><td class="paramname">to</td><td>the destinaton path of the move </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if renaming/moving was successful </dd></dl>
</li>
</ul>

<p>Definition at line <a class="el" href="propmap_8cpp_source.html#l00552">552</a> of file <a class="el" href="propmap_8cpp_source.html">propmap.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="adee60064ebd5e24f31c31dcf8750eb29"></a><!-- doxytag: member="isis::util::PropertyMap::setPropertyAs" ref="adee60064ebd5e24f31c31dcf8750eb29" args="(const PropPath &amp;path, const T &amp;val)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisis_1_1util_1_1PropertyValue.html">PropertyValue</a>&amp; isis::util::PropertyMap::setPropertyAs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structisis_1_1util_1_1PropertyMap_1_1PropPath.html">PropPath</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the given property to a given value/type. </p>
<p>The needed flag (if set) will be kept. If the property is already set to a value of another type an error is send to Runtime and nothing will be set. But a property of the same type will be overwritten. </p>
<div class="fragment"><pre class="fragment"> <a class="code" href="classisis_1_1util_1_1PropertyMap.html#adee60064ebd5e24f31c31dcf8750eb29" title="Set the given property to a given value/type.">setPropertyAs</a>(<span class="stringliteral">&quot;MyPropertyName&quot;</span>, <a class="code" href="classisis_1_1util_1_1vector4.html">isis::util::fvector4</a>(1,0,1,0))
</pre></div> <dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>the path to the property </td></tr>
    <tr><td class="paramname">val</td><td>the value to set of type T </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to the <a class="el" href="classisis_1_1util_1_1PropertyValue.html" title="A very generic class to store values of properties.">PropertyValue</a> (this can be used later, e.g. if a vector is filled step by step the reference can be used to not ask for the Property each time) </dd></dl>

<p>Definition at line <a class="el" href="propmap_8hpp_source.html#l00359">359</a> of file <a class="el" href="propmap_8hpp_source.html">propmap.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8761e90a0f2c2dcd021f2325a4b8f263"></a><!-- doxytag: member="isis::util::PropertyMap::toCommonUnique" ref="a8761e90a0f2c2dcd021f2325a4b8f263" args="(PropertyMap &amp;common, std::set&lt; KeyType &gt; &amp;uniques, bool init) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void isis::util::PropertyMap::toCommonUnique </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classisis_1_1util_1_1PropertyMap.html">PropertyMap</a> &amp;&#160;</td>
          <td class="paramname"><em>common</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; <a class="el" href="classisis_1_1util_1_1PropertyMap.html#a22562fc95dac243746790a5c6a2aad85">KeyType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>uniques</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>init</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get common and unique properties from the tree. </p>
<p>For every entry of the tree this checks if it is common/unique and removes/adds it accordingly. This is done by:</p>
<ul>
<li>generating a difference (using diff) between the current common and the tree<ul>
<li>the resulting diff_map contains all newly unique properties (properties which has been in common, but are not euqual in the tree)</li>
</ul>
</li>
<li>these newly diffent properties are removed from common and added to unique.</li>
<li>if init is true uniques is cleared and common is replaced by a copy of the tree (shall be done at first step) <dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">common</td><td>reference of the common-tree </td></tr>
    <tr><td class="paramname">uniques</td><td>reference of the unique-tree </td></tr>
    <tr><td class="paramname">init</td><td>if initialisation shall be done instead of normal seperation </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

<p>Definition at line <a class="el" href="propmap_8cpp_source.html#l00569">569</a> of file <a class="el" href="propmap_8cpp_source.html">propmap.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8c1624769a45f6aca280cf45b0577d33"></a><!-- doxytag: member="isis::util::PropertyMap::transform" ref="a8c1624769a45f6aca280cf45b0577d33" args="(const PropPath &amp;from, const PropPath &amp;to, int dstID, bool delSource=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isis::util::PropertyMap::transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structisis_1_1util_1_1PropertyMap_1_1PropPath.html">PropPath</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structisis_1_1util_1_1PropertyMap_1_1PropPath.html">PropPath</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dstID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>delSource</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transform an existing property into another. </p>
<p>Converts the value of the given property into the requested type and stores it with the given new path. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>the path of the property to be transformed </td></tr>
    <tr><td class="paramname">to</td><td>the path for the new property </td></tr>
    <tr><td class="paramname">dstID</td><td>the type-ID of the new property value </td></tr>
    <tr><td class="paramname">delSource</td><td>if the original property shall be deleted after the tramsformation was done </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the transformation was done, false it failed </dd></dl>

<p>Definition at line <a class="el" href="propmap_8cpp_source.html#l00439">439</a> of file <a class="el" href="propmap_8cpp_source.html">propmap.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5fa02559317b63e5c6a18cffadefabdd"></a><!-- doxytag: member="isis::util::PropertyMap::transform" ref="a5fa02559317b63e5c6a18cffadefabdd" args="(const PropPath &amp;from, const PropPath &amp;to, bool delSource=true)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DST &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool isis::util::PropertyMap::transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structisis_1_1util_1_1PropertyMap_1_1PropPath.html">PropPath</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structisis_1_1util_1_1PropertyMap_1_1PropPath.html">PropPath</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>delSource</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transform an existing property into another (statically typed version). </p>
<p>Converts the value of the given property into the requested type and stores it with the given new path. A compile-time check is done to test if the requested type is available. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>the path of the property to be transformed </td></tr>
    <tr><td class="paramname">to</td><td>the path for the new property </td></tr>
    <tr><td class="paramname">delSource</td><td>if the original property shall be deleted after the tramsformation was done </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the transformation was done, false it failed </dd></dl>

<p>Definition at line <a class="el" href="propmap_8hpp_source.html#l00337">337</a> of file <a class="el" href="propmap_8hpp_source.html">propmap.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/SCR/isis/lib/Core/CoreUtils/<a class="el" href="propmap_8hpp_source.html">propmap.hpp</a></li>
<li>/SCR/isis/lib/Core/CoreUtils/<a class="el" href="istring_8cpp_source.html">istring.cpp</a></li>
<li>/SCR/isis/lib/Core/CoreUtils/<a class="el" href="propmap_8cpp_source.html">propmap.cpp</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Feb 21 2012 18:41:49 for ISIS Core Library by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
