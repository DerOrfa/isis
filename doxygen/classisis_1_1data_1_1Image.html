<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ISIS Core Library: isis::data::Image Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">ISIS Core Library&#160;<span id="projectnumber">0.4.7 (api 0.0.0)</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceisis.html">isis</a>      </li>
      <li class="navelem"><a class="el" href="namespaceisis_1_1data.html">data</a>      </li>
      <li class="navelem"><a class="el" href="classisis_1_1data_1_1Image.html">Image</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a>  </div>
  <div class="headertitle">
<h1>isis::data::Image Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="isis::data::Image" --><!-- doxytag: inherits="NDimensional&lt; 4 &gt;,isis::util::PropertyMap" -->
<p>Main class for generic 4D-images.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="image_8hpp_source.html">image.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for isis::data::Image:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classisis_1_1data_1_1Image.png" usemap="#isis::data::Image_map" alt=""/>
  <map id="isis::data::Image_map" name="isis::data::Image_map">
<area href="classisis_1_1data_1_1__internal_1_1NDimensional.html" alt="isis::data::_internal::NDimensional&lt; 4 &gt;" shape="rect" coords="0,0,229,24"/>
<area href="classisis_1_1util_1_1PropertyMap.html" alt="isis::util::PropertyMap" shape="rect" coords="239,0,468,24"/>
<area href="classisis_1_1data_1_1TypedImage.html" alt="isis::data::TypedImage&lt; T &gt;" shape="rect" coords="119,112,348,136"/>
<area href="classisis_1_1data_1_1MemImage.html" alt="isis::data::MemImage&lt; T &gt;" shape="rect" coords="119,168,348,192"/>
</map>
 </div></div>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="classisis_1_1data_1_1__internal_1_1ImageIteratorTemplate.html">_internal::ImageIteratorTemplate</a><br class="typebreak"/>
&lt; const <a class="el" href="classisis_1_1data_1_1Chunk.html">Chunk</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#a21407a9c75b9ea3f50e52664d4f7a19e">const_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef const_iterator::reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#aaaebaaac8caa5b11a0d81c6a286c55e4">const_reference</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="classisis_1_1data_1_1__internal_1_1ImageIteratorTemplate.html">_internal::ImageIteratorTemplate</a><br class="typebreak"/>
&lt; <a class="el" href="classisis_1_1data_1_1Chunk.html">Chunk</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#a76dc53ed34c1c73d797f50ef182d7f4a">iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#ac83f7eecffd172b0c0759cb5ee7dd633">orientation</a> { <br/>
&#160;&#160;<a class="el" href="classisis_1_1data_1_1Image.html#ac83f7eecffd172b0c0759cb5ee7dd633aee38808f2b23291db3fbb0aebe7ba405">axial</a>, 
<a class="el" href="classisis_1_1data_1_1Image.html#ac83f7eecffd172b0c0759cb5ee7dd633a64a137c1013ea7f831d25c8701c0693d">reversed_axial</a>, 
<a class="el" href="classisis_1_1data_1_1Image.html#ac83f7eecffd172b0c0759cb5ee7dd633a0d4cbf4f6526d1d6895c71e6bea6542c">sagittal</a>, 
<a class="el" href="classisis_1_1data_1_1Image.html#ac83f7eecffd172b0c0759cb5ee7dd633a3adbf32c9b5579e6e97586301f48e047">reversed_sagittal</a>, 
<br/>
&#160;&#160;<a class="el" href="classisis_1_1data_1_1Image.html#ac83f7eecffd172b0c0759cb5ee7dd633ad77b748bff3861529f19469104a94e6c">coronal</a>, 
<a class="el" href="classisis_1_1data_1_1Image.html#ac83f7eecffd172b0c0759cb5ee7dd633af6335ced67866cc519e297f42ee64caa">reversed_coronal</a>
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef iterator::reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#a4cb25846b5e8e6539e710416b81d4e61">reference</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classisis_1_1data_1_1Image.html#a76dc53ed34c1c73d797f50ef182d7f4a">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#abf0729737cf6906a0aa6c1e830c0d728">begin</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classisis_1_1data_1_1Image.html#a21407a9c75b9ea3f50e52664d4f7a19e">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#aa7798a003e27e1c12de7f30f06aede92">begin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#acd213fa6d0856d45e6413801f9bdec66">checkMakeClean</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#a0750957ebf3422a0fbb3d029cc9b292a">compare</a> (const <a class="el" href="classisis_1_1data_1_1Image.html">Image</a> &amp;comp) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the voxel-values of this image to the given.  <a href="#a0750957ebf3422a0fbb3d029cc9b292a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#a582f927569aba48d8626c9a7d941ded1">convertToType</a> (unsigned short ID)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensure, the image has the type with the requested ID.  <a href="#a582f927569aba48d8626c9a7d941ded1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classisis_1_1data_1_1Chunk.html">isis::data::Chunk</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#a2fd76bb61355c14ef7035e740b462a5e">copyChunksToVector</a> (bool copy_metadata=true) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a sorted list of the chunks of the image.  <a href="#a2fd76bb61355c14ef7035e740b462a5e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#a1849844422ad86be44556bbab0d55088">copyToMem</a> (T *dst, size_t len, <a class="el" href="namespaceisis_1_1data.html#ac2873e5e7a9637d4ac68253dcf140ff4">scaling_pair</a> scaling=<a class="el" href="namespaceisis_1_1data.html#ac2873e5e7a9637d4ac68253dcf140ff4">scaling_pair</a>()) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy all voxel data of the image into memory.  <a href="#a1849844422ad86be44556bbab0d55088"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classisis_1_1data_1_1MemChunk.html">MemChunk</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#ad4c4bf9e84ee707c221cb5140cfb8f3f">copyToMemChunk</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy all voxel data into a new <a class="el" href="classisis_1_1data_1_1MemChunk.html" title="Chunk class for memory-based buffers.">MemChunk</a>.  <a href="#ad4c4bf9e84ee707c221cb5140cfb8f3f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classisis_1_1data_1_1Image.html#a76dc53ed34c1c73d797f50ef182d7f4a">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#ade432319d06fc1638e617457d585e48d">end</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classisis_1_1data_1_1Image.html#a21407a9c75b9ea3f50e52664d4f7a19e">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#ac00259c20d41ad6266b1ad3c92b3b499">end</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#aac647fb29128d16d528059d481c79874">foreachChunk</a> (<a class="el" href="classisis_1_1data_1_1ChunkOp.html">ChunkOp</a> &amp;op, bool copyMetaData=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Run a functor with the base <a class="el" href="classisis_1_1data_1_1ChunkOp.html" title="Base class for operators used for foreachChunk.">ChunkOp</a> on every cunk in the image.  <a href="#aac647fb29128d16d528059d481c79874"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#a22b33e80caee653a22653f6aa04bd048">foreachVoxel</a> (<a class="el" href="classisis_1_1data_1_1VoxelOp.html">VoxelOp</a>&lt; TYPE &gt; &amp;op)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Run a functor with the base <a class="el" href="classisis_1_1data_1_1VoxelOp.html" title="Base class for operators used for foreachVoxel.">VoxelOp</a> on every chunk in the image.  <a href="#a22b33e80caee653a22653f6aa04bd048"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#a873a72def2728e8cfc060ee8c6ac6bd3">getBytesPerVoxel</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">get the voxelsize (in bytes) for the major type in the image  <a href="#a873a72def2728e8cfc060ee8c6ac6bd3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classisis_1_1data_1_1Chunk.html">Chunk</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#afda7218833647cc6526950524775140d">getChunk</a> (size_t first, size_t second=0, size_t third=0, size_t fourth=0, bool copy_metadata=true) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the chunk that contains the voxel at the given coordinates.  <a href="#afda7218833647cc6526950524775140d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classisis_1_1data_1_1Chunk.html">Chunk</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#a882f5172bca7221c71954efdf6d0f9de">getChunk</a> (size_t first, size_t second=0, size_t third=0, size_t fourth=0, bool copy_metadata=true)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the chunk that contains the voxel at the given coordinates.  <a href="#a882f5172bca7221c71954efdf6d0f9de"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classisis_1_1data_1_1Chunk.html">Chunk</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#a815e76cb9cc68006b2bbdad2cd9ded7c">getChunkAs</a> (size_t first, size_t second=0, size_t third=0, size_t fourth=0, bool copy_metadata=true) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the chunk that contains the voxel at the given coordinates in the given type.  <a href="#a815e76cb9cc68006b2bbdad2cd9ded7c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classisis_1_1data_1_1Chunk.html">Chunk</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#a72a398bd1f12cb27bc33bf0e1c693995">getChunkAs</a> (const <a class="el" href="namespaceisis_1_1data.html#ac2873e5e7a9637d4ac68253dcf140ff4">scaling_pair</a> &amp;scaling, size_t first, size_t second=0, size_t third=0, size_t fourth=0, bool copy_metadata=true) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the chunk that contains the voxel at the given coordinates in the given type (fast version).  <a href="#a72a398bd1f12cb27bc33bf0e1c693995"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classisis_1_1data_1_1Chunk.html">Chunk</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#a27cfa5f9ced2077e578ad4bcc064e028">getChunkAt</a> (size_t at, bool copy_metadata=true) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a chunk via index (and the lookup table).  <a href="#a27cfa5f9ced2077e578ad4bcc064e028"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::list&lt; <a class="el" href="classisis_1_1util_1_1PropertyValue.html">util::PropertyValue</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#a97524a597e61074c8b4b2e6e0ebdf8e6">getChunksProperties</a> (const <a class="el" href="classisis_1_1util_1_1PropertyMap.html#a22562fc95dac243746790a5c6a2aad85">util::PropertyMap::KeyType</a> &amp;key, bool unique=false) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of the properties of the chunks for the given key.  <a href="#a97524a597e61074c8b4b2e6e0ebdf8e6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classisis_1_1util_1_1vector4.html">util::fvector4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#a36e107da6a3d4744468b3c837534291b">getFoV</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classisis_1_1util_1_1vector4.html">util::ivector4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#aacbf0d66df0ec2ddfe0e8d73d2eddc39">getIndexFromPhysicalCoords</a> (const <a class="el" href="classisis_1_1util_1_1vector4.html">util::fvector4</a> &amp;physicalCoords, bool restrictedToImageBox=false) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the voxel index of the given physical coordinates (coordinates in scanner space) This function does not perform any test if the physical coordinates are inside the image.  <a href="#aacbf0d66df0ec2ddfe0e8d73d2eddc39"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classisis_1_1data_1_1Image.html#ac83f7eecffd172b0c0759cb5ee7dd633">orientation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#a5d4c287dbd53f05174f3070029e19ce9">getMainOrientation</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#a601eaac6eedf7eaf6fdb6c31b1e8765d">getMajorTypeID</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type of the chunk with "biggest" type.  <a href="#a601eaac6eedf7eaf6fdb6c31b1e8765d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#a6d5302c9e0de9fe8c97fbafa4a9e2d1e">getMajorTypeName</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::pair<br class="typebreak"/>
&lt; <a class="el" href="classisis_1_1util_1_1__internal_1_1ValueReference.html">util::ValueReference</a>, <br class="typebreak"/>
<a class="el" href="classisis_1_1util_1_1__internal_1_1ValueReference.html">util::ValueReference</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#ab437a008e59944a63c9fdc844c673ad6">getMinMax</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum and the minimum voxel value of the image as a pair of ValueReference-objects.  <a href="#ab437a008e59944a63c9fdc844c673ad6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; T, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#ae4bef75405f6729ab6c81191dc23bfc0">getMinMaxAs</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum and the minimum voxel value of the image.  <a href="#ae4bef75405f6729ab6c81191dc23bfc0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#a01c02d76de0a741e527ff1e43b39422b">getNrOfColumns</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#ace627e4628e39615cbae3b6b43b9d915">getNrOfRows</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#a922ea56dd2eb60fbb6e0299138dcde70">getNrOfSlices</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#a142c7b80e200d9822c28fc604bb031ee">getNrOfTimesteps</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classisis_1_1util_1_1vector4.html">util::fvector4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#a2e83ae32400db8cea79ece348a0acffe">getPhysicalCoordsFromIndex</a> (const <a class="el" href="classisis_1_1util_1_1vector4.html">util::ivector4</a> &amp;index) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the physical coordinates (in scanner space) of the given voxel index.  <a href="#a2e83ae32400db8cea79ece348a0acffe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceisis_1_1data.html#ac2873e5e7a9637d4ac68253dcf140ff4">scaling_pair</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#a789138e66345f3e5a73c65dbf05b2940">getScalingTo</a> (unsigned short typeID, <a class="el" href="namespaceisis_1_1data.html#a69354ef53dcb79cbe577ae5fe8764e49">autoscaleOption</a> scaleopt=autoscale) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">for each chunk get the scaling (and offset) which would be used in an conversion to the given type  <a href="#a789138e66345f3e5a73c65dbf05b2940"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classisis_1_1util_1_1__internal_1_1ValueReference.html">util::ValueReference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#ab07f75534c9edeab26dc46c68c99771a">getVoxelValue</a> (size_t nrOfColumns, size_t nrOfRows=0, size_t nrOfSlices=0, size_t nrOfTimesteps=0) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#a0ad493c5fbfed450e4f933097ee81951">Image</a> (const <a class="el" href="classisis_1_1data_1_1Image.html">Image</a> &amp;ref)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a0ad493c5fbfed450e4f933097ee81951"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#af9539532e4fb1458c559f13a6b770174">Image</a> (std::vector&lt; T &gt; &amp;chunks, <a class="el" href="namespaceisis_1_1data.html#a157a8a81ce7fb08f84af9c27b7d251a3">dimensions</a> min_dim=rowDim)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create image from a vector of Chunks or objects with the base <a class="el" href="classisis_1_1data_1_1Chunk.html" title="Main class for four-dimensional random-access data blocks.">Chunk</a>.  <a href="#af9539532e4fb1458c559f13a6b770174"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#a62c50f70497b9094bb2c541b797971f6">Image</a> (const <a class="el" href="classisis_1_1data_1_1Chunk.html">Chunk</a> &amp;chunk, <a class="el" href="namespaceisis_1_1data.html#a157a8a81ce7fb08f84af9c27b7d251a3">dimensions</a> min_dim=rowDim)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create image from a single chunk.  <a href="#a62c50f70497b9094bb2c541b797971f6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#ac8448f89faef184720e5ae079873c7ee">Image</a> (std::list&lt; T &gt; &amp;chunks, <a class="el" href="namespaceisis_1_1data.html#a157a8a81ce7fb08f84af9c27b7d251a3">dimensions</a> min_dim=rowDim)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create image from a list of Chunks or objects with the base <a class="el" href="classisis_1_1data_1_1Chunk.html" title="Main class for four-dimensional random-access data blocks.">Chunk</a>.  <a href="#ac8448f89faef184720e5ae079873c7ee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#a14a33c4d2ba857b38c2188fb8e8abfd9">insertChunk</a> (const <a class="el" href="classisis_1_1data_1_1Chunk.html">Chunk</a> &amp;chunk)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a <a class="el" href="classisis_1_1data_1_1Chunk.html" title="Main class for four-dimensional random-access data blocks.">Chunk</a> into the <a class="el" href="classisis_1_1data_1_1Image.html" title="Main class for generic 4D-images.">Image</a>.  <a href="#a14a33c4d2ba857b38c2188fb8e8abfd9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#a507228763078c1c0ed6cc5b92c4cc65a">insertChunksFromContainer</a> (T &amp;chunks)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert Chunks or objects with the base <a class="el" href="classisis_1_1data_1_1Chunk.html" title="Main class for four-dimensional random-access data blocks.">Chunk</a> from a sequence container into the <a class="el" href="classisis_1_1data_1_1Image.html" title="Main class for generic 4D-images.">Image</a>.  <a href="#a507228763078c1c0ed6cc5b92c4cc65a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#a102fa197eedd6a7cc8642254be953656">isClean</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#a9fb0c9f8351fddc6a2fea609d487aa2b">isEmpty</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceisis_1_1data.html#a157a8a81ce7fb08f84af9c27b7d251a3">dimensions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#a153f570319fc42ea6f1123a5a5eb309c">mapScannerAxisToImageDimension</a> (<a class="el" href="namespaceisis_1_1data.html#addc0484ee8054d9e855bbd264c978b99">scannerAxis</a> scannerAxes)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps the given scanner Axis to the dimension with the minimal angle.  <a href="#a153f570319fc42ea6f1123a5a5eb309c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classisis_1_1data_1_1Image.html">Image</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#aae95616fad335432d8ce3b5e5daf004a">operator=</a> (const <a class="el" href="classisis_1_1data_1_1Image.html">Image</a> &amp;ref)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy operator.  <a href="#aae95616fad335432d8ce3b5e5daf004a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#a801a02eb15ae94b384aaa97061e2ad1c">reIndex</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">(Re)computes the image layout and metadata.  <a href="#a801a02eb15ae94b384aaa97061e2ad1c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#a7f573a7b5d73ba8abcadb337e43f73bc">setIndexingDim</a> (<a class="el" href="namespaceisis_1_1data.html#a157a8a81ce7fb08f84af9c27b7d251a3">dimensions</a> d=rowDim)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Enforce indexing to start at a given dimension.  <a href="#a7f573a7b5d73ba8abcadb337e43f73bc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#af99841f335c21d3061b17e4b99c2ef6d">setVoxelValue</a> (const <a class="el" href="classisis_1_1util_1_1__internal_1_1ValueReference.html">util::ValueReference</a> &amp;val, size_t nrOfColumns, size_t nrOfRows=0, size_t nrOfSlices=0, size_t nrOfTimesteps=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#a94fda5b511c9bfdff550d9691937aea1">spliceDownTo</a> (<a class="el" href="namespaceisis_1_1data.html#a157a8a81ce7fb08f84af9c27b7d251a3">dimensions</a> dim)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Automatically splice the given dimension and all dimensions above.  <a href="#a94fda5b511c9bfdff550d9691937aea1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#a10667fe639484021089fd983caaf58ea">transformCoords</a> (boost::numeric::ublas::matrix&lt; float &gt; transform_matrix, bool transformCenterIsImageCenter=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms the image coordinate system into an other system by multiplying the orientation matrix with a user defined transformation matrix.  <a href="#a10667fe639484021089fd983caaf58ea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#aa2d4ca5ab19f210830ba7a871cb24406">updateOrientationMatrices</a> ()</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#a31aecea5e2a012d677c59222ebe13198">voxel</a> (size_t first, size_t second=0, size_t third=0, size_t fourth=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns a reference to the voxel value at the given coordinates.  <a href="#a31aecea5e2a012d677c59222ebe13198"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#a907da37c72907fa34c67ed937a34c83a">voxel</a> (size_t first, size_t second=0, size_t third=0, size_t fourth=0) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const reference to the voxel value at the given coordinates.  <a href="#a907da37c72907fa34c67ed937a34c83a"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classisis_1_1data_1_1Chunk.html">Chunk</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#a087ed8c4884cea467e47c386c65d5be2">chunkAt</a> (size_t at)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Access a chunk via index (and the lookup table) The <a class="el" href="classisis_1_1data_1_1Chunk.html" title="Main class for four-dimensional random-access data blocks.">Chunk</a> will only have metadata which are unique to it - so it might be invalid (run join on it using the image as parameter to insert all non-unique-metadata).  <a href="#a087ed8c4884cea467e47c386c65d5be2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#aece4ae886cea93d0e05087c9b3e2c85b">getChunkStride</a> (size_t base_stride=1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for a dimensional break in all stored chunks.  <a href="#aece4ae886cea93d0e05087c9b3e2c85b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#afe4f8006b3f04f60f68b5027ed8bbebc">Image</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an empty <a class="el" href="classisis_1_1data_1_1Image.html" title="Main class for generic 4D-images.">Image</a> object.  <a href="#afe4f8006b3f04f60f68b5027ed8bbebc"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#a07dfbac4eb23def6dd10ab2182d98eeb">clean</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; boost::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classisis_1_1data_1_1Chunk.html">Chunk</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#a9c80a4fa8768d5df1c8bf67129e2cae9">lookup</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classisis_1_1util_1_1vector4.html">util::fvector4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#a8fa8b27baf0db3b33521c01015000ebe">m_ColumnVec</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classisis_1_1util_1_1vector4.html">util::fvector4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#ae4c1086fcefdcea6d4c026415732a0bd">m_ColumnVecInv</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classisis_1_1util_1_1vector4.html">util::fvector4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#a2e1c0d32c0ffbacafb9bc54ca97fc469">m_Offset</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classisis_1_1util_1_1vector4.html">util::fvector4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#af304cf98a684a4ea2e9e1e1283f0025a">m_RowVec</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classisis_1_1util_1_1vector4.html">util::fvector4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#a374ae697c25b616628a0baded99903aa">m_RowVecInv</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classisis_1_1util_1_1vector4.html">util::fvector4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#ac55db4f806fb53523b0ed5c599c360ab">m_SliceVec</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classisis_1_1util_1_1vector4.html">util::fvector4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#ad164cb7f1033182b3e33dff905f56787">m_SliceVecInv</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classisis_1_1data_1_1__internal_1_1SortedChunkList.html">_internal::SortedChunkList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#af3656b415fa1872a8da29f82cb98ed6e">set</a></td></tr>
<tr><td colspan="2"><h2><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#a8f9c4e537ac029bc07d10ded62d0be32">neededProperties</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Main class for generic 4D-images. </p>

<p>Definition at line <a class="el" href="image_8hpp_source.html#l00186">186</a> of file <a class="el" href="image_8hpp_source.html">image.hpp</a>.</p>
</div><hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a21407a9c75b9ea3f50e52664d4f7a19e"></a><!-- doxytag: member="isis::data::Image::const_iterator" ref="a21407a9c75b9ea3f50e52664d4f7a19e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classisis_1_1data_1_1__internal_1_1ImageIteratorTemplate.html">_internal::ImageIteratorTemplate</a>&lt;const <a class="el" href="classisis_1_1data_1_1Chunk.html">Chunk</a>&gt; <a class="el" href="classisis_1_1data_1_1__internal_1_1ImageIteratorTemplate.html">isis::data::Image::const_iterator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="classisis_1_1data_1_1TypedImage.html#ad48ac2690214ee59fa0051513153c4f7">isis::data::TypedImage&lt; T &gt;</a>.</p>

<p>Definition at line <a class="el" href="image_8hpp_source.html#l00205">205</a> of file <a class="el" href="image_8hpp_source.html">image.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aaaebaaac8caa5b11a0d81c6a286c55e4"></a><!-- doxytag: member="isis::data::Image::const_reference" ref="aaaebaaac8caa5b11a0d81c6a286c55e4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef const_iterator::reference <a class="el" href="classisis_1_1data_1_1Image.html#aaaebaaac8caa5b11a0d81c6a286c55e4">isis::data::Image::const_reference</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="classisis_1_1data_1_1TypedImage.html#aacdc5f9d936c90b39eddc2c4db8d2827">isis::data::TypedImage&lt; T &gt;</a>.</p>

<p>Definition at line <a class="el" href="image_8hpp_source.html#l00207">207</a> of file <a class="el" href="image_8hpp_source.html">image.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a76dc53ed34c1c73d797f50ef182d7f4a"></a><!-- doxytag: member="isis::data::Image::iterator" ref="a76dc53ed34c1c73d797f50ef182d7f4a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classisis_1_1data_1_1__internal_1_1ImageIteratorTemplate.html">_internal::ImageIteratorTemplate</a>&lt;<a class="el" href="classisis_1_1data_1_1Chunk.html">Chunk</a>&gt; <a class="el" href="classisis_1_1data_1_1__internal_1_1ImageIteratorTemplate.html">isis::data::Image::iterator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="classisis_1_1data_1_1TypedImage.html#a609c3dd20180970150852ffbde3998fb">isis::data::TypedImage&lt; T &gt;</a>.</p>

<p>Definition at line <a class="el" href="image_8hpp_source.html#l00204">204</a> of file <a class="el" href="image_8hpp_source.html">image.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4cb25846b5e8e6539e710416b81d4e61"></a><!-- doxytag: member="isis::data::Image::reference" ref="a4cb25846b5e8e6539e710416b81d4e61" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef iterator::reference <a class="el" href="classisis_1_1data_1_1Image.html#a4cb25846b5e8e6539e710416b81d4e61">isis::data::Image::reference</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="classisis_1_1data_1_1TypedImage.html#a8d8fe2a535b6429d38fcab5576132d6a">isis::data::TypedImage&lt; T &gt;</a>.</p>

<p>Definition at line <a class="el" href="image_8hpp_source.html#l00206">206</a> of file <a class="el" href="image_8hpp_source.html">image.hpp</a>.</p>

</div>
</div>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="ac83f7eecffd172b0c0759cb5ee7dd633"></a><!-- doxytag: member="isis::data::Image::orientation" ref="ac83f7eecffd172b0c0759cb5ee7dd633" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classisis_1_1data_1_1Image.html#ac83f7eecffd172b0c0759cb5ee7dd633">isis::data::Image::orientation</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ac83f7eecffd172b0c0759cb5ee7dd633aee38808f2b23291db3fbb0aebe7ba405"></a><!-- doxytag: member="axial" ref="ac83f7eecffd172b0c0759cb5ee7dd633aee38808f2b23291db3fbb0aebe7ba405" args="" -->axial</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ac83f7eecffd172b0c0759cb5ee7dd633a64a137c1013ea7f831d25c8701c0693d"></a><!-- doxytag: member="reversed_axial" ref="ac83f7eecffd172b0c0759cb5ee7dd633a64a137c1013ea7f831d25c8701c0693d" args="" -->reversed_axial</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ac83f7eecffd172b0c0759cb5ee7dd633a0d4cbf4f6526d1d6895c71e6bea6542c"></a><!-- doxytag: member="sagittal" ref="ac83f7eecffd172b0c0759cb5ee7dd633a0d4cbf4f6526d1d6895c71e6bea6542c" args="" -->sagittal</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ac83f7eecffd172b0c0759cb5ee7dd633a3adbf32c9b5579e6e97586301f48e047"></a><!-- doxytag: member="reversed_sagittal" ref="ac83f7eecffd172b0c0759cb5ee7dd633a3adbf32c9b5579e6e97586301f48e047" args="" -->reversed_sagittal</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ac83f7eecffd172b0c0759cb5ee7dd633ad77b748bff3861529f19469104a94e6c"></a><!-- doxytag: member="coronal" ref="ac83f7eecffd172b0c0759cb5ee7dd633ad77b748bff3861529f19469104a94e6c" args="" -->coronal</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ac83f7eecffd172b0c0759cb5ee7dd633af6335ced67866cc519e297f42ee64caa"></a><!-- doxytag: member="reversed_coronal" ref="ac83f7eecffd172b0c0759cb5ee7dd633af6335ced67866cc519e297f42ee64caa" args="" -->reversed_coronal</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="image_8hpp_source.html#l00202">202</a> of file <a class="el" href="image_8hpp_source.html">image.hpp</a>.</p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="afe4f8006b3f04f60f68b5027ed8bbebc"></a><!-- doxytag: member="isis::data::Image::Image" ref="afe4f8006b3f04f60f68b5027ed8bbebc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">isis::data::Image::Image </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an empty <a class="el" href="classisis_1_1data_1_1Image.html" title="Main class for generic 4D-images.">Image</a> object. </p>

<p>Definition at line <a class="el" href="image_8cpp_source.html#l00036">36</a> of file <a class="el" href="image_8cpp_source.html">image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0ad493c5fbfed450e4f933097ee81951"></a><!-- doxytag: member="isis::data::Image::Image" ref="a0ad493c5fbfed450e4f933097ee81951" args="(const Image &amp;ref)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">isis::data::Image::Image </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classisis_1_1data_1_1Image.html">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>ref</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy constructor. </p>
<p>Copies all elements, only the voxel-data (in the chunks) are referenced. </p>

<p>Definition at line <a class="el" href="image_8cpp_source.html#l00060">60</a> of file <a class="el" href="image_8cpp_source.html">image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac8448f89faef184720e5ae079873c7ee"></a><!-- doxytag: member="isis::data::Image::Image" ref="ac8448f89faef184720e5ae079873c7ee" args="(std::list&lt; T &gt; &amp;chunks, dimensions min_dim=rowDim)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">isis::data::Image::Image </td>
          <td>(</td>
          <td class="paramtype">std::list&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>chunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceisis_1_1data.html#a157a8a81ce7fb08f84af9c27b7d251a3">dimensions</a>&#160;</td>
          <td class="paramname"><em>min_dim</em> = <code>rowDim</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create image from a list of Chunks or objects with the base <a class="el" href="classisis_1_1data_1_1Chunk.html" title="Main class for four-dimensional random-access data blocks.">Chunk</a>. </p>
<p>Removes used chunks from the given list. So afterwards the list consists of the rejected chunks. </p>

<p>Definition at line <a class="el" href="image_8hpp_source.html#l00299">299</a> of file <a class="el" href="image_8hpp_source.html">image.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af9539532e4fb1458c559f13a6b770174"></a><!-- doxytag: member="isis::data::Image::Image" ref="af9539532e4fb1458c559f13a6b770174" args="(std::vector&lt; T &gt; &amp;chunks, dimensions min_dim=rowDim)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">isis::data::Image::Image </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>chunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceisis_1_1data.html#a157a8a81ce7fb08f84af9c27b7d251a3">dimensions</a>&#160;</td>
          <td class="paramname"><em>min_dim</em> = <code>rowDim</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create image from a vector of Chunks or objects with the base <a class="el" href="classisis_1_1data_1_1Chunk.html" title="Main class for four-dimensional random-access data blocks.">Chunk</a>. </p>
<p>Removes used chunks from the given list. So afterwards the list consists of the rejected chunks. </p>

<p>Definition at line <a class="el" href="image_8hpp_source.html#l00312">312</a> of file <a class="el" href="image_8hpp_source.html">image.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a62c50f70497b9094bb2c541b797971f6"></a><!-- doxytag: member="isis::data::Image::Image" ref="a62c50f70497b9094bb2c541b797971f6" args="(const Chunk &amp;chunk, dimensions min_dim=rowDim)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">isis::data::Image::Image </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classisis_1_1data_1_1Chunk.html">Chunk</a> &amp;&#160;</td>
          <td class="paramname"><em>chunk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceisis_1_1data.html#a157a8a81ce7fb08f84af9c27b7d251a3">dimensions</a>&#160;</td>
          <td class="paramname"><em>min_dim</em> = <code>rowDim</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create image from a single chunk. </p>

<p>Definition at line <a class="el" href="image_8cpp_source.html#l00043">43</a> of file <a class="el" href="image_8cpp_source.html">image.cpp</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="abf0729737cf6906a0aa6c1e830c0d728"></a><!-- doxytag: member="isis::data::Image::begin" ref="abf0729737cf6906a0aa6c1e830c0d728" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisis_1_1data_1_1__internal_1_1ImageIteratorTemplate.html">Image::iterator</a> isis::data::Image::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="classisis_1_1data_1_1TypedImage.html#ae0eb2a2c2e9862d8730239d7afb3aec2">isis::data::TypedImage&lt; T &gt;</a>.</p>

<p>Definition at line <a class="el" href="image_8cpp_source.html#l00963">963</a> of file <a class="el" href="image_8cpp_source.html">image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa7798a003e27e1c12de7f30f06aede92"></a><!-- doxytag: member="isis::data::Image::begin" ref="aa7798a003e27e1c12de7f30f06aede92" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisis_1_1data_1_1__internal_1_1ImageIteratorTemplate.html">Image::const_iterator</a> isis::data::Image::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="classisis_1_1data_1_1TypedImage.html#ae03769fb22a4b5b013cf1a0d8c2a409c">isis::data::TypedImage&lt; T &gt;</a>.</p>

<p>Definition at line <a class="el" href="image_8cpp_source.html#l00978">978</a> of file <a class="el" href="image_8cpp_source.html">image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="acd213fa6d0856d45e6413801f9bdec66"></a><!-- doxytag: member="isis::data::Image::checkMakeClean" ref="acd213fa6d0856d45e6413801f9bdec66" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isis::data::Image::checkMakeClean </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="image_8cpp_source.html#l00088">88</a> of file <a class="el" href="image_8cpp_source.html">image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a087ed8c4884cea467e47c386c65d5be2"></a><!-- doxytag: member="isis::data::Image::chunkAt" ref="a087ed8c4884cea467e47c386c65d5be2" args="(size_t at)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisis_1_1data_1_1Chunk.html">Chunk</a> &amp; isis::data::Image::chunkAt </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>at</em></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Access a chunk via index (and the lookup table) The <a class="el" href="classisis_1_1data_1_1Chunk.html" title="Main class for four-dimensional random-access data blocks.">Chunk</a> will only have metadata which are unique to it - so it might be invalid (run join on it using the image as parameter to insert all non-unique-metadata). </p>

<p>Definition at line <a class="el" href="image_8cpp_source.html#l00543">543</a> of file <a class="el" href="image_8cpp_source.html">image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0750957ebf3422a0fbb3d029cc9b292a"></a><!-- doxytag: member="isis::data::Image::compare" ref="a0750957ebf3422a0fbb3d029cc9b292a" args="(const Image &amp;comp) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t isis::data::Image::compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classisis_1_1data_1_1Image.html">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>comp</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compares the voxel-values of this image to the given. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the amount of the different voxels </dd></dl>

<p>Definition at line <a class="el" href="image_8cpp_source.html#l00712">712</a> of file <a class="el" href="image_8cpp_source.html">image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a582f927569aba48d8626c9a7d941ded1"></a><!-- doxytag: member="isis::data::Image::convertToType" ref="a582f927569aba48d8626c9a7d941ded1" args="(unsigned short ID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isis::data::Image::convertToType </td>
          <td>(</td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>ID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Ensure, the image has the type with the requested ID. </p>
<p>If the typeID of any chunk is not equal to the requested ID, the data of the chunk is replaced by an converted version. The conversion is done using the value range of the image. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>false if there was an error </dd></dl>

<p>Definition at line <a class="el" href="image_8cpp_source.html#l00830">830</a> of file <a class="el" href="image_8cpp_source.html">image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2fd76bb61355c14ef7035e740b462a5e"></a><!-- doxytag: member="isis::data::Image::copyChunksToVector" ref="a2fd76bb61355c14ef7035e740b462a5e" args="(bool copy_metadata=true) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classisis_1_1data_1_1Chunk.html">Chunk</a> &gt; isis::data::Image::copyChunksToVector </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>copy_metadata</em> = <code>true</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a sorted list of the chunks of the image. </p>
<p>Note: These chunks are cheap copies, so changing their voxels will change the voxels of the image. Make MemChunks of them to get deep copies. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">copy_metadata</td><td>set to false to prevent the metadata of the image to be copied into the results. This will improve performance, but the chunks may lack important properties. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="image_8cpp_source.html#l00560">560</a> of file <a class="el" href="image_8cpp_source.html">image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1849844422ad86be44556bbab0d55088"></a><!-- doxytag: member="isis::data::Image::copyToMem" ref="a1849844422ad86be44556bbab0d55088" args="(T *dst, size_t len, scaling_pair scaling=scaling_pair()) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void isis::data::Image::copyToMem </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceisis_1_1data.html#ac2873e5e7a9637d4ac68253dcf140ff4">scaling_pair</a>&#160;</td>
          <td class="paramname"><em>scaling</em> = <code><a class="el" href="namespaceisis_1_1data.html#ac2873e5e7a9637d4ac68253dcf140ff4">scaling_pair</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy all voxel data of the image into memory. </p>
<p>If neccessary a conversion into T is done using min/max of the image. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>c-pointer for the memory to copy into </td></tr>
    <tr><td class="paramname">len</td><td>the allocated size of that memory in elements </td></tr>
    <tr><td class="paramname">scaling</td><td>the scaling to be used when converting the data (will be determined automatically if not given) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="image_8hpp_source.html#l00652">652</a> of file <a class="el" href="image_8hpp_source.html">image.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad4c4bf9e84ee707c221cb5140cfb8f3f"></a><!-- doxytag: member="isis::data::Image::copyToMemChunk" ref="ad4c4bf9e84ee707c221cb5140cfb8f3f" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisis_1_1data_1_1MemChunk.html">MemChunk</a>&lt;T&gt; isis::data::Image::copyToMemChunk </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy all voxel data into a new <a class="el" href="classisis_1_1data_1_1MemChunk.html" title="Chunk class for memory-based buffers.">MemChunk</a>. </p>
<p>This creates a <a class="el" href="classisis_1_1data_1_1MemChunk.html" title="Chunk class for memory-based buffers.">MemChunk</a>&lt;T&gt; of the requested type and the same size as the <a class="el" href="classisis_1_1data_1_1Image.html" title="Main class for generic 4D-images.">Image</a> and then copies all voxeldata of the image into that <a class="el" href="classisis_1_1data_1_1Chunk.html" title="Main class for four-dimensional random-access data blocks.">Chunk</a>. If neccessary a conversion into T is done using min/max of the image. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a <a class="el" href="classisis_1_1data_1_1MemChunk.html" title="Chunk class for memory-based buffers.">MemChunk</a>&lt;T&gt; containing the voxeldata of the <a class="el" href="classisis_1_1data_1_1Image.html" title="Main class for generic 4D-images.">Image</a> (but not its Properties) </dd></dl>

<p>Definition at line <a class="el" href="image_8hpp_source.html#l00686">686</a> of file <a class="el" href="image_8hpp_source.html">image.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac00259c20d41ad6266b1ad3c92b3b499"></a><!-- doxytag: member="isis::data::Image::end" ref="ac00259c20d41ad6266b1ad3c92b3b499" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisis_1_1data_1_1__internal_1_1ImageIteratorTemplate.html">Image::const_iterator</a> isis::data::Image::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="classisis_1_1data_1_1TypedImage.html#a7d6e6d04889c61bb9899df125ec2939e">isis::data::TypedImage&lt; T &gt;</a>.</p>

<p>Definition at line <a class="el" href="image_8cpp_source.html#l00992">992</a> of file <a class="el" href="image_8cpp_source.html">image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ade432319d06fc1638e617457d585e48d"></a><!-- doxytag: member="isis::data::Image::end" ref="ade432319d06fc1638e617457d585e48d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisis_1_1data_1_1__internal_1_1ImageIteratorTemplate.html">Image::iterator</a> isis::data::Image::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="classisis_1_1data_1_1TypedImage.html#a510cd35b1115a31a26c5d7b231d67907">isis::data::TypedImage&lt; T &gt;</a>.</p>

<p>Definition at line <a class="el" href="image_8cpp_source.html#l00977">977</a> of file <a class="el" href="image_8cpp_source.html">image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aac647fb29128d16d528059d481c79874"></a><!-- doxytag: member="isis::data::Image::foreachChunk" ref="aac647fb29128d16d528059d481c79874" args="(ChunkOp &amp;op, bool copyMetaData=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t isis::data::Image::foreachChunk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classisis_1_1data_1_1ChunkOp.html">ChunkOp</a> &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>copyMetaData</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Run a functor with the base <a class="el" href="classisis_1_1data_1_1ChunkOp.html" title="Base class for operators used for foreachChunk.">ChunkOp</a> on every cunk in the image. </p>
<p>This does not check the types of the images. So if your functor needs a specific type, use <a class="el" href="classisis_1_1data_1_1TypedImage.html" title="An Image where all chunks are guaranteed to have a specific type.">TypedImage</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>a functor object which inherits ChunkOP </td></tr>
    <tr><td class="paramname">copyMetaData</td><td>if true the metadata of the image are copied into the chunks before calling the functor </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="image_8cpp_source.html#l00904">904</a> of file <a class="el" href="image_8cpp_source.html">image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a22b33e80caee653a22653f6aa04bd048"></a><!-- doxytag: member="isis::data::Image::foreachVoxel" ref="a22b33e80caee653a22653f6aa04bd048" args="(VoxelOp&lt; TYPE &gt; &amp;op)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t isis::data::Image::foreachVoxel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classisis_1_1data_1_1VoxelOp.html">VoxelOp</a>&lt; TYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Run a functor with the base <a class="el" href="classisis_1_1data_1_1VoxelOp.html" title="Base class for operators used for foreachVoxel.">VoxelOp</a> on every chunk in the image. </p>
<p>If any chunk does not have the requested type it will be converted. So the result is equivalent to <a class="el" href="classisis_1_1data_1_1TypedImage.html" title="An Image where all chunks are guaranteed to have a specific type.">TypedImage</a>&lt;TYPE&gt;. If these conversion failes no operation is done, and false is returned. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>a functor object which inherits <a class="el" href="classisis_1_1data_1_1ChunkOp.html" title="Base class for operators used for foreachChunk.">ChunkOp</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="image_8hpp_source.html#l00731">731</a> of file <a class="el" href="image_8hpp_source.html">image.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a873a72def2728e8cfc060ee8c6ac6bd3"></a><!-- doxytag: member="isis::data::Image::getBytesPerVoxel" ref="a873a72def2728e8cfc060ee8c6ac6bd3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t isis::data::Image::getBytesPerVoxel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>get the voxelsize (in bytes) for the major type in the image </p>

<p>Definition at line <a class="el" href="image_8cpp_source.html#l00658">658</a> of file <a class="el" href="image_8cpp_source.html">image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="afda7218833647cc6526950524775140d"></a><!-- doxytag: member="isis::data::Image::getChunk" ref="afda7218833647cc6526950524775140d" args="(size_t first, size_t second=0, size_t third=0, size_t fourth=0, bool copy_metadata=true) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classisis_1_1data_1_1Chunk.html">Chunk</a> isis::data::Image::getChunk </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>second</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>third</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>fourth</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>copy_metadata</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the chunk that contains the voxel at the given coordinates. </p>
<p>If the image is not clean, behaviour is undefined. (See Image::commonGet).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first coordinate in voxel space. Usually the x value / the read-encoded position. </td></tr>
    <tr><td class="paramname">second</td><td>The second coordinate in voxel space. Usually the y value / the column-encoded position. </td></tr>
    <tr><td class="paramname">third</td><td>The third coordinate in voxel space. Ususally the z value / the slice-encoded position. </td></tr>
    <tr><td class="paramname">fourth</td><td>The fourth coordinate in voxel space. Usually the time value. </td></tr>
    <tr><td class="paramname">copy_metadata</td><td>if true the metadata of the image are merged into the returned chunk </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a copy of the chunk that contains the voxel at the given coordinates. (Reminder: Chunk-copies are cheap, so the image data are NOT copied but referenced) </dd></dl>

<p>Definition at line <a class="el" href="image_8cpp_source.html#l00554">554</a> of file <a class="el" href="image_8cpp_source.html">image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a882f5172bca7221c71954efdf6d0f9de"></a><!-- doxytag: member="isis::data::Image::getChunk" ref="a882f5172bca7221c71954efdf6d0f9de" args="(size_t first, size_t second=0, size_t third=0, size_t fourth=0, bool copy_metadata=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisis_1_1data_1_1Chunk.html">Chunk</a> isis::data::Image::getChunk </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>second</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>third</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>fourth</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>copy_metadata</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the chunk that contains the voxel at the given coordinates. </p>
<p>If the image is not clean <a class="el" href="classisis_1_1data_1_1Image.html#a801a02eb15ae94b384aaa97061e2ad1c" title="(Re)computes the image layout and metadata.">Image::reIndex()</a> will be run.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first coordinate in voxel space. Usually the x value. </td></tr>
    <tr><td class="paramname">second</td><td>The second coordinate in voxel space. Usually the y value. </td></tr>
    <tr><td class="paramname">third</td><td>The third coordinate in voxel space. Ususally the z value. </td></tr>
    <tr><td class="paramname">fourth</td><td>The fourth coordinate in voxel space. Usually the time value. </td></tr>
    <tr><td class="paramname">copy_metadata</td><td>if true the metadata of the image are merged into the returned chunk </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a copy of the chunk that contains the voxel at the given coordinates. (Reminder: Chunk-copies are cheap, so the image data are NOT copied but referenced) </dd></dl>

<p>Definition at line <a class="el" href="image_8cpp_source.html#l00548">548</a> of file <a class="el" href="image_8cpp_source.html">image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a815e76cb9cc68006b2bbdad2cd9ded7c"></a><!-- doxytag: member="isis::data::Image::getChunkAs" ref="a815e76cb9cc68006b2bbdad2cd9ded7c" args="(size_t first, size_t second=0, size_t third=0, size_t fourth=0, bool copy_metadata=true) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisis_1_1data_1_1Chunk.html">Chunk</a> isis::data::Image::getChunkAs </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>second</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>third</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>fourth</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>copy_metadata</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the chunk that contains the voxel at the given coordinates in the given type. </p>
<p>If the accordant chunk has type T a cheap copy is returned. Otherwise a MemChunk-copy of the requested type is created from it. In this case the minimum and maximum values of the image are computed and used for the <a class="el" href="classisis_1_1data_1_1MemChunk.html" title="Chunk class for memory-based buffers.">MemChunk</a> constructor.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first coordinate in voxel space. Usually the x value. </td></tr>
    <tr><td class="paramname">second</td><td>The second coordinate in voxel space. Usually the y value. </td></tr>
    <tr><td class="paramname">third</td><td>The third coordinate in voxel space. Ususally the z value. </td></tr>
    <tr><td class="paramname">fourth</td><td>The fourth coordinate in voxel space. Usually the time value. </td></tr>
    <tr><td class="paramname">copy_metadata</td><td>if true the metadata of the image are merged into the returned chunk </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a (maybe converted) chunk containing the voxel value at the given coordinates. </dd></dl>

<p>Definition at line <a class="el" href="image_8hpp_source.html#l00483">483</a> of file <a class="el" href="image_8hpp_source.html">image.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a72a398bd1f12cb27bc33bf0e1c693995"></a><!-- doxytag: member="isis::data::Image::getChunkAs" ref="a72a398bd1f12cb27bc33bf0e1c693995" args="(const scaling_pair &amp;scaling, size_t first, size_t second=0, size_t third=0, size_t fourth=0, bool copy_metadata=true) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisis_1_1data_1_1Chunk.html">Chunk</a> isis::data::Image::getChunkAs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceisis_1_1data.html#ac2873e5e7a9637d4ac68253dcf140ff4">scaling_pair</a> &amp;&#160;</td>
          <td class="paramname"><em>scaling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>second</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>third</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>fourth</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>copy_metadata</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the chunk that contains the voxel at the given coordinates in the given type (fast version). </p>
<p>If the accordant chunk has type T a cheap copy is returned. Otherwise a MemChunk-copy of the requested type is created from it. In this case the minimum and maximum values of the image are computed and used for the <a class="el" href="classisis_1_1data_1_1MemChunk.html" title="Chunk class for memory-based buffers.">MemChunk</a> constructor.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first coordinate in voxel space. Usually the x value. </td></tr>
    <tr><td class="paramname">second</td><td>The second coordinate in voxel space. Usually the y value. </td></tr>
    <tr><td class="paramname">third</td><td>The third coordinate in voxel space. Ususally the z value. </td></tr>
    <tr><td class="paramname">fourth</td><td>The fourth coordinate in voxel space. Usually the time value. </td></tr>
    <tr><td class="paramname">copy_metadata</td><td>if true the metadata of the image are merged into the returned chunk </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a (maybe converted) chunk containing the voxel value at the given coordinates. </dd></dl>
 This version does not compute the scaling, and thus is much faster. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">scaling</td><td>the scaling (scale and offset) to be used if a conversion to the requested type is neccessary. </td></tr>
    <tr><td class="paramname">first</td><td>The first coordinate in voxel space. Usually the x value. </td></tr>
    <tr><td class="paramname">second</td><td>The second coordinate in voxel space. Usually the y value. </td></tr>
    <tr><td class="paramname">third</td><td>The third coordinate in voxel space. Ususally the z value. </td></tr>
    <tr><td class="paramname">fourth</td><td>The fourth coordinate in voxel space. Usually the time value. </td></tr>
    <tr><td class="paramname">copy_metadata</td><td>if true the metadata of the image are merged into the returned chunk </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a (maybe converted) chunk containing the voxel value at the given coordinates. </dd></dl>

<p>Definition at line <a class="el" href="image_8hpp_source.html#l00498">498</a> of file <a class="el" href="image_8hpp_source.html">image.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a27cfa5f9ced2077e578ad4bcc064e028"></a><!-- doxytag: member="isis::data::Image::getChunkAt" ref="a27cfa5f9ced2077e578ad4bcc064e028" args="(size_t at, bool copy_metadata=true) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisis_1_1data_1_1Chunk.html">Chunk</a> isis::data::Image::getChunkAt </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>at</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>copy_metadata</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a chunk via index (and the lookup table). </p>
<p>The returned chunk will be a cheap copy of the original chunk. If copy_metadata is true the metadata of the image is copied into the chunk. </p>

<p>Definition at line <a class="el" href="image_8cpp_source.html#l00535">535</a> of file <a class="el" href="image_8cpp_source.html">image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a97524a597e61074c8b4b2e6e0ebdf8e6"></a><!-- doxytag: member="isis::data::Image::getChunksProperties" ref="a97524a597e61074c8b4b2e6e0ebdf8e6" args="(const util::PropertyMap::KeyType &amp;key, bool unique=false) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt; <a class="el" href="classisis_1_1util_1_1PropertyValue.html">util::PropertyValue</a> &gt; isis::data::Image::getChunksProperties </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classisis_1_1util_1_1PropertyMap.html#a22562fc95dac243746790a5c6a2aad85">util::PropertyMap::KeyType</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>unique</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a list of the properties of the chunks for the given key. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the name of the property to search for </td></tr>
    <tr><td class="paramname">unique</td><td>when true empty or consecutive duplicates wont be added </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="image_8cpp_source.html#l00635">635</a> of file <a class="el" href="image_8cpp_source.html">image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aece4ae886cea93d0e05087c9b3e2c85b"></a><!-- doxytag: member="isis::data::Image::getChunkStride" ref="aece4ae886cea93d0e05087c9b3e2c85b" args="(size_t base_stride=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t isis::data::Image::getChunkStride </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>base_stride</em> = <code>1</code></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Search for a dimensional break in all stored chunks. </p>
<p>This function searches for two chunks whose (geometrical) distance is more than twice the distance between the first and the second chunk. It wll assume a dimensional break at this position.</p>
<p>Normally chunks are beneath each other (like characters in a text) so their distance is more or less constant. But if there is a dimensional break (analogous to the linebreak in a text) the distance between this particular chunks/characters is bigger than twice the normal distance</p>
<p>For example for an image of 2D-chunks (slices) getChunkStride(1) will get the number of slices (size of third dim) and getChunkStride(slices) will get the number of timesteps </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">base_stride</td><td>the base_stride for the iteration between chunks (1 for the first dimension, one "line" for the second and soon...) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the length of this chunk-"line" / the stride </dd></dl>

<p>Definition at line <a class="el" href="image_8cpp_source.html#l00577">577</a> of file <a class="el" href="image_8cpp_source.html">image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a36e107da6a3d4744468b3c837534291b"></a><!-- doxytag: member="isis::data::Image::getFoV" ref="a36e107da6a3d4744468b3c837534291b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisis_1_1util_1_1vector4.html">util::fvector4</a> isis::data::Image::getFoV </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="image_8cpp_source.html#l00946">946</a> of file <a class="el" href="image_8cpp_source.html">image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aacbf0d66df0ec2ddfe0e8d73d2eddc39"></a><!-- doxytag: member="isis::data::Image::getIndexFromPhysicalCoords" ref="aacbf0d66df0ec2ddfe0e8d73d2eddc39" args="(const util::fvector4 &amp;physicalCoords, bool restrictedToImageBox=false) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisis_1_1util_1_1vector4.html">util::ivector4</a> isis::data::Image::getIndexFromPhysicalCoords </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classisis_1_1util_1_1vector4.html">util::fvector4</a> &amp;&#160;</td>
          <td class="paramname"><em>physicalCoords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>restrictedToImageBox</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the voxel index of the given physical coordinates (coordinates in scanner space) This function does not perform any test if the physical coordinates are inside the image. </p>
<p>See getPhysicalCoordsFromIndex for vice versa purpose. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">physicalCoords</td><td>the physical coords from which you want to get the voxel index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>voxel index associated with the given physicalCoords </dd></dl>

<p>Definition at line <a class="el" href="image_8cpp_source.html#l00199">199</a> of file <a class="el" href="image_8cpp_source.html">image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5d4c287dbd53f05174f3070029e19ce9"></a><!-- doxytag: member="isis::data::Image::getMainOrientation" ref="a5d4c287dbd53f05174f3070029e19ce9" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisis_1_1data_1_1Image.html#ac83f7eecffd172b0c0759cb5ee7dd633">Image::orientation</a> isis::data::Image::getMainOrientation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="image_8cpp_source.html#l00746">746</a> of file <a class="el" href="image_8cpp_source.html">image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a601eaac6eedf7eaf6fdb6c31b1e8765d"></a><!-- doxytag: member="isis::data::Image::getMajorTypeID" ref="a601eaac6eedf7eaf6fdb6c31b1e8765d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short isis::data::Image::getMajorTypeID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the type of the chunk with "biggest" type. </p>
<p>Determines the minimum and maximum of the image, (and with that the types of these limits). If they are not the same, the type which can store the other type is selected. E.g. if min is "-5(int8_t)" and max is "1000(int16_t)" "int16_t" is selected. Warning1: this will fail if min is "-5(int8_t)" and max is "70000(uint16_t)" Warning2: the cost of this is O(n) while <a class="el" href="classisis_1_1data_1_1Chunk.html#aaa66a58ddd4cf865cbb92850a2a1d40c">Chunk::getTypeID</a> is O(1) - so do not use it in loops Warning3: the result is not exact - so never use it to determine the type for <a class="el" href="classisis_1_1data_1_1Image.html#a31aecea5e2a012d677c59222ebe13198" title="This method returns a reference to the voxel value at the given coordinates.">Image::voxel</a> (Use <a class="el" href="classisis_1_1data_1_1TypedImage.html" title="An Image where all chunks are guaranteed to have a specific type.">TypedImage</a> to get an image with an guaranteed type) </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a number which is equal to the <a class="el" href="classisis_1_1data_1_1ValuePtr.html#afaf56a4a73ada017a6eefbdb03cb82a2">ValuePtr::staticID</a> of the selected type. </dd></dl>

<p>Definition at line <a class="el" href="image_8cpp_source.html#l00793">793</a> of file <a class="el" href="image_8cpp_source.html">image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6d5302c9e0de9fe8c97fbafa4a9e2d1e"></a><!-- doxytag: member="isis::data::Image::getMajorTypeName" ref="a6d5302c9e0de9fe8c97fbafa4a9e2d1e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string isis::data::Image::getMajorTypeName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the typename correspondig to the result of typeID </dd></dl>

<p>Definition at line <a class="el" href="image_8cpp_source.html#l00825">825</a> of file <a class="el" href="image_8cpp_source.html">image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab437a008e59944a63c9fdc844c673ad6"></a><!-- doxytag: member="isis::data::Image::getMinMax" ref="ab437a008e59944a63c9fdc844c673ad6" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classisis_1_1util_1_1__internal_1_1ValueReference.html">util::ValueReference</a>, <a class="el" href="classisis_1_1util_1_1__internal_1_1ValueReference.html">util::ValueReference</a> &gt; isis::data::Image::getMinMax </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the maximum and the minimum voxel value of the image as a pair of ValueReference-objects. </p>

<p>Definition at line <a class="el" href="image_8cpp_source.html#l00672">672</a> of file <a class="el" href="image_8cpp_source.html">image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae4bef75405f6729ab6c81191dc23bfc0"></a><!-- doxytag: member="isis::data::Image::getMinMaxAs" ref="ae4bef75405f6729ab6c81191dc23bfc0" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;T, T&gt; isis::data::Image::getMinMaxAs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the maximum and the minimum voxel value of the image. </p>
<p>The results are converted to T. If they dont fit an error ist send. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pair of T storing the minimum and maximum values of the image. </dd></dl>

<p>Definition at line <a class="el" href="image_8hpp_source.html#l00542">542</a> of file <a class="el" href="image_8hpp_source.html">image.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a01c02d76de0a741e527ff1e43b39422b"></a><!-- doxytag: member="isis::data::Image::getNrOfColumns" ref="a01c02d76de0a741e527ff1e43b39422b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t isis::data::Image::getNrOfColumns </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of columns of the image </dd></dl>

<p>Definition at line <a class="el" href="image_8cpp_source.html#l00928">928</a> of file <a class="el" href="image_8cpp_source.html">image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ace627e4628e39615cbae3b6b43b9d915"></a><!-- doxytag: member="isis::data::Image::getNrOfRows" ref="ace627e4628e39615cbae3b6b43b9d915" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t isis::data::Image::getNrOfRows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of rows of the image </dd></dl>

<p>Definition at line <a class="el" href="image_8cpp_source.html#l00933">933</a> of file <a class="el" href="image_8cpp_source.html">image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a922ea56dd2eb60fbb6e0299138dcde70"></a><!-- doxytag: member="isis::data::Image::getNrOfSlices" ref="a922ea56dd2eb60fbb6e0299138dcde70" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t isis::data::Image::getNrOfSlices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of slices of the image </dd></dl>

<p>Definition at line <a class="el" href="image_8cpp_source.html#l00937">937</a> of file <a class="el" href="image_8cpp_source.html">image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a142c7b80e200d9822c28fc604bb031ee"></a><!-- doxytag: member="isis::data::Image::getNrOfTimesteps" ref="a142c7b80e200d9822c28fc604bb031ee" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t isis::data::Image::getNrOfTimesteps </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of timesteps of the image </dd></dl>

<p>Definition at line <a class="el" href="image_8cpp_source.html#l00941">941</a> of file <a class="el" href="image_8cpp_source.html">image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2e83ae32400db8cea79ece348a0acffe"></a><!-- doxytag: member="isis::data::Image::getPhysicalCoordsFromIndex" ref="a2e83ae32400db8cea79ece348a0acffe" args="(const util::ivector4 &amp;index) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisis_1_1util_1_1vector4.html">util::fvector4</a> isis::data::Image::getPhysicalCoordsFromIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classisis_1_1util_1_1vector4.html">util::ivector4</a> &amp;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the physical coordinates (in scanner space) of the given voxel index. </p>
<p>This function does not perform any test if the voxel index is inside the image. See getIndexFromPhysicalCoords for vice versa purpose. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the voxel index from which you want to get the physical coordinates </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>physical coordinates associated with the given voxel index </dd></dl>

<p>Definition at line <a class="el" href="image_8cpp_source.html#l00187">187</a> of file <a class="el" href="image_8cpp_source.html">image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a789138e66345f3e5a73c65dbf05b2940"></a><!-- doxytag: member="isis::data::Image::getScalingTo" ref="a789138e66345f3e5a73c65dbf05b2940" args="(unsigned short typeID, autoscaleOption scaleopt=autoscale) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceisis_1_1data.html#ac2873e5e7a9637d4ac68253dcf140ff4">scaling_pair</a> isis::data::Image::getScalingTo </td>
          <td>(</td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>typeID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceisis_1_1data.html#a69354ef53dcb79cbe577ae5fe8764e49">autoscaleOption</a>&#160;</td>
          <td class="paramname"><em>scaleopt</em> = <code>autoscale</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>for each chunk get the scaling (and offset) which would be used in an conversion to the given type </p>

</div>
</div>
<a class="anchor" id="ab07f75534c9edeab26dc46c68c99771a"></a><!-- doxytag: member="isis::data::Image::getVoxelValue" ref="ab07f75534c9edeab26dc46c68c99771a" args="(size_t nrOfColumns, size_t nrOfRows=0, size_t nrOfSlices=0, size_t nrOfTimesteps=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classisis_1_1util_1_1__internal_1_1ValueReference.html">util::ValueReference</a> isis::data::Image::getVoxelValue </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nrOfColumns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nrOfRows</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nrOfSlices</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nrOfTimesteps</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="image_8cpp_source.html#l00994">994</a> of file <a class="el" href="image_8cpp_source.html">image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a14a33c4d2ba857b38c2188fb8e8abfd9"></a><!-- doxytag: member="isis::data::Image::insertChunk" ref="a14a33c4d2ba857b38c2188fb8e8abfd9" args="(const Chunk &amp;chunk)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isis::data::Image::insertChunk </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classisis_1_1data_1_1Chunk.html">Chunk</a> &amp;&#160;</td>
          <td class="paramname"><em>chunk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert a <a class="el" href="classisis_1_1data_1_1Chunk.html" title="Main class for four-dimensional random-access data blocks.">Chunk</a> into the <a class="el" href="classisis_1_1data_1_1Image.html" title="Main class for generic 4D-images.">Image</a>. </p>
<p>The insertion is sorted and unique. So the <a class="el" href="classisis_1_1data_1_1Chunk.html" title="Main class for four-dimensional random-access data blocks.">Chunk</a> will be inserted behind a geometrically "lower" <a class="el" href="classisis_1_1data_1_1Chunk.html" title="Main class for four-dimensional random-access data blocks.">Chunk</a> if there is one. If there is allready a <a class="el" href="classisis_1_1data_1_1Chunk.html" title="Main class for four-dimensional random-access data blocks.">Chunk</a> at the proposed position this <a class="el" href="classisis_1_1data_1_1Chunk.html" title="Main class for four-dimensional random-access data blocks.">Chunk</a> wont be inserted.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">chunk</td><td>The <a class="el" href="classisis_1_1data_1_1Chunk.html" title="Main class for four-dimensional random-access data blocks.">Chunk</a> to be inserted </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the <a class="el" href="classisis_1_1data_1_1Chunk.html" title="Main class for four-dimensional random-access data blocks.">Chunk</a> was inserted, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="image_8cpp_source.html#l00135">135</a> of file <a class="el" href="image_8cpp_source.html">image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a507228763078c1c0ed6cc5b92c4cc65a"></a><!-- doxytag: member="isis::data::Image::insertChunksFromContainer" ref="a507228763078c1c0ed6cc5b92c4cc65a" args="(T &amp;chunks)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t isis::data::Image::insertChunksFromContainer </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>chunks</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert Chunks or objects with the base <a class="el" href="classisis_1_1data_1_1Chunk.html" title="Main class for four-dimensional random-access data blocks.">Chunk</a> from a sequence container into the <a class="el" href="classisis_1_1data_1_1Image.html" title="Main class for generic 4D-images.">Image</a>. </p>
<p>Removes used chunks from the given sequence container. So afterwards the container consists of the rejected chunks. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>amount of successfully inserted chunks </dd></dl>

<p>Definition at line <a class="el" href="image_8hpp_source.html#l00327">327</a> of file <a class="el" href="image_8hpp_source.html">image.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a102fa197eedd6a7cc8642254be953656"></a><!-- doxytag: member="isis::data::Image::isClean" ref="a102fa197eedd6a7cc8642254be953656" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isis::data::Image::isClean </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="image_8cpp_source.html#l00100">100</a> of file <a class="el" href="image_8cpp_source.html">image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9fb0c9f8351fddc6a2fea609d487aa2b"></a><!-- doxytag: member="isis::data::Image::isEmpty" ref="a9fb0c9f8351fddc6a2fea609d487aa2b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isis::data::Image::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>true if there is no chunk in the image </dd></dl>

<p>Reimplemented from <a class="el" href="classisis_1_1util_1_1PropertyMap.html#a4a6bae8173d0a0e910903a634be674af">isis::util::PropertyMap</a>.</p>

<p>Definition at line <a class="el" href="image_8cpp_source.html#l00521">521</a> of file <a class="el" href="image_8cpp_source.html">image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a153f570319fc42ea6f1123a5a5eb309c"></a><!-- doxytag: member="isis::data::Image::mapScannerAxisToImageDimension" ref="a153f570319fc42ea6f1123a5a5eb309c" args="(scannerAxis scannerAxes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceisis_1_1data.html#a157a8a81ce7fb08f84af9c27b7d251a3">dimensions</a> isis::data::Image::mapScannerAxisToImageDimension </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceisis_1_1data.html#addc0484ee8054d9e855bbd264c978b99">scannerAxis</a>&#160;</td>
          <td class="paramname"><em>scannerAxes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Maps the given scanner Axis to the dimension with the minimal angle. </p>
<p>This is done by latching the orientation of the image by setting the biggest absolute value of each orientation vector to 1 and the others to 0. Example: (-0.8) (1) ( 0.2) -&gt; (0) (this is done for the rowVec, columnVec and sliceVec) (-0.1) (0)</p>
<p>This latched orientation is used to map from the scanner axes to the dimension. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">scannerAxes</td><td>the axes of the scanner you want to map to dimension of the image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the mapped image dimension </dd></dl>

<p>Definition at line <a class="el" href="image_8cpp_source.html#l00278">278</a> of file <a class="el" href="image_8cpp_source.html">image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aae95616fad335432d8ce3b5e5daf004a"></a><!-- doxytag: member="isis::data::Image::operator=" ref="aae95616fad335432d8ce3b5e5daf004a" args="(const Image &amp;ref)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisis_1_1data_1_1Image.html">Image</a> &amp; isis::data::Image::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classisis_1_1data_1_1Image.html">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>ref</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy operator. </p>
<p>Copies all elements, only the voxel-data (in the chunks) are referenced. </p>

<p>Reimplemented in <a class="el" href="classisis_1_1data_1_1TypedImage.html#a16654e67097e9e70a1bcc16b84bdd640">isis::data::TypedImage&lt; T &gt;</a>, and <a class="el" href="classisis_1_1data_1_1MemImage.html#a734d63e8c8c9d1eec740522451662f7f">isis::data::MemImage&lt; T &gt;</a>.</p>

<p>Definition at line <a class="el" href="image_8cpp_source.html#l00066">66</a> of file <a class="el" href="image_8cpp_source.html">image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a801a02eb15ae94b384aaa97061e2ad1c"></a><!-- doxytag: member="isis::data::Image::reIndex" ref="a801a02eb15ae94b384aaa97061e2ad1c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isis::data::Image::reIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>(Re)computes the image layout and metadata. </p>
<p>The image will be "clean" on success. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the image was successfully reindexed and is valid, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="image_8cpp_source.html#l00297">297</a> of file <a class="el" href="image_8cpp_source.html">image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7f573a7b5d73ba8abcadb337e43f73bc"></a><!-- doxytag: member="isis::data::Image::setIndexingDim" ref="a7f573a7b5d73ba8abcadb337e43f73bc" args="(dimensions d=rowDim)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void isis::data::Image::setIndexingDim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceisis_1_1data.html#a157a8a81ce7fb08f84af9c27b7d251a3">dimensions</a>&#160;</td>
          <td class="paramname"><em>d</em> = <code>rowDim</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enforce indexing to start at a given dimension. </p>
<p>Normally indexing starts at the dimensionality of the inserted chunks. So, an <a class="el" href="classisis_1_1data_1_1Image.html" title="Main class for generic 4D-images.">Image</a> of 2D-Chunks (slices) will start indexing at the 3rd dimension. If the dimension given here is bigger than the dimensionality of the chunks reindexing will override that and start indexing at the given dimension. E.g. setIndexingDim(timeDim) will enforce indexing of a <a class="el" href="classisis_1_1data_1_1Image.html" title="Main class for generic 4D-images.">Image</a> of 10 30x30-slices at the time dimension resulting in an 30x30x1x10 image instead of an 30x30x10x1 image. If the indexing dimension is set after the <a class="el" href="classisis_1_1data_1_1Image.html" title="Main class for generic 4D-images.">Image</a> was indexed it will be indexed again. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>the minimal indexing dimension to be used </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="image_8cpp_source.html#l00177">177</a> of file <a class="el" href="image_8cpp_source.html">image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="af99841f335c21d3061b17e4b99c2ef6d"></a><!-- doxytag: member="isis::data::Image::setVoxelValue" ref="af99841f335c21d3061b17e4b99c2ef6d" args="(const util::ValueReference &amp;val, size_t nrOfColumns, size_t nrOfRows=0, size_t nrOfSlices=0, size_t nrOfTimesteps=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void isis::data::Image::setVoxelValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classisis_1_1util_1_1__internal_1_1ValueReference.html">util::ValueReference</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nrOfColumns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nrOfRows</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nrOfSlices</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nrOfTimesteps</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="image_8cpp_source.html#l01001">1001</a> of file <a class="el" href="image_8cpp_source.html">image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a94fda5b511c9bfdff550d9691937aea1"></a><!-- doxytag: member="isis::data::Image::spliceDownTo" ref="a94fda5b511c9bfdff550d9691937aea1" args="(dimensions dim)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t isis::data::Image::spliceDownTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceisis_1_1data.html#a157a8a81ce7fb08f84af9c27b7d251a3">dimensions</a>&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Automatically splice the given dimension and all dimensions above. </p>
<p>e.g. spliceDownTo(sliceDim) will result in an image made of slices (aka 2d-chunks). </p>

<p>Definition at line <a class="el" href="image_8cpp_source.html#l00844">844</a> of file <a class="el" href="image_8cpp_source.html">image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a10667fe639484021089fd983caaf58ea"></a><!-- doxytag: member="isis::data::Image::transformCoords" ref="a10667fe639484021089fd983caaf58ea" args="(boost::numeric::ublas::matrix&lt; float &gt; transform_matrix, bool transformCenterIsImageCenter=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isis::data::Image::transformCoords </td>
          <td>(</td>
          <td class="paramtype">boost::numeric::ublas::matrix&lt; float &gt;&#160;</td>
          <td class="paramname"><em>transform_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transformCenterIsImageCenter</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transforms the image coordinate system into an other system by multiplying the orientation matrix with a user defined transformation matrix. </p>
<p>Additionally, the index origin will be transformed into the new coordinate system. This function only changes the orientation information (rowVec, columnVec, sliceVec, indexOrigin) of the image but will not change the image itself.</p>
<p><b>IMPORTANT!</b>: If you call this function with a matrix other than the identidy matrix, it's not guaranteed that the image is still in ISIS space according to the DICOM conventions. Eventuelly some ISIS algorithms that depend on correct image orientations won't work as expected. Use this method with caution! </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">transform_matrix</td><td>the transformation matrix can be any type of rigid and affine transformation </td></tr>
    <tr><td class="paramname">transformCenterIsImageCenter</td><td>if this parameter is true, the center of the image will be translated to the isocenter of the scanner prior applying the transform_matrix. Eventually, it will be translated to its initial position. For example this is the way SPM flips its images when converting from DICOM to nifti. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>returns if the transformation was successfuly </dd></dl>

<p>Definition at line <a class="el" href="image_8hpp_source.html#l00577">577</a> of file <a class="el" href="image_8hpp_source.html">image.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa2d4ca5ab19f210830ba7a871cb24406"></a><!-- doxytag: member="isis::data::Image::updateOrientationMatrices" ref="aa2d4ca5ab19f210830ba7a871cb24406" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isis::data::Image::updateOrientationMatrices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="image_8cpp_source.html#l00223">223</a> of file <a class="el" href="image_8cpp_source.html">image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a907da37c72907fa34c67ed937a34c83a"></a><!-- doxytag: member="isis::data::Image::voxel" ref="a907da37c72907fa34c67ed937a34c83a" args="(size_t first, size_t second=0, size_t third=0, size_t fourth=0) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; isis::data::Image::voxel </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>second</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>third</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>fourth</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a const reference to the voxel value at the given coordinates. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first coordinate in voxel space. Usually the x value / the read-encoded position.. </td></tr>
    <tr><td class="paramname">second</td><td>The second coordinate in voxel space. Usually the y value / the column-encoded position. </td></tr>
    <tr><td class="paramname">third</td><td>The third coordinate in voxel space. Ususally the z value / the time-encoded position. </td></tr>
    <tr><td class="paramname">fourth</td><td>The fourth coordinate in voxel space. Usually the time value.</td></tr>
  </table>
  </dd>
</dl>
<p>If the requested voxel is not of type T, an error will be raised.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A reference to the addressed voxel value. Only reading access is provided </dd></dl>

<p>Definition at line <a class="el" href="image_8hpp_source.html#l00406">406</a> of file <a class="el" href="image_8hpp_source.html">image.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a31aecea5e2a012d677c59222ebe13198"></a><!-- doxytag: member="isis::data::Image::voxel" ref="a31aecea5e2a012d677c59222ebe13198" args="(size_t first, size_t second=0, size_t third=0, size_t fourth=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; isis::data::Image::voxel </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>second</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>third</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>fourth</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This method returns a reference to the voxel value at the given coordinates. </p>
<p>The voxel reference provides reading and writing access to the refered value.</p>
<p>If the image is not clean, reIndex will be run. If the requested voxel is not of type T, an error will be raised.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first coordinate in voxel space. Usually the x value / the read-encoded position.. </td></tr>
    <tr><td class="paramname">second</td><td>The second coordinate in voxel space. Usually the y value / the column-encoded position. </td></tr>
    <tr><td class="paramname">third</td><td>The third coordinate in voxel space. Ususally the z value / the time-encoded position. </td></tr>
    <tr><td class="paramname">fourth</td><td>The fourth coordinate in voxel space. Usually the time value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A reference to the addressed voxel value. Reading and writing access is provided. </dd></dl>

<p>Definition at line <a class="el" href="image_8hpp_source.html#l00387">387</a> of file <a class="el" href="image_8hpp_source.html">image.hpp</a>.</p>

</div>
</div>
<hr/><h2>Field Documentation</h2>
<a class="anchor" id="a07dfbac4eb23def6dd10ab2182d98eeb"></a><!-- doxytag: member="isis::data::Image::clean" ref="a07dfbac4eb23def6dd10ab2182d98eeb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classisis_1_1data_1_1Image.html#a07dfbac4eb23def6dd10ab2182d98eeb">isis::data::Image::clean</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="image_8hpp_source.html#l00248">248</a> of file <a class="el" href="image_8hpp_source.html">image.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9c80a4fa8768d5df1c8bf67129e2cae9"></a><!-- doxytag: member="isis::data::Image::lookup" ref="a9c80a4fa8768d5df1c8bf67129e2cae9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;boost::shared_ptr&lt;<a class="el" href="classisis_1_1data_1_1Chunk.html">Chunk</a>&gt; &gt; <a class="el" href="classisis_1_1data_1_1Image.html#a9c80a4fa8768d5df1c8bf67129e2cae9">isis::data::Image::lookup</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="image_8hpp_source.html#l00210">210</a> of file <a class="el" href="image_8hpp_source.html">image.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8fa8b27baf0db3b33521c01015000ebe"></a><!-- doxytag: member="isis::data::Image::m_ColumnVec" ref="a8fa8b27baf0db3b33521c01015000ebe" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisis_1_1util_1_1vector4.html">util::fvector4</a> <a class="el" href="classisis_1_1data_1_1Image.html#a8fa8b27baf0db3b33521c01015000ebe">isis::data::Image::m_ColumnVec</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="image_8hpp_source.html#l00283">283</a> of file <a class="el" href="image_8hpp_source.html">image.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae4c1086fcefdcea6d4c026415732a0bd"></a><!-- doxytag: member="isis::data::Image::m_ColumnVecInv" ref="ae4c1086fcefdcea6d4c026415732a0bd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisis_1_1util_1_1vector4.html">util::fvector4</a> <a class="el" href="classisis_1_1data_1_1Image.html#ae4c1086fcefdcea6d4c026415732a0bd">isis::data::Image::m_ColumnVecInv</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="image_8hpp_source.html#l00284">284</a> of file <a class="el" href="image_8hpp_source.html">image.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2e1c0d32c0ffbacafb9bc54ca97fc469"></a><!-- doxytag: member="isis::data::Image::m_Offset" ref="a2e1c0d32c0ffbacafb9bc54ca97fc469" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisis_1_1util_1_1vector4.html">util::fvector4</a> <a class="el" href="classisis_1_1data_1_1Image.html#a2e1c0d32c0ffbacafb9bc54ca97fc469">isis::data::Image::m_Offset</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="image_8hpp_source.html#l00287">287</a> of file <a class="el" href="image_8hpp_source.html">image.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af304cf98a684a4ea2e9e1e1283f0025a"></a><!-- doxytag: member="isis::data::Image::m_RowVec" ref="af304cf98a684a4ea2e9e1e1283f0025a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisis_1_1util_1_1vector4.html">util::fvector4</a> <a class="el" href="classisis_1_1data_1_1Image.html#af304cf98a684a4ea2e9e1e1283f0025a">isis::data::Image::m_RowVec</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="image_8hpp_source.html#l00281">281</a> of file <a class="el" href="image_8hpp_source.html">image.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a374ae697c25b616628a0baded99903aa"></a><!-- doxytag: member="isis::data::Image::m_RowVecInv" ref="a374ae697c25b616628a0baded99903aa" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisis_1_1util_1_1vector4.html">util::fvector4</a> <a class="el" href="classisis_1_1data_1_1Image.html#a374ae697c25b616628a0baded99903aa">isis::data::Image::m_RowVecInv</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="image_8hpp_source.html#l00282">282</a> of file <a class="el" href="image_8hpp_source.html">image.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac55db4f806fb53523b0ed5c599c360ab"></a><!-- doxytag: member="isis::data::Image::m_SliceVec" ref="ac55db4f806fb53523b0ed5c599c360ab" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisis_1_1util_1_1vector4.html">util::fvector4</a> <a class="el" href="classisis_1_1data_1_1Image.html#ac55db4f806fb53523b0ed5c599c360ab">isis::data::Image::m_SliceVec</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="image_8hpp_source.html#l00285">285</a> of file <a class="el" href="image_8hpp_source.html">image.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad164cb7f1033182b3e33dff905f56787"></a><!-- doxytag: member="isis::data::Image::m_SliceVecInv" ref="ad164cb7f1033182b3e33dff905f56787" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisis_1_1util_1_1vector4.html">util::fvector4</a> <a class="el" href="classisis_1_1data_1_1Image.html#ad164cb7f1033182b3e33dff905f56787">isis::data::Image::m_SliceVecInv</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="image_8hpp_source.html#l00286">286</a> of file <a class="el" href="image_8hpp_source.html">image.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8f9c4e537ac029bc07d10ded62d0be32"></a><!-- doxytag: member="isis::data::Image::neededProperties" ref="a8f9c4e537ac029bc07d10ded62d0be32" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * <a class="el" href="classisis_1_1data_1_1Image.html#a8f9c4e537ac029bc07d10ded62d0be32">isis::data::Image::neededProperties</a><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Initial value:</b><div class="fragment"><pre class="fragment"><span class="stringliteral">&quot;\</span>
<span class="stringliteral">    voxelSize\</span>
<span class="stringliteral">    rowVec\</span>
<span class="stringliteral">    columnVec\</span>
<span class="stringliteral">    sliceVec\</span>
<span class="stringliteral">&quot;</span>
</pre></div>
<p>Definition at line <a class="el" href="image_8hpp_source.html#l00249">249</a> of file <a class="el" href="image_8hpp_source.html">image.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af3656b415fa1872a8da29f82cb98ed6e"></a><!-- doxytag: member="isis::data::Image::set" ref="af3656b415fa1872a8da29f82cb98ed6e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisis_1_1data_1_1__internal_1_1SortedChunkList.html">_internal::SortedChunkList</a> <a class="el" href="classisis_1_1data_1_1Image.html#af3656b415fa1872a8da29f82cb98ed6e">isis::data::Image::set</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="image_8hpp_source.html#l00209">209</a> of file <a class="el" href="image_8hpp_source.html">image.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/SCR/isis/lib/Core/DataStorage/<a class="el" href="image_8hpp_source.html">image.hpp</a></li>
<li>/SCR/isis/lib/Core/DataStorage/<a class="el" href="image_8cpp_source.html">image.cpp</a></li>
<li>/SCR/isis/lib/Core/DataStorage/<a class="el" href="needed_8cpp_source.html">needed.cpp</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Feb 21 2012 18:41:48 for ISIS Core Library by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
