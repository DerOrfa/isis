<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ISIS Core Library: isis::data::Image Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespaceisis.html">isis</a>      </li>
      <li><a class="el" href="namespaceisis_1_1data.html">data</a>      </li>
      <li><a class="el" href="classisis_1_1data_1_1Image.html">isis::data::Image</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a>  </div>
  <div class="headertitle">
<h1>isis::data::Image Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="isis::data::Image" --><!-- doxytag: inherits="NDimensional&lt; 4 &gt;,isis::util::PropertyMap" -->
<p><code>#include &lt;<a class="el" href="image_8hpp_source.html">image.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for isis::data::Image:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classisis_1_1data_1_1Image.png" usemap="#isis::data::Image_map" alt=""/>
  <map id="isis::data::Image_map" name="isis::data::Image_map">
<area href="classisis_1_1data_1_1__internal_1_1NDimensional.html" alt="isis::data::_internal::NDimensional&lt; 4 &gt;" shape="rect" coords="0,0,229,24"/>
<area href="classisis_1_1util_1_1PropertyMap.html" alt="isis::util::PropertyMap" shape="rect" coords="239,0,468,24"/>
<area href="classisis_1_1data_1_1TypedImage.html" alt="isis::data::TypedImage&lt; T &gt;" shape="rect" coords="119,112,348,136"/>
<area href="classisis_1_1data_1_1MemImage.html" alt="isis::data::MemImage&lt; T &gt;" shape="rect" coords="119,168,348,192"/>
</map>
</div>

<p><a href="classisis_1_1data_1_1Image-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image_1_1ChunkOp.html">ChunkOp</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#ac83f7eecffd172b0c0759cb5ee7dd633">orientation</a> { <br/>
&nbsp;&nbsp;<a class="el" href="classisis_1_1data_1_1Image.html#ac83f7eecffd172b0c0759cb5ee7dd633aee38808f2b23291db3fbb0aebe7ba405">axial</a>, 
<a class="el" href="classisis_1_1data_1_1Image.html#ac83f7eecffd172b0c0759cb5ee7dd633a64a137c1013ea7f831d25c8701c0693d">reversed_axial</a>, 
<a class="el" href="classisis_1_1data_1_1Image.html#ac83f7eecffd172b0c0759cb5ee7dd633a0d4cbf4f6526d1d6895c71e6bea6542c">sagittal</a>, 
<a class="el" href="classisis_1_1data_1_1Image.html#ac83f7eecffd172b0c0759cb5ee7dd633a3adbf32c9b5579e6e97586301f48e047">reversed_sagittal</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="classisis_1_1data_1_1Image.html#ac83f7eecffd172b0c0759cb5ee7dd633ad77b748bff3861529f19469104a94e6c">coronal</a>, 
<a class="el" href="classisis_1_1data_1_1Image.html#ac83f7eecffd172b0c0759cb5ee7dd633af6335ced67866cc519e297f42ee64caa">reversed_coronal</a>
<br/>
 }</td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#acd213fa6d0856d45e6413801f9bdec66">checkMakeClean</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#a0750957ebf3422a0fbb3d029cc9b292a">compare</a> (const <a class="el" href="classisis_1_1data_1_1Image.html">Image</a> &amp;comp) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compares the voxel-values of this image to the given.  <a href="#a0750957ebf3422a0fbb3d029cc9b292a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#a582f927569aba48d8626c9a7d941ded1">convertToType</a> (unsigned short ID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Ensure, the image has the type with the requested ID.  <a href="#a582f927569aba48d8626c9a7d941ded1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#a6828f1a6b951b3e171152287fd4a6184">copyToMem</a> (T *dst) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy all voxel data of the image into memory.  <a href="#a6828f1a6b951b3e171152287fd4a6184"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classisis_1_1data_1_1MemChunk.html">MemChunk</a>&lt; T &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#ad4c4bf9e84ee707c221cb5140cfb8f3f">copyToMemChunk</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy all voxel data into a new <a class="el" href="classisis_1_1data_1_1MemChunk.html" title="Chunk class for memory-based buffers.">MemChunk</a>.  <a href="#ad4c4bf9e84ee707c221cb5140cfb8f3f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#aac647fb29128d16d528059d481c79874">foreachChunk</a> (<a class="el" href="classisis_1_1data_1_1Image_1_1ChunkOp.html">ChunkOp</a> &amp;op, bool copyMetaData=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Run a functor with the base <a class="el" href="classisis_1_1data_1_1Image_1_1ChunkOp.html">ChunkOp</a> on every cunk in the image.  <a href="#aac647fb29128d16d528059d481c79874"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#a3b22f8df84945fb3ff35788cb295f12d">foreachVoxel</a> (<a class="el" href="classisis_1_1data_1_1Chunk_1_1VoxelOp.html">Chunk::VoxelOp</a>&lt; TYPE &gt; &amp;op)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Run a functor with the base VoxelOp on every chunk in the image.  <a href="#a3b22f8df84945fb3ff35788cb295f12d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#a873a72def2728e8cfc060ee8c6ac6bd3">getBytesPerVoxel</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">get the size of every voxel (in bytes)  <a href="#a873a72def2728e8cfc060ee8c6ac6bd3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classisis_1_1data_1_1Chunk.html">Chunk</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#afda7218833647cc6526950524775140d">getChunk</a> (size_t first, size_t second=0, size_t third=0, size_t fourth=0, bool copy_metadata=true) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the chunk that contains the voxel at the given coordinates.  <a href="#afda7218833647cc6526950524775140d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classisis_1_1data_1_1Chunk.html">Chunk</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#a882f5172bca7221c71954efdf6d0f9de">getChunk</a> (size_t first, size_t second=0, size_t third=0, size_t fourth=0, bool copy_metadata=true)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the chunk that contains the voxel at the given coordinates.  <a href="#a882f5172bca7221c71954efdf6d0f9de"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classisis_1_1data_1_1Chunk.html">Chunk</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#a72a398bd1f12cb27bc33bf0e1c693995">getChunkAs</a> (const <a class="el" href="namespaceisis_1_1data.html#ac2873e5e7a9637d4ac68253dcf140ff4">scaling_pair</a> &amp;scaling, size_t first, size_t second=0, size_t third=0, size_t fourth=0, bool copy_metadata=true) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the chunk that contains the voxel at the given coordinates in the given type (fast version).  <a href="#a72a398bd1f12cb27bc33bf0e1c693995"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classisis_1_1data_1_1Chunk.html">Chunk</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#a815e76cb9cc68006b2bbdad2cd9ded7c">getChunkAs</a> (size_t first, size_t second=0, size_t third=0, size_t fourth=0, bool copy_metadata=true) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the chunk that contains the voxel at the given coordinates in the given type.  <a href="#a815e76cb9cc68006b2bbdad2cd9ded7c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classisis_1_1data_1_1Chunk.html">Chunk</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#a27cfa5f9ced2077e578ad4bcc064e028">getChunkAt</a> (size_t at, bool copy_metadata=true) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a chunk via index (and the lookup table).  <a href="#a27cfa5f9ced2077e578ad4bcc064e028"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; boost::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classisis_1_1data_1_1Chunk.html">Chunk</a> &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#aecd5440f8550637ddb9f582f5ac7802f">getChunksAsVector</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a sorted list of pointers to the chunks of the image.  <a href="#aecd5440f8550637ddb9f582f5ac7802f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; boost::shared_ptr<br class="typebreak"/>
&lt; const <a class="el" href="classisis_1_1data_1_1Chunk.html">Chunk</a> &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#acac16e306ec8efce24cac1366f0a5c63">getChunksAsVector</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::list&lt; <a class="el" href="classisis_1_1util_1_1PropertyValue.html">util::PropertyValue</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#a97524a597e61074c8b4b2e6e0ebdf8e6">getChunksProperties</a> (const <a class="el" href="classisis_1_1util_1_1PropertyMap.html#a22562fc95dac243746790a5c6a2aad85">util::PropertyMap::KeyType</a> &amp;key, bool unique=false) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a list of the properties of the chunks for the given key.  <a href="#a97524a597e61074c8b4b2e6e0ebdf8e6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classisis_1_1util_1_1vector4.html">util::fvector4</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#a36e107da6a3d4744468b3c837534291b">getFoV</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classisis_1_1data_1_1Image.html#ac83f7eecffd172b0c0759cb5ee7dd633">orientation</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#a5d4c287dbd53f05174f3070029e19ce9">getMainOrientation</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned short&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#a601eaac6eedf7eaf6fdb6c31b1e8765d">getMajorTypeID</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the type of the chunk with "biggest" type.  <a href="#a601eaac6eedf7eaf6fdb6c31b1e8765d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#a6d5302c9e0de9fe8c97fbafa4a9e2d1e">getMajorTypeName</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::pair<br class="typebreak"/>
&lt; <a class="el" href="classisis_1_1util_1_1__internal_1_1ValueReference.html">util::ValueReference</a>, <br class="typebreak"/>
<a class="el" href="classisis_1_1util_1_1__internal_1_1ValueReference.html">util::ValueReference</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#ab437a008e59944a63c9fdc844c673ad6">getMinMax</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the maximum and the minimum voxel value of the image as a pair of ValueReference-objects.  <a href="#ab437a008e59944a63c9fdc844c673ad6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; T, T &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#ae4bef75405f6729ab6c81191dc23bfc0">getMinMaxAs</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the maximum and the minimum voxel value of the image.  <a href="#ae4bef75405f6729ab6c81191dc23bfc0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#a7db53938ebc559528240a73b24736d81">getNrOfColumms</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#ace627e4628e39615cbae3b6b43b9d915">getNrOfRows</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#a922ea56dd2eb60fbb6e0299138dcde70">getNrOfSlices</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#a142c7b80e200d9822c28fc604bb031ee">getNrOfTimesteps</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceisis_1_1data.html#ac2873e5e7a9637d4ac68253dcf140ff4">scaling_pair</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#a789138e66345f3e5a73c65dbf05b2940">getScalingTo</a> (unsigned short typeID, <a class="el" href="namespaceisis_1_1data.html#a69354ef53dcb79cbe577ae5fe8764e49">autoscaleOption</a> scaleopt=autoscale) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">for each chunk get the scaling (and offset) which would be used in an conversion to the given type  <a href="#a789138e66345f3e5a73c65dbf05b2940"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#a0ad493c5fbfed450e4f933097ee81951">Image</a> (const <a class="el" href="classisis_1_1data_1_1Image.html">Image</a> &amp;ref)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor.  <a href="#a0ad493c5fbfed450e4f933097ee81951"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#a12e82fed1ce3688fd3cb93ec04eb59a5">Image</a> (std::list&lt; T &gt; &amp;chunks)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create image from a list of Chunks or objects with the base <a class="el" href="classisis_1_1data_1_1Chunk.html" title="Main class for four-dimensional random-access data blocks.">Chunk</a>.  <a href="#a12e82fed1ce3688fd3cb93ec04eb59a5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#a83cfd8adab254c10a058e5d88630a37d">Image</a> (const <a class="el" href="classisis_1_1data_1_1Chunk.html">Chunk</a> &amp;chunk)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create image from a single chunk.  <a href="#a83cfd8adab254c10a058e5d88630a37d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#a14a33c4d2ba857b38c2188fb8e8abfd9">insertChunk</a> (const <a class="el" href="classisis_1_1data_1_1Chunk.html">Chunk</a> &amp;chunk)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a <a class="el" href="classisis_1_1data_1_1Chunk.html" title="Main class for four-dimensional random-access data blocks.">Chunk</a> into the <a class="el" href="classisis_1_1data_1_1Image.html">Image</a>.  <a href="#a14a33c4d2ba857b38c2188fb8e8abfd9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#a904fef2b4511f9c978be51bf9b7fe8f1">isClean</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#a9fb0c9f8351fddc6a2fea609d487aa2b">isEmpty</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classisis_1_1data_1_1Image.html">Image</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#aae95616fad335432d8ce3b5e5daf004a">operator=</a> (const <a class="el" href="classisis_1_1data_1_1Image.html">Image</a> &amp;ref)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy operator.  <a href="#aae95616fad335432d8ce3b5e5daf004a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#a801a02eb15ae94b384aaa97061e2ad1c">reIndex</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">(Re)computes the image layout and metadata.  <a href="#a801a02eb15ae94b384aaa97061e2ad1c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#a94fda5b511c9bfdff550d9691937aea1">spliceDownTo</a> (<a class="el" href="namespaceisis_1_1data.html#a157a8a81ce7fb08f84af9c27b7d251a3">dimensions</a> dim)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Automatically splice the given dimension and all dimensions above.  <a href="#a94fda5b511c9bfdff550d9691937aea1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#a9ed78842da8e8f0af4f2f14d71dae2ee">transformCoords</a> (boost::numeric::ublas::matrix&lt; float &gt; transform_matrix)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transforms the image coordinate system into an other system by multiplying the orientation matrix with a user defined transformation matrix.  <a href="#a9ed78842da8e8f0af4f2f14d71dae2ee"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#a907da37c72907fa34c67ed937a34c83a">voxel</a> (size_t first, size_t second=0, size_t third=0, size_t fourth=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a const reference to the voxel value at the given coordinates.  <a href="#a907da37c72907fa34c67ed937a34c83a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#a31aecea5e2a012d677c59222ebe13198">voxel</a> (size_t first, size_t second=0, size_t third=0, size_t fourth=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method returns a reference to the voxel value at the given coordinates.  <a href="#a31aecea5e2a012d677c59222ebe13198"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classisis_1_1data_1_1Chunk.html">Chunk</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#a087ed8c4884cea467e47c386c65d5be2">chunkAt</a> (size_t at)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access a chunk via index (and the lookup table) The <a class="el" href="classisis_1_1data_1_1Chunk.html" title="Main class for four-dimensional random-access data blocks.">Chunk</a> will only have metadata which are unique to it - so it might be invalid (run join on it using the image as parameter to insert all non-unique-metadata).  <a href="#a087ed8c4884cea467e47c386c65d5be2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#aece4ae886cea93d0e05087c9b3e2c85b">getChunkStride</a> (size_t base_stride=1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Search for a dimensional break in all stored chunks.  <a href="#aece4ae886cea93d0e05087c9b3e2c85b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#afe4f8006b3f04f60f68b5027ed8bbebc">Image</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an empty <a class="el" href="classisis_1_1data_1_1Image.html">Image</a> object.  <a href="#afe4f8006b3f04f60f68b5027ed8bbebc"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; boost::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classisis_1_1data_1_1Chunk.html">Chunk</a> &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#a9c80a4fa8768d5df1c8bf67129e2cae9">lookup</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classisis_1_1data_1_1__internal_1_1SortedChunkList.html">_internal::SortedChunkList</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#af3656b415fa1872a8da29f82cb98ed6e">set</a></td></tr>
<tr><td colspan="2"><h2><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#a8f9c4e537ac029bc07d10ded62d0be32">neededProperties</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>

<p>Definition at line <a class="el" href="image_8hpp_source.html#l00031">31</a> of file <a class="el" href="image_8hpp_source.html">image.hpp</a>.</p>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="ac83f7eecffd172b0c0759cb5ee7dd633"></a><!-- doxytag: member="isis::data::Image::orientation" ref="ac83f7eecffd172b0c0759cb5ee7dd633" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classisis_1_1data_1_1Image.html#ac83f7eecffd172b0c0759cb5ee7dd633">isis::data::Image::orientation</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ac83f7eecffd172b0c0759cb5ee7dd633aee38808f2b23291db3fbb0aebe7ba405"></a><!-- doxytag: member="axial" ref="ac83f7eecffd172b0c0759cb5ee7dd633aee38808f2b23291db3fbb0aebe7ba405" args="" -->axial</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ac83f7eecffd172b0c0759cb5ee7dd633a64a137c1013ea7f831d25c8701c0693d"></a><!-- doxytag: member="reversed_axial" ref="ac83f7eecffd172b0c0759cb5ee7dd633a64a137c1013ea7f831d25c8701c0693d" args="" -->reversed_axial</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ac83f7eecffd172b0c0759cb5ee7dd633a0d4cbf4f6526d1d6895c71e6bea6542c"></a><!-- doxytag: member="sagittal" ref="ac83f7eecffd172b0c0759cb5ee7dd633a0d4cbf4f6526d1d6895c71e6bea6542c" args="" -->sagittal</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ac83f7eecffd172b0c0759cb5ee7dd633a3adbf32c9b5579e6e97586301f48e047"></a><!-- doxytag: member="reversed_sagittal" ref="ac83f7eecffd172b0c0759cb5ee7dd633a3adbf32c9b5579e6e97586301f48e047" args="" -->reversed_sagittal</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ac83f7eecffd172b0c0759cb5ee7dd633ad77b748bff3861529f19469104a94e6c"></a><!-- doxytag: member="coronal" ref="ac83f7eecffd172b0c0759cb5ee7dd633ad77b748bff3861529f19469104a94e6c" args="" -->coronal</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ac83f7eecffd172b0c0759cb5ee7dd633af6335ced67866cc519e297f42ee64caa"></a><!-- doxytag: member="reversed_coronal" ref="ac83f7eecffd172b0c0759cb5ee7dd633af6335ced67866cc519e297f42ee64caa" args="" -->reversed_coronal</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="image_8hpp_source.html#l00036">36</a> of file <a class="el" href="image_8hpp_source.html">image.hpp</a>.</p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="afe4f8006b3f04f60f68b5027ed8bbebc"></a><!-- doxytag: member="isis::data::Image::Image" ref="afe4f8006b3f04f60f68b5027ed8bbebc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">isis::data::Image::Image </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an empty <a class="el" href="classisis_1_1data_1_1Image.html">Image</a> object. </p>

<p>Definition at line <a class="el" href="image_8cpp_source.html#l00034">34</a> of file <a class="el" href="image_8cpp_source.html">image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0ad493c5fbfed450e4f933097ee81951"></a><!-- doxytag: member="isis::data::Image::Image" ref="a0ad493c5fbfed450e4f933097ee81951" args="(const Image &amp;ref)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">isis::data::Image::Image </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classisis_1_1data_1_1Image.html">Image</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ref</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy constructor. </p>
<p>Copies all elements, only the voxel-data (in the chunks) are referenced. </p>

<p>Definition at line <a class="el" href="image_8cpp_source.html#l00055">55</a> of file <a class="el" href="image_8cpp_source.html">image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a12e82fed1ce3688fd3cb93ec04eb59a5"></a><!-- doxytag: member="isis::data::Image::Image" ref="a12e82fed1ce3688fd3cb93ec04eb59a5" args="(std::list&lt; T &gt; &amp;chunks)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">isis::data::Image::Image </td>
          <td>(</td>
          <td class="paramtype">std::list&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>chunks</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create image from a list of Chunks or objects with the base <a class="el" href="classisis_1_1data_1_1Chunk.html" title="Main class for four-dimensional random-access data blocks.">Chunk</a>. </p>
<p>Removes used chunks from the given list. So afterwards the list consists of the rejected chunks. </p>

<p>Definition at line <a class="el" href="image_8hpp_source.html#l00125">125</a> of file <a class="el" href="image_8hpp_source.html">image.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a83cfd8adab254c10a058e5d88630a37d"></a><!-- doxytag: member="isis::data::Image::Image" ref="a83cfd8adab254c10a058e5d88630a37d" args="(const Chunk &amp;chunk)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">isis::data::Image::Image </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classisis_1_1data_1_1Chunk.html">Chunk</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>chunk</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create image from a single chunk. </p>

<p>Definition at line <a class="el" href="image_8cpp_source.html#l00041">41</a> of file <a class="el" href="image_8cpp_source.html">image.cpp</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="acd213fa6d0856d45e6413801f9bdec66"></a><!-- doxytag: member="isis::data::Image::checkMakeClean" ref="acd213fa6d0856d45e6413801f9bdec66" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isis::data::Image::checkMakeClean </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="image_8cpp_source.html#l00082">82</a> of file <a class="el" href="image_8cpp_source.html">image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a087ed8c4884cea467e47c386c65d5be2"></a><!-- doxytag: member="isis::data::Image::chunkAt" ref="a087ed8c4884cea467e47c386c65d5be2" args="(size_t at)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisis_1_1data_1_1Chunk.html">Chunk</a> &amp; isis::data::Image::chunkAt </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>at</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Access a chunk via index (and the lookup table) The <a class="el" href="classisis_1_1data_1_1Chunk.html" title="Main class for four-dimensional random-access data blocks.">Chunk</a> will only have metadata which are unique to it - so it might be invalid (run join on it using the image as parameter to insert all non-unique-metadata). </p>

<p>Definition at line <a class="el" href="image_8cpp_source.html#l00377">377</a> of file <a class="el" href="image_8cpp_source.html">image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0750957ebf3422a0fbb3d029cc9b292a"></a><!-- doxytag: member="isis::data::Image::compare" ref="a0750957ebf3422a0fbb3d029cc9b292a" args="(const Image &amp;comp) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t isis::data::Image::compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classisis_1_1data_1_1Image.html">Image</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>comp</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compares the voxel-values of this image to the given. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the amount of the different voxels </dd></dl>

<p>Definition at line <a class="el" href="image_8cpp_source.html#l00542">542</a> of file <a class="el" href="image_8cpp_source.html">image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a582f927569aba48d8626c9a7d941ded1"></a><!-- doxytag: member="isis::data::Image::convertToType" ref="a582f927569aba48d8626c9a7d941ded1" args="(unsigned short ID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isis::data::Image::convertToType </td>
          <td>(</td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>ID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Ensure, the image has the type with the requested ID. </p>
<p>If the typeID of any chunk is not equal to the requested ID, the data of the chunk is replaced by an converted version. The conversion is done using the value range of the image. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>false if there was an error </dd></dl>

</div>
</div>
<a class="anchor" id="a6828f1a6b951b3e171152287fd4a6184"></a><!-- doxytag: member="isis::data::Image::copyToMem" ref="a6828f1a6b951b3e171152287fd4a6184" args="(T *dst) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void isis::data::Image::copyToMem </td>
          <td>(</td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>dst</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy all voxel data of the image into memory. </p>
<p>If neccessary a conversion into T is done using min/max of the image. </p>

<p>Definition at line <a class="el" href="image_8hpp_source.html#l00379">379</a> of file <a class="el" href="image_8hpp_source.html">image.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad4c4bf9e84ee707c221cb5140cfb8f3f"></a><!-- doxytag: member="isis::data::Image::copyToMemChunk" ref="ad4c4bf9e84ee707c221cb5140cfb8f3f" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisis_1_1data_1_1MemChunk.html">MemChunk</a>&lt;T&gt; isis::data::Image::copyToMemChunk </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy all voxel data into a new <a class="el" href="classisis_1_1data_1_1MemChunk.html" title="Chunk class for memory-based buffers.">MemChunk</a>. </p>
<p>This creates a <a class="el" href="classisis_1_1data_1_1MemChunk.html" title="Chunk class for memory-based buffers.">MemChunk</a>&lt;T&gt; of the requested type and the same size as the <a class="el" href="classisis_1_1data_1_1Image.html">Image</a> and then copies all voxeldata of the image into that <a class="el" href="classisis_1_1data_1_1Chunk.html" title="Main class for four-dimensional random-access data blocks.">Chunk</a>. If neccessary a conversion into T is done using min/max of the image. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a <a class="el" href="classisis_1_1data_1_1MemChunk.html" title="Chunk class for memory-based buffers.">MemChunk</a>&lt;T&gt; containing the voxeldata of the <a class="el" href="classisis_1_1data_1_1Image.html">Image</a> (but not its Properties) </dd></dl>

<p>Definition at line <a class="el" href="image_8hpp_source.html#l00401">401</a> of file <a class="el" href="image_8hpp_source.html">image.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aac647fb29128d16d528059d481c79874"></a><!-- doxytag: member="isis::data::Image::foreachChunk" ref="aac647fb29128d16d528059d481c79874" args="(ChunkOp &amp;op, bool copyMetaData=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t isis::data::Image::foreachChunk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classisis_1_1data_1_1Image_1_1ChunkOp.html">Image::ChunkOp</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>copyMetaData</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Run a functor with the base <a class="el" href="classisis_1_1data_1_1Image_1_1ChunkOp.html">ChunkOp</a> on every cunk in the image. </p>
<p>This does not check the types of the images. So if your functor needs a specific type, use <a class="el" href="classisis_1_1data_1_1TypedImage.html" title="An Image where all chunks are guaranteed to have a specific type.">TypedImage</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>op</em>&nbsp;</td><td>a functor object which inherits ChunkOP </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>copyMetaData</em>&nbsp;</td><td>if true the metadata of the image are copied into the chunks before calling the functor </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="image_8cpp_source.html#l00720">720</a> of file <a class="el" href="image_8cpp_source.html">image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3b22f8df84945fb3ff35788cb295f12d"></a><!-- doxytag: member="isis::data::Image::foreachVoxel" ref="a3b22f8df84945fb3ff35788cb295f12d" args="(Chunk::VoxelOp&lt; TYPE &gt; &amp;op)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t isis::data::Image::foreachVoxel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classisis_1_1data_1_1Chunk_1_1VoxelOp.html">Chunk::VoxelOp</a>&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>op</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Run a functor with the base VoxelOp on every chunk in the image. </p>
<p>If any chunk does not have the requested type it will be converted. So the result is equivalent to <a class="el" href="classisis_1_1data_1_1TypedImage.html" title="An Image where all chunks are guaranteed to have a specific type.">TypedImage</a>&lt;TYPE&gt;. If these conversion failes no operation is done, and false is returned. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>op</em>&nbsp;</td><td>a functor object which inherits <a class="el" href="classisis_1_1data_1_1Image_1_1ChunkOp.html">ChunkOp</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="image_8hpp_source.html#l00438">438</a> of file <a class="el" href="image_8hpp_source.html">image.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a873a72def2728e8cfc060ee8c6ac6bd3"></a><!-- doxytag: member="isis::data::Image::getBytesPerVoxel" ref="a873a72def2728e8cfc060ee8c6ac6bd3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t isis::data::Image::getBytesPerVoxel </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>get the size of every voxel (in bytes) </p>

<p>Definition at line <a class="el" href="image_8cpp_source.html#l00487">487</a> of file <a class="el" href="image_8cpp_source.html">image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="afda7218833647cc6526950524775140d"></a><!-- doxytag: member="isis::data::Image::getChunk" ref="afda7218833647cc6526950524775140d" args="(size_t first, size_t second=0, size_t third=0, size_t fourth=0, bool copy_metadata=true) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classisis_1_1data_1_1Chunk.html">Chunk</a> isis::data::Image::getChunk </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>second</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>third</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>fourth</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>copy_metadata</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the chunk that contains the voxel at the given coordinates. </p>
<p>If the image is not clean, behaviour is undefined. (See Image::commonGet).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>first</em>&nbsp;</td><td>The first coordinate in voxel space. Usually the x value / the read-encoded position. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>second</em>&nbsp;</td><td>The second coordinate in voxel space. Usually the y value / the column-encoded position. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>third</em>&nbsp;</td><td>The third coordinate in voxel space. Ususally the z value / the slice-encoded position. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fourth</em>&nbsp;</td><td>The fourth coordinate in voxel space. Usually the time value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>copy_metadata</em>&nbsp;</td><td>if true the metadata of the image are merged into the returned chunk </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a copy of the chunk that contains the voxel at the given coordinates. (Reminder: Chunk-copies are cheap, so the image data are NOT copied but referenced) </dd></dl>

<p>Definition at line <a class="el" href="image_8cpp_source.html#l00388">388</a> of file <a class="el" href="image_8cpp_source.html">image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a882f5172bca7221c71954efdf6d0f9de"></a><!-- doxytag: member="isis::data::Image::getChunk" ref="a882f5172bca7221c71954efdf6d0f9de" args="(size_t first, size_t second=0, size_t third=0, size_t fourth=0, bool copy_metadata=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisis_1_1data_1_1Chunk.html">Chunk</a> isis::data::Image::getChunk </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>second</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>third</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>fourth</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>copy_metadata</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the chunk that contains the voxel at the given coordinates. </p>
<p>If the image is not clean <a class="el" href="classisis_1_1data_1_1Image.html#a801a02eb15ae94b384aaa97061e2ad1c" title="(Re)computes the image layout and metadata.">Image::reIndex()</a> will be run.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>first</em>&nbsp;</td><td>The first coordinate in voxel space. Usually the x value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>second</em>&nbsp;</td><td>The second coordinate in voxel space. Usually the y value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>third</em>&nbsp;</td><td>The third coordinate in voxel space. Ususally the z value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fourth</em>&nbsp;</td><td>The fourth coordinate in voxel space. Usually the time value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>copy_metadata</em>&nbsp;</td><td>if true the metadata of the image are merged into the returned chunk </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a copy of the chunk that contains the voxel at the given coordinates. (Reminder: Chunk-copies are cheap, so the image data are NOT copied but referenced) </dd></dl>

<p>Definition at line <a class="el" href="image_8cpp_source.html#l00382">382</a> of file <a class="el" href="image_8cpp_source.html">image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a72a398bd1f12cb27bc33bf0e1c693995"></a><!-- doxytag: member="isis::data::Image::getChunkAs" ref="a72a398bd1f12cb27bc33bf0e1c693995" args="(const scaling_pair &amp;scaling, size_t first, size_t second=0, size_t third=0, size_t fourth=0, bool copy_metadata=true) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisis_1_1data_1_1Chunk.html">Chunk</a> isis::data::Image::getChunkAs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceisis_1_1data.html#ac2873e5e7a9637d4ac68253dcf140ff4">scaling_pair</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>scaling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>second</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>third</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>fourth</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>copy_metadata</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the chunk that contains the voxel at the given coordinates in the given type (fast version). </p>
<p>If the accordant chunk has type T a cheap copy is returned. Otherwise a MemChunk-copy of the requested type is created from it. In this case the minimum and maximum values of the image are computed and used for the <a class="el" href="classisis_1_1data_1_1MemChunk.html" title="Chunk class for memory-based buffers.">MemChunk</a> constructor.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>first</em>&nbsp;</td><td>The first coordinate in voxel space. Usually the x value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>second</em>&nbsp;</td><td>The second coordinate in voxel space. Usually the y value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>third</em>&nbsp;</td><td>The third coordinate in voxel space. Ususally the z value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fourth</em>&nbsp;</td><td>The fourth coordinate in voxel space. Usually the time value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>copy_metadata</em>&nbsp;</td><td>if true the metadata of the image are merged into the returned chunk </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a (maybe converted) chunk containing the voxel value at the given coordinates. </dd></dl>
 This version does not compute the scaling, and thus is much faster. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>scaling</em>&nbsp;</td><td>the scaling (scale and offset) to be used if a conversion to the requested type is neccessary. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>first</em>&nbsp;</td><td>The first coordinate in voxel space. Usually the x value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>second</em>&nbsp;</td><td>The second coordinate in voxel space. Usually the y value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>third</em>&nbsp;</td><td>The third coordinate in voxel space. Ususally the z value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fourth</em>&nbsp;</td><td>The fourth coordinate in voxel space. Usually the time value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>copy_metadata</em>&nbsp;</td><td>if true the metadata of the image are merged into the returned chunk </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a (maybe converted) chunk containing the voxel value at the given coordinates. </dd></dl>

<p>Definition at line <a class="el" href="image_8hpp_source.html#l00299">299</a> of file <a class="el" href="image_8hpp_source.html">image.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a815e76cb9cc68006b2bbdad2cd9ded7c"></a><!-- doxytag: member="isis::data::Image::getChunkAs" ref="a815e76cb9cc68006b2bbdad2cd9ded7c" args="(size_t first, size_t second=0, size_t third=0, size_t fourth=0, bool copy_metadata=true) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisis_1_1data_1_1Chunk.html">Chunk</a> isis::data::Image::getChunkAs </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>second</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>third</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>fourth</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>copy_metadata</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the chunk that contains the voxel at the given coordinates in the given type. </p>
<p>If the accordant chunk has type T a cheap copy is returned. Otherwise a MemChunk-copy of the requested type is created from it. In this case the minimum and maximum values of the image are computed and used for the <a class="el" href="classisis_1_1data_1_1MemChunk.html" title="Chunk class for memory-based buffers.">MemChunk</a> constructor.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>first</em>&nbsp;</td><td>The first coordinate in voxel space. Usually the x value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>second</em>&nbsp;</td><td>The second coordinate in voxel space. Usually the y value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>third</em>&nbsp;</td><td>The third coordinate in voxel space. Ususally the z value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fourth</em>&nbsp;</td><td>The fourth coordinate in voxel space. Usually the time value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>copy_metadata</em>&nbsp;</td><td>if true the metadata of the image are merged into the returned chunk </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a (maybe converted) chunk containing the voxel value at the given coordinates. </dd></dl>

<p>Definition at line <a class="el" href="image_8hpp_source.html#l00284">284</a> of file <a class="el" href="image_8hpp_source.html">image.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a27cfa5f9ced2077e578ad4bcc064e028"></a><!-- doxytag: member="isis::data::Image::getChunkAt" ref="a27cfa5f9ced2077e578ad4bcc064e028" args="(size_t at, bool copy_metadata=true) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisis_1_1data_1_1Chunk.html">Chunk</a> isis::data::Image::getChunkAt </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>at</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>copy_metadata</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a chunk via index (and the lookup table). </p>
<p>The returned chunk will be a cheap copy of the original chunk. If copy_metadata is true the metadata of the image is copied into the chunk. </p>

<p>Definition at line <a class="el" href="image_8cpp_source.html#l00369">369</a> of file <a class="el" href="image_8cpp_source.html">image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aecd5440f8550637ddb9f582f5ac7802f"></a><!-- doxytag: member="isis::data::Image::getChunksAsVector" ref="aecd5440f8550637ddb9f582f5ac7802f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; boost::shared_ptr&lt; <a class="el" href="classisis_1_1data_1_1Chunk.html">Chunk</a> &gt; &gt; isis::data::Image::getChunksAsVector </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a sorted list of pointers to the chunks of the image. </p>
<p>Note: this chunks only have metadata which are unique to them - so they might be invalid. (run join on copies of them using the image as parameter to insert all non-unique-metadata). </p>

<p>Definition at line <a class="el" href="image_8cpp_source.html#l00393">393</a> of file <a class="el" href="image_8cpp_source.html">image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="acac16e306ec8efce24cac1366f0a5c63"></a><!-- doxytag: member="isis::data::Image::getChunksAsVector" ref="acac16e306ec8efce24cac1366f0a5c63" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; boost::shared_ptr&lt; const <a class="el" href="classisis_1_1data_1_1Chunk.html">Chunk</a> &gt; &gt; isis::data::Image::getChunksAsVector </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get a sorted list of pointers to the chunks of the image. </p>
<p>Note: this chunks only have metadata which are unique to them - so they might be invalid. (run join on copies of them using the image as parameter to insert all non-unique-metadata). </p>
 
<p>Definition at line <a class="el" href="image_8cpp_source.html#l00399">399</a> of file <a class="el" href="image_8cpp_source.html">image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a97524a597e61074c8b4b2e6e0ebdf8e6"></a><!-- doxytag: member="isis::data::Image::getChunksProperties" ref="a97524a597e61074c8b4b2e6e0ebdf8e6" args="(const util::PropertyMap::KeyType &amp;key, bool unique=false) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt; <a class="el" href="classisis_1_1util_1_1PropertyValue.html">util::PropertyValue</a> &gt; isis::data::Image::getChunksProperties </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classisis_1_1util_1_1PropertyMap.html#a22562fc95dac243746790a5c6a2aad85">util::PropertyMap::KeyType</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>unique</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a list of the properties of the chunks for the given key. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>the name of the property to search for </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>unique</em>&nbsp;</td><td>when true empty or consecutive duplicates wont be added </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="image_8cpp_source.html#l00464">464</a> of file <a class="el" href="image_8cpp_source.html">image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aece4ae886cea93d0e05087c9b3e2c85b"></a><!-- doxytag: member="isis::data::Image::getChunkStride" ref="aece4ae886cea93d0e05087c9b3e2c85b" args="(size_t base_stride=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t isis::data::Image::getChunkStride </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>base_stride</em> = <code>1</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Search for a dimensional break in all stored chunks. </p>
<p>This function searches for two chunks whose (geometrical) distance is more than twice the distance between the first and the second chunk. It wll assume a dimensional break at this position.</p>
<p>Normally chunks are beneath each other (like characters in a text) so their distance is more or less constant. But if there is a dimensional break (analogous to the linebreak in a text) the distance between this particular chunks/characters is bigger than twice the normal distance</p>
<p>For example for an image of 2D-chunks (slices) getChunkStride(1) will get the number of slices (size of third dim) and getChunkStride(slices) will get the number of timesteps </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>base_stride</em>&nbsp;</td><td>the base_stride for the iteration between chunks (1 for the first dimension, one "line" for the second and soon...) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the length of this chunk-"line" / the stride </dd></dl>

<p>Definition at line <a class="el" href="image_8cpp_source.html#l00406">406</a> of file <a class="el" href="image_8cpp_source.html">image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a36e107da6a3d4744468b3c837534291b"></a><!-- doxytag: member="isis::data::Image::getFoV" ref="a36e107da6a3d4744468b3c837534291b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisis_1_1util_1_1vector4.html">util::fvector4</a> isis::data::Image::getFoV </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="image_8cpp_source.html#l00762">762</a> of file <a class="el" href="image_8cpp_source.html">image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5d4c287dbd53f05174f3070029e19ce9"></a><!-- doxytag: member="isis::data::Image::getMainOrientation" ref="a5d4c287dbd53f05174f3070029e19ce9" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisis_1_1data_1_1Image.html#ac83f7eecffd172b0c0759cb5ee7dd633">Image::orientation</a> isis::data::Image::getMainOrientation </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="image_8cpp_source.html#l00576">576</a> of file <a class="el" href="image_8cpp_source.html">image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a601eaac6eedf7eaf6fdb6c31b1e8765d"></a><!-- doxytag: member="isis::data::Image::getMajorTypeID" ref="a601eaac6eedf7eaf6fdb6c31b1e8765d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short isis::data::Image::getMajorTypeID </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the type of the chunk with "biggest" type. </p>
<p>Determines the minimum and maximum of the image, (and with that the types of these limits). If they are not the same, the type which can store the other type is selected. E.g. if min is "-5(int8_t)" and max is "1000(int16_t)" "int16_t" is selected. Warning1: this will fail if min is "-5(int8_t)" and max is "70000(uint16_t)" Warning2: the cost of this is O(n) while <a class="el" href="classisis_1_1data_1_1Chunk.html#aaa66a58ddd4cf865cbb92850a2a1d40c">Chunk::getTypeID</a> is O(1) - so do not use it in loops Warning3: the result is not exact - so never use it to determine the type for <a class="el" href="classisis_1_1data_1_1Image.html#a31aecea5e2a012d677c59222ebe13198" title="This method returns a reference to the voxel value at the given coordinates.">Image::voxel</a> (Use <a class="el" href="classisis_1_1data_1_1TypedImage.html" title="An Image where all chunks are guaranteed to have a specific type.">TypedImage</a> to get an image with an guaranteed type) </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a number which is equal to the <a class="el" href="classisis_1_1data_1_1ValuePtr.html#afaf56a4a73ada017a6eefbdb03cb82a2">ValuePtr::staticID</a> of the selected type. </dd></dl>

<p>Definition at line <a class="el" href="image_8cpp_source.html#l00623">623</a> of file <a class="el" href="image_8cpp_source.html">image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6d5302c9e0de9fe8c97fbafa4a9e2d1e"></a><!-- doxytag: member="isis::data::Image::getMajorTypeName" ref="a6d5302c9e0de9fe8c97fbafa4a9e2d1e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string isis::data::Image::getMajorTypeName </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the typename correspondig to the result of typeID </dd></dl>

<p>Definition at line <a class="el" href="image_8cpp_source.html#l00642">642</a> of file <a class="el" href="image_8cpp_source.html">image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab437a008e59944a63c9fdc844c673ad6"></a><!-- doxytag: member="isis::data::Image::getMinMax" ref="ab437a008e59944a63c9fdc844c673ad6" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classisis_1_1util_1_1__internal_1_1ValueReference.html">util::ValueReference</a>, <a class="el" href="classisis_1_1util_1_1__internal_1_1ValueReference.html">util::ValueReference</a> &gt; isis::data::Image::getMinMax </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the maximum and the minimum voxel value of the image as a pair of ValueReference-objects. </p>

<p>Definition at line <a class="el" href="image_8cpp_source.html#l00501">501</a> of file <a class="el" href="image_8cpp_source.html">image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae4bef75405f6729ab6c81191dc23bfc0"></a><!-- doxytag: member="isis::data::Image::getMinMaxAs" ref="ae4bef75405f6729ab6c81191dc23bfc0" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;T, T&gt; isis::data::Image::getMinMaxAs </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the maximum and the minimum voxel value of the image. </p>
<p>The results are converted to T. If they dont fit an error ist send. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pair of T storing the minimum and maximum values of the image. </dd></dl>

<p>Definition at line <a class="el" href="image_8hpp_source.html#l00343">343</a> of file <a class="el" href="image_8hpp_source.html">image.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7db53938ebc559528240a73b24736d81"></a><!-- doxytag: member="isis::data::Image::getNrOfColumms" ref="a7db53938ebc559528240a73b24736d81" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t isis::data::Image::getNrOfColumms </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of columns of the image </dd></dl>

<p>Definition at line <a class="el" href="image_8cpp_source.html#l00744">744</a> of file <a class="el" href="image_8cpp_source.html">image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ace627e4628e39615cbae3b6b43b9d915"></a><!-- doxytag: member="isis::data::Image::getNrOfRows" ref="ace627e4628e39615cbae3b6b43b9d915" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t isis::data::Image::getNrOfRows </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of rows of the image </dd></dl>

<p>Definition at line <a class="el" href="image_8cpp_source.html#l00749">749</a> of file <a class="el" href="image_8cpp_source.html">image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a922ea56dd2eb60fbb6e0299138dcde70"></a><!-- doxytag: member="isis::data::Image::getNrOfSlices" ref="a922ea56dd2eb60fbb6e0299138dcde70" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t isis::data::Image::getNrOfSlices </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of slices of the image </dd></dl>

<p>Definition at line <a class="el" href="image_8cpp_source.html#l00753">753</a> of file <a class="el" href="image_8cpp_source.html">image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a142c7b80e200d9822c28fc604bb031ee"></a><!-- doxytag: member="isis::data::Image::getNrOfTimesteps" ref="a142c7b80e200d9822c28fc604bb031ee" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t isis::data::Image::getNrOfTimesteps </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of timesteps of the image </dd></dl>

<p>Definition at line <a class="el" href="image_8cpp_source.html#l00757">757</a> of file <a class="el" href="image_8cpp_source.html">image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a789138e66345f3e5a73c65dbf05b2940"></a><!-- doxytag: member="isis::data::Image::getScalingTo" ref="a789138e66345f3e5a73c65dbf05b2940" args="(unsigned short typeID, autoscaleOption scaleopt=autoscale) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceisis_1_1data.html#ac2873e5e7a9637d4ac68253dcf140ff4">scaling_pair</a> isis::data::Image::getScalingTo </td>
          <td>(</td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>typeID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceisis_1_1data.html#a69354ef53dcb79cbe577ae5fe8764e49">autoscaleOption</a>&nbsp;</td>
          <td class="paramname"> <em>scaleopt</em> = <code>autoscale</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>for each chunk get the scaling (and offset) which would be used in an conversion to the given type </p>

</div>
</div>
<a class="anchor" id="a14a33c4d2ba857b38c2188fb8e8abfd9"></a><!-- doxytag: member="isis::data::Image::insertChunk" ref="a14a33c4d2ba857b38c2188fb8e8abfd9" args="(const Chunk &amp;chunk)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isis::data::Image::insertChunk </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classisis_1_1data_1_1Chunk.html">Chunk</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>chunk</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert a <a class="el" href="classisis_1_1data_1_1Chunk.html" title="Main class for four-dimensional random-access data blocks.">Chunk</a> into the <a class="el" href="classisis_1_1data_1_1Image.html">Image</a>. </p>
<p>The insertion is sorted and unique. So the <a class="el" href="classisis_1_1data_1_1Chunk.html" title="Main class for four-dimensional random-access data blocks.">Chunk</a> will be inserted behind a geometrically "lower" <a class="el" href="classisis_1_1data_1_1Chunk.html" title="Main class for four-dimensional random-access data blocks.">Chunk</a> if there is one. If there is allready a <a class="el" href="classisis_1_1data_1_1Chunk.html" title="Main class for four-dimensional random-access data blocks.">Chunk</a> at the proposed position this <a class="el" href="classisis_1_1data_1_1Chunk.html" title="Main class for four-dimensional random-access data blocks.">Chunk</a> wont be inserted.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>chunk</em>&nbsp;</td><td>The <a class="el" href="classisis_1_1data_1_1Chunk.html" title="Main class for four-dimensional random-access data blocks.">Chunk</a> to be inserted </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the <a class="el" href="classisis_1_1data_1_1Chunk.html" title="Main class for four-dimensional random-access data blocks.">Chunk</a> was inserted, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="image_8cpp_source.html#l00125">125</a> of file <a class="el" href="image_8cpp_source.html">image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a904fef2b4511f9c978be51bf9b7fe8f1"></a><!-- doxytag: member="isis::data::Image::isClean" ref="a904fef2b4511f9c978be51bf9b7fe8f1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isis::data::Image::isClean </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="image_8cpp_source.html#l00094">94</a> of file <a class="el" href="image_8cpp_source.html">image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9fb0c9f8351fddc6a2fea609d487aa2b"></a><!-- doxytag: member="isis::data::Image::isEmpty" ref="a9fb0c9f8351fddc6a2fea609d487aa2b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isis::data::Image::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>true if there is no chunk in the image </dd></dl>

<p>Reimplemented from <a class="el" href="classisis_1_1util_1_1PropertyMap.html#a4a6bae8173d0a0e910903a634be674af">isis::util::PropertyMap</a>.</p>

<p>Definition at line <a class="el" href="image_8cpp_source.html#l00355">355</a> of file <a class="el" href="image_8cpp_source.html">image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aae95616fad335432d8ce3b5e5daf004a"></a><!-- doxytag: member="isis::data::Image::operator=" ref="aae95616fad335432d8ce3b5e5daf004a" args="(const Image &amp;ref)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisis_1_1data_1_1Image.html">Image</a> &amp; isis::data::Image::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classisis_1_1data_1_1Image.html">Image</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ref</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy operator. </p>
<p>Copies all elements, only the voxel-data (in the chunks) are referenced. </p>

<p>Reimplemented in <a class="el" href="classisis_1_1data_1_1TypedImage.html#a16654e67097e9e70a1bcc16b84bdd640">isis::data::TypedImage&lt; T &gt;</a>, and <a class="el" href="classisis_1_1data_1_1MemImage.html#a734d63e8c8c9d1eec740522451662f7f">isis::data::MemImage&lt; T &gt;</a>.</p>

<p>Definition at line <a class="el" href="image_8cpp_source.html#l00061">61</a> of file <a class="el" href="image_8cpp_source.html">image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a801a02eb15ae94b384aaa97061e2ad1c"></a><!-- doxytag: member="isis::data::Image::reIndex" ref="a801a02eb15ae94b384aaa97061e2ad1c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isis::data::Image::reIndex </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>(Re)computes the image layout and metadata. </p>
<p>The image will be "clean" on success. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the image was successfully reindexed and is valid, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="image_8cpp_source.html#l00168">168</a> of file <a class="el" href="image_8cpp_source.html">image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a94fda5b511c9bfdff550d9691937aea1"></a><!-- doxytag: member="isis::data::Image::spliceDownTo" ref="a94fda5b511c9bfdff550d9691937aea1" args="(dimensions dim)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t isis::data::Image::spliceDownTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceisis_1_1data.html#a157a8a81ce7fb08f84af9c27b7d251a3">dimensions</a>&nbsp;</td>
          <td class="paramname"> <em>dim</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Automatically splice the given dimension and all dimensions above. </p>
<p>e.g. spliceDownTo(sliceDim) will result in an image made of slices (aka 2d-chunks). </p>

<p>Definition at line <a class="el" href="image_8cpp_source.html#l00661">661</a> of file <a class="el" href="image_8cpp_source.html">image.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9ed78842da8e8f0af4f2f14d71dae2ee"></a><!-- doxytag: member="isis::data::Image::transformCoords" ref="a9ed78842da8e8f0af4f2f14d71dae2ee" args="(boost::numeric::ublas::matrix&lt; float &gt; transform_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void isis::data::Image::transformCoords </td>
          <td>(</td>
          <td class="paramtype">boost::numeric::ublas::matrix&lt; float &gt;&nbsp;</td>
          <td class="paramname"> <em>transform_matrix</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transforms the image coordinate system into an other system by multiplying the orientation matrix with a user defined transformation matrix. </p>
<p>Additionally, the index origin will be transformed into the new coordinate system. This function only changes the</p>
<p><b>IMPORTANT!</b>: If you call this function with a matrix other than the identidy matrix, it's not guaranteed that the image is still in ISIS space according to the DICOM conventions. Eventuelly some ISIS algorithms that depend on correct image orientations won't work as expected. Use this method with caution! </p>

<p>Definition at line <a class="el" href="image_8hpp_source.html#l00371">371</a> of file <a class="el" href="image_8hpp_source.html">image.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a31aecea5e2a012d677c59222ebe13198"></a><!-- doxytag: member="isis::data::Image::voxel" ref="a31aecea5e2a012d677c59222ebe13198" args="(size_t first, size_t second=0, size_t third=0, size_t fourth=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; isis::data::Image::voxel </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>second</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>third</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>fourth</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This method returns a reference to the voxel value at the given coordinates. </p>
<p>The voxel reference provides reading and writing access to the refered value.</p>
<p>If the image is not clean, reIndex will be run. If the requested voxel is not of type T, an error will be raised.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>first</em>&nbsp;</td><td>The first coordinate in voxel space. Usually the x value / the read-encoded position.. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>second</em>&nbsp;</td><td>The second coordinate in voxel space. Usually the y value / the column-encoded position. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>third</em>&nbsp;</td><td>The third coordinate in voxel space. Ususally the z value / the time-encoded position. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fourth</em>&nbsp;</td><td>The fourth coordinate in voxel space. Usually the time value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A reference to the addressed voxel value. Reading and writing access is provided. </dd></dl>

<p>Definition at line <a class="el" href="image_8hpp_source.html#l00185">185</a> of file <a class="el" href="image_8hpp_source.html">image.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a907da37c72907fa34c67ed937a34c83a"></a><!-- doxytag: member="isis::data::Image::voxel" ref="a907da37c72907fa34c67ed937a34c83a" args="(size_t first, size_t second=0, size_t third=0, size_t fourth=0) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; isis::data::Image::voxel </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>second</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>third</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>fourth</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a const reference to the voxel value at the given coordinates. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>first</em>&nbsp;</td><td>The first coordinate in voxel space. Usually the x value / the read-encoded position.. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>second</em>&nbsp;</td><td>The second coordinate in voxel space. Usually the y value / the column-encoded position. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>third</em>&nbsp;</td><td>The third coordinate in voxel space. Ususally the z value / the time-encoded position. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fourth</em>&nbsp;</td><td>The fourth coordinate in voxel space. Usually the time value.</td></tr>
  </table>
  </dd>
</dl>
<p>If the requested voxel is not of type T, an error will be raised.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A reference to the addressed voxel value. Only reading access is provided </dd></dl>

<p>Definition at line <a class="el" href="image_8hpp_source.html#l00204">204</a> of file <a class="el" href="image_8hpp_source.html">image.hpp</a>.</p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a9c80a4fa8768d5df1c8bf67129e2cae9"></a><!-- doxytag: member="isis::data::Image::lookup" ref="a9c80a4fa8768d5df1c8bf67129e2cae9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;boost::shared_ptr&lt;<a class="el" href="classisis_1_1data_1_1Chunk.html">Chunk</a>&gt; &gt; <a class="el" href="classisis_1_1data_1_1Image.html#a9c80a4fa8768d5df1c8bf67129e2cae9">isis::data::Image::lookup</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="image_8hpp_source.html#l00040">40</a> of file <a class="el" href="image_8hpp_source.html">image.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8f9c4e537ac029bc07d10ded62d0be32"></a><!-- doxytag: member="isis::data::Image::neededProperties" ref="a8f9c4e537ac029bc07d10ded62d0be32" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * <a class="el" href="classisis_1_1data_1_1Image.html#a8f9c4e537ac029bc07d10ded62d0be32">isis::data::Image::neededProperties</a><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Initial value:</b><div class="fragment"><pre class="fragment"><span class="stringliteral">&quot;\</span>
<span class="stringliteral">    voxelSize\</span>
<span class="stringliteral">    rowVec\</span>
<span class="stringliteral">    columnVec\</span>
<span class="stringliteral">    sliceVec\</span>
<span class="stringliteral">&quot;</span>
</pre></div>
<p>Definition at line <a class="el" href="image_8hpp_source.html#l00079">79</a> of file <a class="el" href="image_8hpp_source.html">image.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af3656b415fa1872a8da29f82cb98ed6e"></a><!-- doxytag: member="isis::data::Image::set" ref="af3656b415fa1872a8da29f82cb98ed6e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisis_1_1data_1_1__internal_1_1SortedChunkList.html">_internal::SortedChunkList</a> <a class="el" href="classisis_1_1data_1_1Image.html#af3656b415fa1872a8da29f82cb98ed6e">isis::data::Image::set</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="image_8hpp_source.html#l00039">39</a> of file <a class="el" href="image_8hpp_source.html">image.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/scr/thulium1/isis/lib/Core/DataStorage/<a class="el" href="image_8hpp_source.html">image.hpp</a></li>
<li>/scr/thulium1/isis/lib/Core/DataStorage/<a class="el" href="image_8cpp_source.html">image.cpp</a></li>
<li>/scr/thulium1/isis/lib/Core/DataStorage/<a class="el" href="needed_8cpp_source.html">needed.cpp</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Apr 19 2011 16:19:27 for ISIS Core Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
