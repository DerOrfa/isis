<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>ISIS Core Library: isis::data::Image Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceisis.html">isis</a>::<a class="el" href="namespaceisis_1_1data.html">data</a>::<a class="el" href="classisis_1_1data_1_1Image.html">Image</a>
  </div>
</div>
<div class="contents">
<h1>isis::data::Image Class Reference</h1><!-- doxytag: class="isis::data::Image" --><!-- doxytag: inherits="NDimensional&lt; 4 &gt;,isis::util::PropMap" --><code>#include &lt;<a class="el" href="image_8hpp-source.html">image.hpp</a>&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for isis::data::Image:</div>
<div class="dynsection">

<p><center><img src="classisis_1_1data_1_1Image.png" usemap="#isis::data::Image_map" border="0" alt=""></center>
<map name="isis::data::Image_map">
<area href="classisis_1_1data_1_1__internal_1_1NDimensional.html" alt="isis::data::_internal::NDimensional< 4 >" shape="rect" coords="0,0,229,24">
<area href="classisis_1_1util_1_1PropMap.html" alt="isis::util::PropMap" shape="rect" coords="239,0,468,24">
<area href="classisis_1_1data_1_1MemImage.html" alt="isis::data::MemImage< T >" shape="rect" coords="0,112,229,136">
<area href="classisis_1_1data_1_1TypedImage.html" alt="isis::data::TypedImage< T >" shape="rect" coords="239,112,468,136">
</map>
</div>

<p>
<a href="classisis_1_1data_1_1Image-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#c83f7eecffd172b0c0759cb5ee7dd633">orientation</a> { <br>
&nbsp;&nbsp;<a class="el" href="classisis_1_1data_1_1Image.html#c83f7eecffd172b0c0759cb5ee7dd633ee38808f2b23291db3fbb0aebe7ba405">axial</a>, 
<a class="el" href="classisis_1_1data_1_1Image.html#c83f7eecffd172b0c0759cb5ee7dd63364a137c1013ea7f831d25c8701c0693d">reversed_axial</a>, 
<a class="el" href="classisis_1_1data_1_1Image.html#c83f7eecffd172b0c0759cb5ee7dd6330d4cbf4f6526d1d6895c71e6bea6542c">sagittal</a>, 
<a class="el" href="classisis_1_1data_1_1Image.html#c83f7eecffd172b0c0759cb5ee7dd6333adbf32c9b5579e6e97586301f48e047">reversed_sagittal</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="classisis_1_1data_1_1Image.html#c83f7eecffd172b0c0759cb5ee7dd633d77b748bff3861529f19469104a94e6c">coronal</a>, 
<a class="el" href="classisis_1_1data_1_1Image.html#c83f7eecffd172b0c0759cb5ee7dd633f6335ced67866cc519e297f42ee64caa">reversed_coronal</a>
<br>
 }</td></tr>

<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#3d14f900dc0617a26096718aad9568d7">bytes_per_voxel</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">get the size of every voxel (in bytes)  <a href="#3d14f900dc0617a26096718aad9568d7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#cd213fa6d0856d45e6413801f9bdec66">checkMakeClean</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#713bf9b2de4c1c8ca26d79cf665141d6">cmp</a> (const <a class="el" href="classisis_1_1data_1_1Image.html">Image</a> &amp;comp) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compares the voxel-values of this image to the given.  <a href="#713bf9b2de4c1c8ca26d79cf665141d6"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#6828f1a6b951b3e171152287fd4a6184">copyToMem</a> (T *dst) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy all voxel <a class="el" href="namespaceisis_1_1data.html">data</a> of the image into memory.  <a href="#6828f1a6b951b3e171152287fd4a6184"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#b5afb05390412eb68388cb79a6f7f50a">empty</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classisis_1_1data_1_1Chunk.html">Chunk</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#882f5172bca7221c71954efdf6d0f9de">getChunk</a> (size_t first, size_t second=0, size_t third=0, size_t fourth=0, bool copy_metadata=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the chunk that contains the voxel at the given coordinates.  <a href="#882f5172bca7221c71954efdf6d0f9de"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classisis_1_1data_1_1Chunk.html">Chunk</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#fda7218833647cc6526950524775140d">getChunk</a> (size_t first, size_t second=0, size_t third=0, size_t fourth=0, bool copy_metadata=true) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the chunk that contains the voxel at the given coordinates.  <a href="#fda7218833647cc6526950524775140d"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename TYPE&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classisis_1_1data_1_1Chunk.html">Chunk</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#394dc97182639545c2cc34ce6284b95d">getChunkAs</a> (const <a class="el" href="namespaceisis_1_1data.html#652d0963aeb92747bb0f48bee4652afd">scaling_pair</a> &amp;scaling, size_t first, size_t second=0, size_t third=0, size_t fourth=0) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the chunk that contains the voxel at the given coordinates in the given type (fast version).  <a href="#394dc97182639545c2cc34ce6284b95d"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename TYPE&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classisis_1_1data_1_1Chunk.html">Chunk</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#9331c45a182600e3f18c4e14cab73962">getChunkAs</a> (size_t first, size_t second=0, size_t third=0, size_t fourth=0) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the chunk that contains the voxel at the given coordinates in the given type.  <a href="#9331c45a182600e3f18c4e14cab73962"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classisis_1_1data_1_1Chunk.html">Chunk</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#27cfa5f9ced2077e578ad4bcc064e028">getChunkAt</a> (size_t at, bool copy_metadata=true) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a chunk via index (and the lookup table).  <a href="#27cfa5f9ced2077e578ad4bcc064e028"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; boost::shared_ptr<br>
&lt; const <a class="el" href="classisis_1_1data_1_1Chunk.html">Chunk</a> &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#1e64839d1d950e3e96f85fc4f5e84ac4">getChunkList</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; boost::shared_ptr<br>
&lt; <a class="el" href="classisis_1_1data_1_1Chunk.html">Chunk</a> &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#75347e303a9bf31ddb5e97e386342db6">getChunkList</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a sorted list of pointers to the chunks of the image.  <a href="#75347e303a9bf31ddb5e97e386342db6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::list&lt; <a class="el" href="classisis_1_1util_1_1PropertyValue.html">util::PropertyValue</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#af07f078753a69b7b00f287953778ed6">getChunksProperties</a> (const <a class="el" href="classisis_1_1util_1_1PropMap.html#83144c1481dbf7244cdfd4ebc90adfab">util::PropMap::pname_type</a> &amp;key, bool unique=false) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a list of the properties of the chunks for the given key.  <a href="#af07f078753a69b7b00f287953778ed6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classisis_1_1data_1_1Image.html#c83f7eecffd172b0c0759cb5ee7dd633">orientation</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#5d4c287dbd53f05174f3070029e19ce9">getMainOrientation</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#f4d1e1a4d12cf2a21f9e103e09088c6e">getMinMax</a> (<a class="el" href="classisis_1_1util_1_1__internal_1_1TypeReference.html">util::TypeReference</a> &amp;min, <a class="el" href="classisis_1_1util_1_1__internal_1_1TypeReference.html">util::TypeReference</a> &amp;max) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the maximum and the minimum voxel value of the image and store them as Type-object in the given references.  <a href="#f4d1e1a4d12cf2a21f9e103e09088c6e"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#b93169697b9ccf6cb81b2ebd4a6837d0">getMinMax</a> (T &amp;min, T &amp;max) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the maximum and the minimum voxel value of the image.  <a href="#b93169697b9ccf6cb81b2ebd4a6837d0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespaceisis_1_1data.html#652d0963aeb92747bb0f48bee4652afd">scaling_pair</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#789138e66345f3e5a73c65dbf05b2940">getScalingTo</a> (unsigned short typeID, <a class="el" href="namespaceisis_1_1data.html#69354ef53dcb79cbe577ae5fe8764e49">autoscaleOption</a> scaleopt=autoscale) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">for each chunk get the scaling (and offset) which would be used in an conversion to the given type  <a href="#789138e66345f3e5a73c65dbf05b2940"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#0ad493c5fbfed450e4f933097ee81951">Image</a> (const <a class="el" href="classisis_1_1data_1_1Image.html">Image</a> &amp;ref)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor.  <a href="#0ad493c5fbfed450e4f933097ee81951"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#fe4f8006b3f04f60f68b5027ed8bbebc">Image</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an empty <a class="el" href="classisis_1_1data_1_1Image.html">Image</a> object.  <a href="#fe4f8006b3f04f60f68b5027ed8bbebc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#14a33c4d2ba857b38c2188fb8e8abfd9">insertChunk</a> (const <a class="el" href="classisis_1_1data_1_1Chunk.html">Chunk</a> &amp;chunk)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a <a class="el" href="classisis_1_1data_1_1Chunk.html" title="Main class for four-dimensional random-access data blocks.">Chunk</a> into the <a class="el" href="classisis_1_1data_1_1Image.html">Image</a>.  <a href="#14a33c4d2ba857b38c2188fb8e8abfd9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#ea5977c8de15ec5bc9f2e646ee48bca6">makeOfTypeId</a> (unsigned short id)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Ensure, the image has the type with the requested id.  <a href="#ea5977c8de15ec5bc9f2e646ee48bca6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classisis_1_1data_1_1Image.html">Image</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#ae95616fad335432d8ce3b5e5daf004a">operator=</a> (const <a class="el" href="classisis_1_1data_1_1Image.html">Image</a> &amp;ref)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy operator.  <a href="#ae95616fad335432d8ce3b5e5daf004a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#801a02eb15ae94b384aaa97061e2ad1c">reIndex</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">(Re)computes the image layout and metadata.  <a href="#801a02eb15ae94b384aaa97061e2ad1c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#94fda5b511c9bfdff550d9691937aea1">spliceDownTo</a> (<a class="el" href="namespaceisis_1_1data.html#157a8a81ce7fb08f84af9c27b7d251a3">dimensions</a> dim)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Automatically splice the given dimension and all dimensions above.  <a href="#94fda5b511c9bfdff550d9691937aea1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#08a00900007d599e698e56a430e88c19">transformCoords</a> (boost::numeric::ublas::matrix&lt; float &gt; transform)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transforms the image coordinate system into an other system by multiplying the orientation matrix with a user defined transformation matrix.  <a href="#08a00900007d599e698e56a430e88c19"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned short&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#0e1813b7ad96b056317c0282794202ec">typeID</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the type of the chunk with "biggest" type.  <a href="#0e1813b7ad96b056317c0282794202ec"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#22eb142b9e736863f33ffffdf6a2a9f8">typeName</a> () const </td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#da9507a974c95aba6869636e5df4a306">voxel</a> (size_t first, size_t second=0, size_t third=0, size_t fourth=0) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the value of the voxel value at the given coordinates.  <a href="#da9507a974c95aba6869636e5df4a306"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">T &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#31aecea5e2a012d677c59222ebe13198">voxel</a> (size_t first, size_t second=0, size_t third=0, size_t fourth=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method returns a reference to the voxel value at the given coordinates.  <a href="#31aecea5e2a012d677c59222ebe13198"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classisis_1_1data_1_1Chunk.html">Chunk</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#087ed8c4884cea467e47c386c65d5be2">chunkAt</a> (size_t at)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access a chunk via index (and the lookup table) The <a class="el" href="classisis_1_1data_1_1Chunk.html" title="Main class for four-dimensional random-access data blocks.">Chunk</a> will only have metadata which are unique to it - so it might be invalid (run join on it using the image as parameter to insert all non-unique-metadata).  <a href="#087ed8c4884cea467e47c386c65d5be2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#ece4ae886cea93d0e05087c9b3e2c85b">getChunkStride</a> (size_t base_stride=1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Search for a dimensional break in all stored chunks.  <a href="#ece4ae886cea93d0e05087c9b3e2c85b"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; boost::shared_ptr<br>
&lt; <a class="el" href="classisis_1_1data_1_1Chunk.html">Chunk</a> &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#9c80a4fa8768d5df1c8bf67129e2cae9">lookup</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classisis_1_1data_1_1__internal_1_1SortedChunkList.html">_internal::SortedChunkList</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#f3656b415fa1872a8da29f82cb98ed6e">set</a></td></tr>

<tr><td colspan="2"><br><h2>Static Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1Image.html#aa5072c5a9d97873c38822fe1c674387">needed</a></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>

<p>Definition at line <a class="el" href="image_8hpp-source.html#l00031">31</a> of file <a class="el" href="image_8hpp-source.html">image.hpp</a>.</p>
<hr><h2>Member Enumeration Documentation</h2>
<a class="anchor" name="c83f7eecffd172b0c0759cb5ee7dd633"></a><!-- doxytag: member="isis::data::Image::orientation" ref="c83f7eecffd172b0c0759cb5ee7dd633" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classisis_1_1data_1_1Image.html#c83f7eecffd172b0c0759cb5ee7dd633">isis::data::Image::orientation</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="c83f7eecffd172b0c0759cb5ee7dd633ee38808f2b23291db3fbb0aebe7ba405"></a><!-- doxytag: member="axial" ref="c83f7eecffd172b0c0759cb5ee7dd633ee38808f2b23291db3fbb0aebe7ba405" args="" -->axial</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="c83f7eecffd172b0c0759cb5ee7dd63364a137c1013ea7f831d25c8701c0693d"></a><!-- doxytag: member="reversed_axial" ref="c83f7eecffd172b0c0759cb5ee7dd63364a137c1013ea7f831d25c8701c0693d" args="" -->reversed_axial</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="c83f7eecffd172b0c0759cb5ee7dd6330d4cbf4f6526d1d6895c71e6bea6542c"></a><!-- doxytag: member="sagittal" ref="c83f7eecffd172b0c0759cb5ee7dd6330d4cbf4f6526d1d6895c71e6bea6542c" args="" -->sagittal</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="c83f7eecffd172b0c0759cb5ee7dd6333adbf32c9b5579e6e97586301f48e047"></a><!-- doxytag: member="reversed_sagittal" ref="c83f7eecffd172b0c0759cb5ee7dd6333adbf32c9b5579e6e97586301f48e047" args="" -->reversed_sagittal</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="c83f7eecffd172b0c0759cb5ee7dd633d77b748bff3861529f19469104a94e6c"></a><!-- doxytag: member="coronal" ref="c83f7eecffd172b0c0759cb5ee7dd633d77b748bff3861529f19469104a94e6c" args="" -->coronal</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="c83f7eecffd172b0c0759cb5ee7dd633f6335ced67866cc519e297f42ee64caa"></a><!-- doxytag: member="reversed_coronal" ref="c83f7eecffd172b0c0759cb5ee7dd633f6335ced67866cc519e297f42ee64caa" args="" -->reversed_coronal</em>&nbsp;</td><td>
</td></tr>
</table>
</dl>

<p>Definition at line <a class="el" href="image_8hpp-source.html#l00036">36</a> of file <a class="el" href="image_8hpp-source.html">image.hpp</a>.</p>

</div>
</div><p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="fe4f8006b3f04f60f68b5027ed8bbebc"></a><!-- doxytag: member="isis::data::Image::Image" ref="fe4f8006b3f04f60f68b5027ed8bbebc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">isis::data::Image::Image           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates an empty <a class="el" href="classisis_1_1data_1_1Image.html">Image</a> object. 
<p>

<p>Definition at line <a class="el" href="image_8cpp-source.html#l00034">34</a> of file <a class="el" href="image_8cpp-source.html">image.cpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="0ad493c5fbfed450e4f933097ee81951"></a><!-- doxytag: member="isis::data::Image::Image" ref="0ad493c5fbfed450e4f933097ee81951" args="(const Image &amp;ref)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">isis::data::Image::Image           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classisis_1_1data_1_1Image.html">Image</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ref</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy constructor. 
<p>
Copies all elements, only the voxel-data (in the chunks) are referenced. 
<p>Definition at line <a class="el" href="image_8cpp-source.html#l00041">41</a> of file <a class="el" href="image_8cpp-source.html">image.cpp</a>.</p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="3d14f900dc0617a26096718aad9568d7"></a><!-- doxytag: member="isis::data::Image::bytes_per_voxel" ref="3d14f900dc0617a26096718aad9568d7" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t isis::data::Image::bytes_per_voxel           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
get the size of every voxel (in bytes) 
<p>

<p>Definition at line <a class="el" href="image_8cpp-source.html#l00456">456</a> of file <a class="el" href="image_8cpp-source.html">image.cpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="cd213fa6d0856d45e6413801f9bdec66"></a><!-- doxytag: member="isis::data::Image::checkMakeClean" ref="cd213fa6d0856d45e6413801f9bdec66" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isis::data::Image::checkMakeClean           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="image_8cpp-source.html#l00067">67</a> of file <a class="el" href="image_8cpp-source.html">image.cpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="087ed8c4884cea467e47c386c65d5be2"></a><!-- doxytag: member="isis::data::Image::chunkAt" ref="087ed8c4884cea467e47c386c65d5be2" args="(size_t at)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisis_1_1data_1_1Chunk.html">Chunk</a> &amp; isis::data::Image::chunkAt           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>at</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Access a chunk via index (and the lookup table) The <a class="el" href="classisis_1_1data_1_1Chunk.html" title="Main class for four-dimensional random-access data blocks.">Chunk</a> will only have metadata which are unique to it - so it might be invalid (run join on it using the image as parameter to insert all non-unique-metadata). 
<p>

<p>Definition at line <a class="el" href="image_8cpp-source.html#l00346">346</a> of file <a class="el" href="image_8cpp-source.html">image.cpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="713bf9b2de4c1c8ca26d79cf665141d6"></a><!-- doxytag: member="isis::data::Image::cmp" ref="713bf9b2de4c1c8ca26d79cf665141d6" args="(const Image &amp;comp) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t isis::data::Image::cmp           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classisis_1_1data_1_1Image.html">Image</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>comp</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compares the voxel-values of this image to the given. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the amount of the different voxels </dd></dl>

<p>Definition at line <a class="el" href="image_8cpp-source.html#l00552">552</a> of file <a class="el" href="image_8cpp-source.html">image.cpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="6828f1a6b951b3e171152287fd4a6184"></a><!-- doxytag: member="isis::data::Image::copyToMem" ref="6828f1a6b951b3e171152287fd4a6184" args="(T *dst) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void isis::data::Image::copyToMem           </td>
          <td>(</td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>dst</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy all voxel <a class="el" href="namespaceisis_1_1data.html">data</a> of the image into memory. 
<p>
If neccessary a conversion into T is done using min/max of the image. 
<p>Definition at line <a class="el" href="image_8hpp-source.html#l00331">331</a> of file <a class="el" href="image_8hpp-source.html">image.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="b5afb05390412eb68388cb79a6f7f50a"></a><!-- doxytag: member="isis::data::Image::empty" ref="b5afb05390412eb68388cb79a6f7f50a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isis::data::Image::empty           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if there is no chunk in the image </dd></dl>

<p>Reimplemented from <a class="el" href="classisis_1_1util_1_1PropMap.html#fe6bbbbf89d6d12c0b11a3cc035dc118">isis::util::PropMap</a>.</p>

<p>Definition at line <a class="el" href="image_8cpp-source.html#l00324">324</a> of file <a class="el" href="image_8cpp-source.html">image.cpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="882f5172bca7221c71954efdf6d0f9de"></a><!-- doxytag: member="isis::data::Image::getChunk" ref="882f5172bca7221c71954efdf6d0f9de" args="(size_t first, size_t second=0, size_t third=0, size_t fourth=0, bool copy_metadata=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisis_1_1data_1_1Chunk.html">Chunk</a> isis::data::Image::getChunk           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>second</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>third</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>fourth</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>copy_metadata</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the chunk that contains the voxel at the given coordinates. 
<p>
If the image is not clean <a class="el" href="classisis_1_1data_1_1Image.html#801a02eb15ae94b384aaa97061e2ad1c" title="(Re)computes the image layout and metadata.">Image::reIndex()</a> will be run.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>first</em>&nbsp;</td><td>The first coordinate in voxel space. Usually the x value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>second</em>&nbsp;</td><td>The second coordinate in voxel space. Usually the y value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>third</em>&nbsp;</td><td>The third coordinate in voxel space. Ususally the z value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fourth</em>&nbsp;</td><td>The fourth coordinate in voxel space. Usually the time value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>copy_metadata</em>&nbsp;</td><td>if true the metadata of the image are merged into the returned chunk </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a copy of the chunk that contains the voxel at the given coordinates. (Reminder: Chunk-copies are cheap, so the <a class="el" href="namespaceisis_1_1data.html">data</a> are NOT copied) </dd></dl>

<p>Definition at line <a class="el" href="image_8cpp-source.html#l00351">351</a> of file <a class="el" href="image_8cpp-source.html">image.cpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="fda7218833647cc6526950524775140d"></a><!-- doxytag: member="isis::data::Image::getChunk" ref="fda7218833647cc6526950524775140d" args="(size_t first, size_t second=0, size_t third=0, size_t fourth=0, bool copy_metadata=true) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classisis_1_1data_1_1Chunk.html">Chunk</a> isis::data::Image::getChunk           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>second</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>third</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>fourth</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>copy_metadata</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the chunk that contains the voxel at the given coordinates. 
<p>
If the image is not clean, behaviour is undefined. (See Image::commonGet).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>first</em>&nbsp;</td><td>The first coordinate in voxel space. Usually the x value / the read-encoded position. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>second</em>&nbsp;</td><td>The second coordinate in voxel space. Usually the y value / the phase-encoded position. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>third</em>&nbsp;</td><td>The third coordinate in voxel space. Ususally the z value / the slice-encoded position. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fourth</em>&nbsp;</td><td>The fourth coordinate in voxel space. Usually the time value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>copy_metadata</em>&nbsp;</td><td>if true the metadata of the image are merged into the returned chunk </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a copy of the chunk that contains the voxel at the given coordinates. (Reminder: Chunk-copies are cheap, so the <a class="el" href="namespaceisis_1_1data.html">data</a> are NOT copied) </dd></dl>

<p>Definition at line <a class="el" href="image_8cpp-source.html#l00357">357</a> of file <a class="el" href="image_8cpp-source.html">image.cpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="394dc97182639545c2cc34ce6284b95d"></a><!-- doxytag: member="isis::data::Image::getChunkAs" ref="394dc97182639545c2cc34ce6284b95d" args="(const scaling_pair &amp;scaling, size_t first, size_t second=0, size_t third=0, size_t fourth=0) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisis_1_1data_1_1Chunk.html">Chunk</a> isis::data::Image::getChunkAs           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceisis_1_1data.html#652d0963aeb92747bb0f48bee4652afd">scaling_pair</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>scaling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>second</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>third</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>fourth</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the chunk that contains the voxel at the given coordinates in the given type (fast version). 
<p>
If the accordant chunk has type T a cheap copy is returned. Otherwise a <a class="el" href="classisis_1_1data_1_1MemChunk.html" title="Chunk class for memory-based buffers.">MemChunk</a> of the requested type is created from it. In this case the minimum and maximum values of the image are computed and used for the <a class="el" href="classisis_1_1data_1_1MemChunk.html" title="Chunk class for memory-based buffers.">MemChunk</a> constructor.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>first</em>&nbsp;</td><td>The first coordinate in voxel space. Usually the x value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>second</em>&nbsp;</td><td>The second coordinate in voxel space. Usually the y value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>third</em>&nbsp;</td><td>The third coordinate in voxel space. Ususally the z value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fourth</em>&nbsp;</td><td>The fourth coordinate in voxel space. Usually the time value. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a (maybe converted) chunk containing the voxel value at the given coordinates. </dd></dl>
 This version does not compute the scaling, and thus is much faster. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>scaling</em>&nbsp;</td><td>the scaling (scale and offset) to be used if a conversion to the requested type is neccessary. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>first</em>&nbsp;</td><td>The first coordinate in voxel space. Usually the x value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>second</em>&nbsp;</td><td>The second coordinate in voxel space. Usually the y value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>third</em>&nbsp;</td><td>The third coordinate in voxel space. Ususally the z value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fourth</em>&nbsp;</td><td>The fourth coordinate in voxel space. Usually the time value. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a (maybe converted) chunk containing the voxel value at the given coordinates. </dd></dl>

<p>Definition at line <a class="el" href="image_8hpp-source.html#l00250">250</a> of file <a class="el" href="image_8hpp-source.html">image.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="9331c45a182600e3f18c4e14cab73962"></a><!-- doxytag: member="isis::data::Image::getChunkAs" ref="9331c45a182600e3f18c4e14cab73962" args="(size_t first, size_t second=0, size_t third=0, size_t fourth=0) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisis_1_1data_1_1Chunk.html">Chunk</a> isis::data::Image::getChunkAs           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>second</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>third</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>fourth</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the chunk that contains the voxel at the given coordinates in the given type. 
<p>
If the accordant chunk has type T a cheap copy is returned. Otherwise a <a class="el" href="classisis_1_1data_1_1MemChunk.html" title="Chunk class for memory-based buffers.">MemChunk</a> of the requested type is created from it. In this case the minimum and maximum values of the image are computed and used for the <a class="el" href="classisis_1_1data_1_1MemChunk.html" title="Chunk class for memory-based buffers.">MemChunk</a> constructor.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>first</em>&nbsp;</td><td>The first coordinate in voxel space. Usually the x value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>second</em>&nbsp;</td><td>The second coordinate in voxel space. Usually the y value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>third</em>&nbsp;</td><td>The third coordinate in voxel space. Ususally the z value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fourth</em>&nbsp;</td><td>The fourth coordinate in voxel space. Usually the time value. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a (maybe converted) chunk containing the voxel value at the given coordinates. </dd></dl>

<p>Definition at line <a class="el" href="image_8hpp-source.html#l00236">236</a> of file <a class="el" href="image_8hpp-source.html">image.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="27cfa5f9ced2077e578ad4bcc064e028"></a><!-- doxytag: member="isis::data::Image::getChunkAt" ref="27cfa5f9ced2077e578ad4bcc064e028" args="(size_t at, bool copy_metadata=true) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisis_1_1data_1_1Chunk.html">Chunk</a> isis::data::Image::getChunkAt           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>at</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>copy_metadata</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get a chunk via index (and the lookup table). 
<p>
The returned chunk will be a cheap copy of the original chunk. If copy_metadata is true the metadata of the image is copied into the chunk. 
<p>Definition at line <a class="el" href="image_8cpp-source.html#l00338">338</a> of file <a class="el" href="image_8cpp-source.html">image.cpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="1e64839d1d950e3e96f85fc4f5e84ac4"></a><!-- doxytag: member="isis::data::Image::getChunkList" ref="1e64839d1d950e3e96f85fc4f5e84ac4" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; boost::shared_ptr&lt; const <a class="el" href="classisis_1_1data_1_1Chunk.html">Chunk</a> &gt; &gt; isis::data::Image::getChunkList           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get a sorted list of pointers to the chunks of the image. <p>
Note: this chunks only have metadata which are unique to them - so they might be invalid. (run join on copies of them using the image as parameter to insert all non-unique-metadata).  
<p>Definition at line <a class="el" href="image_8cpp-source.html#l00368">368</a> of file <a class="el" href="image_8cpp-source.html">image.cpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="75347e303a9bf31ddb5e97e386342db6"></a><!-- doxytag: member="isis::data::Image::getChunkList" ref="75347e303a9bf31ddb5e97e386342db6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; boost::shared_ptr&lt; <a class="el" href="classisis_1_1data_1_1Chunk.html">Chunk</a> &gt; &gt; isis::data::Image::getChunkList           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get a sorted list of pointers to the chunks of the image. 
<p>
Note: this chunks only have metadata which are unique to them - so they might be invalid. (run join on copies of them using the image as parameter to insert all non-unique-metadata). 
<p>Definition at line <a class="el" href="image_8cpp-source.html#l00362">362</a> of file <a class="el" href="image_8cpp-source.html">image.cpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="af07f078753a69b7b00f287953778ed6"></a><!-- doxytag: member="isis::data::Image::getChunksProperties" ref="af07f078753a69b7b00f287953778ed6" args="(const util::PropMap::pname_type &amp;key, bool unique=false) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt; <a class="el" href="classisis_1_1util_1_1PropertyValue.html">util::PropertyValue</a> &gt; isis::data::Image::getChunksProperties           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classisis_1_1util_1_1PropMap.html#83144c1481dbf7244cdfd4ebc90adfab">util::PropMap::pname_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>unique</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get a list of the properties of the chunks for the given key. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>the name of the property to search for </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>unique</em>&nbsp;</td><td>when true empty or consecutive duplicates wont be added </td></tr>
  </table>
</dl>

<p>Definition at line <a class="el" href="image_8cpp-source.html#l00433">433</a> of file <a class="el" href="image_8cpp-source.html">image.cpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="ece4ae886cea93d0e05087c9b3e2c85b"></a><!-- doxytag: member="isis::data::Image::getChunkStride" ref="ece4ae886cea93d0e05087c9b3e2c85b" args="(size_t base_stride=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t isis::data::Image::getChunkStride           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>base_stride</em> = <code>1</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Search for a dimensional break in all stored chunks. 
<p>
This function searches for two chunks whose (geometrical) distance is more than twice the distance between the first and the second chunk. It wll assume a dimensional break at this position.<p>
Normally chunks are beneath each other (like characters in a text) so their distance is more or less constant. But if there is a dimensional break (analogous to the linebreak in a text) the distance between this particular chunks/characters is bigger than twice the normal distance<p>
For example for an image of 2D-chunks (slices) getChunkStride(1) will get the number of slices (size of third dim) and getChunkStride(slices) will get the number of timesteps <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>base_stride</em>&nbsp;</td><td>the base_stride for the iteration between chunks (1 for the first dimension, one "line" for the second and soon...) </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the length of this chunk-"line" / the stride </dd></dl>

<p>Definition at line <a class="el" href="image_8cpp-source.html#l00375">375</a> of file <a class="el" href="image_8cpp-source.html">image.cpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="5d4c287dbd53f05174f3070029e19ce9"></a><!-- doxytag: member="isis::data::Image::getMainOrientation" ref="5d4c287dbd53f05174f3070029e19ce9" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisis_1_1data_1_1Image.html#c83f7eecffd172b0c0759cb5ee7dd633">Image::orientation</a> isis::data::Image::getMainOrientation           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="image_8cpp-source.html#l00586">586</a> of file <a class="el" href="image_8cpp-source.html">image.cpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="f4d1e1a4d12cf2a21f9e103e09088c6e"></a><!-- doxytag: member="isis::data::Image::getMinMax" ref="f4d1e1a4d12cf2a21f9e103e09088c6e" args="(util::TypeReference &amp;min, util::TypeReference &amp;max) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void isis::data::Image::getMinMax           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classisis_1_1util_1_1__internal_1_1TypeReference.html">util::TypeReference</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classisis_1_1util_1_1__internal_1_1TypeReference.html">util::TypeReference</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>max</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the maximum and the minimum voxel value of the image and store them as Type-object in the given references. 
<p>

<p>Definition at line <a class="el" href="image_8cpp-source.html#l00521">521</a> of file <a class="el" href="image_8cpp-source.html">image.cpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="b93169697b9ccf6cb81b2ebd4a6837d0"></a><!-- doxytag: member="isis::data::Image::getMinMax" ref="b93169697b9ccf6cb81b2ebd4a6837d0" args="(T &amp;min, T &amp;max) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void isis::data::Image::getMinMax           </td>
          <td>(</td>
          <td class="paramtype">T &amp;&nbsp;</td>
          <td class="paramname"> <em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&nbsp;</td>
          <td class="paramname"> <em>max</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the maximum and the minimum voxel value of the image. 
<p>
The results are stored as type T, if they dont fit an error ist send. 
<p>Definition at line <a class="el" href="image_8hpp-source.html#l00293">293</a> of file <a class="el" href="image_8hpp-source.html">image.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="789138e66345f3e5a73c65dbf05b2940"></a><!-- doxytag: member="isis::data::Image::getScalingTo" ref="789138e66345f3e5a73c65dbf05b2940" args="(unsigned short typeID, autoscaleOption scaleopt=autoscale) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceisis_1_1data.html#652d0963aeb92747bb0f48bee4652afd">scaling_pair</a> isis::data::Image::getScalingTo           </td>
          <td>(</td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>typeID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceisis_1_1data.html#69354ef53dcb79cbe577ae5fe8764e49">autoscaleOption</a>&nbsp;</td>
          <td class="paramname"> <em>scaleopt</em> = <code>autoscale</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
for each chunk get the scaling (and offset) which would be used in an conversion to the given type 
<p>

</div>
</div><p>
<a class="anchor" name="14a33c4d2ba857b38c2188fb8e8abfd9"></a><!-- doxytag: member="isis::data::Image::insertChunk" ref="14a33c4d2ba857b38c2188fb8e8abfd9" args="(const Chunk &amp;chunk)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isis::data::Image::insertChunk           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classisis_1_1data_1_1Chunk.html">Chunk</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>chunk</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert a <a class="el" href="classisis_1_1data_1_1Chunk.html" title="Main class for four-dimensional random-access data blocks.">Chunk</a> into the <a class="el" href="classisis_1_1data_1_1Image.html">Image</a>. 
<p>
The insertion is sorted and unique. So the <a class="el" href="classisis_1_1data_1_1Chunk.html" title="Main class for four-dimensional random-access data blocks.">Chunk</a> will be inserted behind a geometrically "lower" <a class="el" href="classisis_1_1data_1_1Chunk.html" title="Main class for four-dimensional random-access data blocks.">Chunk</a> if there is one. If there is allready a <a class="el" href="classisis_1_1data_1_1Chunk.html" title="Main class for four-dimensional random-access data blocks.">Chunk</a> at the proposed position this <a class="el" href="classisis_1_1data_1_1Chunk.html" title="Main class for four-dimensional random-access data blocks.">Chunk</a> wont be inserted.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>chunk</em>&nbsp;</td><td>The <a class="el" href="classisis_1_1data_1_1Chunk.html" title="Main class for four-dimensional random-access data blocks.">Chunk</a> to be inserted </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if the <a class="el" href="classisis_1_1data_1_1Chunk.html" title="Main class for four-dimensional random-access data blocks.">Chunk</a> was inserted, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="image_8cpp-source.html#l00081">81</a> of file <a class="el" href="image_8cpp-source.html">image.cpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="ea5977c8de15ec5bc9f2e646ee48bca6"></a><!-- doxytag: member="isis::data::Image::makeOfTypeId" ref="ea5977c8de15ec5bc9f2e646ee48bca6" args="(unsigned short id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isis::data::Image::makeOfTypeId           </td>
          <td>(</td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>id</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Ensure, the image has the type with the requested id. 
<p>
If the typeId of any chunk is not equal to the requested id, the <a class="el" href="namespaceisis_1_1data.html">data</a> of the chunk is replaced by an converted version. The conversion is done using the value range of the image. <dl class="return" compact><dt><b>Returns:</b></dt><dd>false if there was an error </dd></dl>

</div>
</div><p>
<a class="anchor" name="ae95616fad335432d8ce3b5e5daf004a"></a><!-- doxytag: member="isis::data::Image::operator=" ref="ae95616fad335432d8ce3b5e5daf004a" args="(const Image &amp;ref)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisis_1_1data_1_1Image.html">Image</a> &amp; isis::data::Image::operator=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classisis_1_1data_1_1Image.html">Image</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ref</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy operator. 
<p>
Copies all elements, only the voxel-data (in the chunks) are referenced. 
<p>Reimplemented in <a class="el" href="classisis_1_1data_1_1MemImage.html#734d63e8c8c9d1eec740522451662f7f">isis::data::MemImage&lt; T &gt;</a>, and <a class="el" href="classisis_1_1data_1_1TypedImage.html#16654e67097e9e70a1bcc16b84bdd640">isis::data::TypedImage&lt; T &gt;</a>.</p>

<p>Definition at line <a class="el" href="image_8cpp-source.html#l00046">46</a> of file <a class="el" href="image_8cpp-source.html">image.cpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="801a02eb15ae94b384aaa97061e2ad1c"></a><!-- doxytag: member="isis::data::Image::reIndex" ref="801a02eb15ae94b384aaa97061e2ad1c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isis::data::Image::reIndex           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
(Re)computes the image layout and metadata. 
<p>
The image will be "clean" on success. <dl class="return" compact><dt><b>Returns:</b></dt><dd>true if the image was successfully reindexed and is valid, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="image_8cpp-source.html#l00107">107</a> of file <a class="el" href="image_8cpp-source.html">image.cpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="94fda5b511c9bfdff550d9691937aea1"></a><!-- doxytag: member="isis::data::Image::spliceDownTo" ref="94fda5b511c9bfdff550d9691937aea1" args="(dimensions dim)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t isis::data::Image::spliceDownTo           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceisis_1_1data.html#157a8a81ce7fb08f84af9c27b7d251a3">dimensions</a>&nbsp;</td>
          <td class="paramname"> <em>dim</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Automatically splice the given dimension and all dimensions above. 
<p>
e.g. spliceDownTo(sliceDim) will result in an image made of slices (aka 2d-chunks). 
<p>Definition at line <a class="el" href="image_8cpp-source.html#l00671">671</a> of file <a class="el" href="image_8cpp-source.html">image.cpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="08a00900007d599e698e56a430e88c19"></a><!-- doxytag: member="isis::data::Image::transformCoords" ref="08a00900007d599e698e56a430e88c19" args="(boost::numeric::ublas::matrix&lt; float &gt; transform)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void isis::data::Image::transformCoords           </td>
          <td>(</td>
          <td class="paramtype">boost::numeric::ublas::matrix&lt; float &gt;&nbsp;</td>
          <td class="paramname"> <em>transform</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Transforms the image coordinate system into an other system by multiplying the orientation matrix with a user defined transformation matrix. 
<p>
Additionally, the index origin will be transformed into the new coordinate system. This function only changes the<p>
<b>IMPORTANT!</b>: If you call this function with a matrix other than the identidy matrix, it's not guaranteed that the image is still in ISIS space according to the DICOM conventions. Eventuelly some ISIS algorithms that depend on correct image orientations won't work as expected. Use this method with caution! 
<p>Definition at line <a class="el" href="image_8hpp-source.html#l00323">323</a> of file <a class="el" href="image_8hpp-source.html">image.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="0e1813b7ad96b056317c0282794202ec"></a><!-- doxytag: member="isis::data::Image::typeID" ref="0e1813b7ad96b056317c0282794202ec" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short isis::data::Image::typeID           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the type of the chunk with "biggest" type. 
<p>
Determines the minimum and maximum of the image, (and with that the types of these limits). If they are not the same, the type which can store the other type is selected. E.g. if min is "-5(int8_t)" and max is "1000(int16_t)" "int16_t" is selected. Warning: this will fail if min is "-5(int8_t)" and max is "70000(uint16_t)" <dl class="return" compact><dt><b>Returns:</b></dt><dd>a number which is equal to the <a class="el" href="classisis_1_1data_1_1TypePtr.html#9c0439afbff4e6ff5a3a68d326d8bdef">TypePtr::staticID</a> of the selected type. </dd></dl>

<p>Definition at line <a class="el" href="image_8cpp-source.html#l00633">633</a> of file <a class="el" href="image_8cpp-source.html">image.cpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="22eb142b9e736863f33ffffdf6a2a9f8"></a><!-- doxytag: member="isis::data::Image::typeName" ref="22eb142b9e736863f33ffffdf6a2a9f8" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string isis::data::Image::typeName           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the typename correspondig to the result of typeID </dd></dl>

<p>Definition at line <a class="el" href="image_8cpp-source.html#l00653">653</a> of file <a class="el" href="image_8cpp-source.html">image.cpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="da9507a974c95aba6869636e5df4a306"></a><!-- doxytag: member="isis::data::Image::voxel" ref="da9507a974c95aba6869636e5df4a306" args="(size_t first, size_t second=0, size_t third=0, size_t fourth=0) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T isis::data::Image::voxel           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>second</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>third</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>fourth</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the value of the voxel value at the given coordinates. 
<p>
The voxel reference provides reading and writing access to the refered value.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>first</em>&nbsp;</td><td>The first coordinate in voxel space. Usually the x value / the read-encoded position.. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>second</em>&nbsp;</td><td>The second coordinate in voxel space. Usually the y value / the phase-encoded position. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>third</em>&nbsp;</td><td>The third coordinate in voxel space. Ususally the z value / the time-encoded position. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fourth</em>&nbsp;</td><td>The fourth coordinate in voxel space. Usually the time value.</td></tr>
  </table>
</dl>
If the requested voxel is not of type T, an error will be raised.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A reference to the addressed voxel value. Only reading access is provided </dd></dl>

<p>Definition at line <a class="el" href="image_8hpp-source.html#l00160">160</a> of file <a class="el" href="image_8hpp-source.html">image.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="31aecea5e2a012d677c59222ebe13198"></a><!-- doxytag: member="isis::data::Image::voxel" ref="31aecea5e2a012d677c59222ebe13198" args="(size_t first, size_t second=0, size_t third=0, size_t fourth=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; isis::data::Image::voxel           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>second</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>third</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>fourth</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method returns a reference to the voxel value at the given coordinates. 
<p>
The voxel reference provides reading and writing access to the refered value.<p>
If the image is not clean, reIndex will be run. If the requested voxel is not of type T, an error will be raised.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>first</em>&nbsp;</td><td>The first coordinate in voxel space. Usually the x value / the read-encoded position.. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>second</em>&nbsp;</td><td>The second coordinate in voxel space. Usually the y value / the phase-encoded position. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>third</em>&nbsp;</td><td>The third coordinate in voxel space. Ususally the z value / the time-encoded position. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fourth</em>&nbsp;</td><td>The fourth coordinate in voxel space. Usually the time value.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A reference to the addressed voxel value. Reading and writing access is provided. </dd></dl>

<p>Definition at line <a class="el" href="image_8hpp-source.html#l00138">138</a> of file <a class="el" href="image_8hpp-source.html">image.hpp</a>.</p>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="9c80a4fa8768d5df1c8bf67129e2cae9"></a><!-- doxytag: member="isis::data::Image::lookup" ref="9c80a4fa8768d5df1c8bf67129e2cae9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;boost::shared_ptr&lt;<a class="el" href="classisis_1_1data_1_1Chunk.html">Chunk</a>&gt; &gt; <a class="el" href="classisis_1_1data_1_1Image.html#9c80a4fa8768d5df1c8bf67129e2cae9">isis::data::Image::lookup</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="image_8hpp-source.html#l00040">40</a> of file <a class="el" href="image_8hpp-source.html">image.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="aa5072c5a9d97873c38822fe1c674387"></a><!-- doxytag: member="isis::data::Image::needed" ref="aa5072c5a9d97873c38822fe1c674387" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * <a class="el" href="classisis_1_1data_1_1Image.html#aa5072c5a9d97873c38822fe1c674387">isis::data::Image::needed</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Initial value:</b><div class="fragment"><pre class="fragment"> <span class="stringliteral">"\</span>
<span class="stringliteral">    voxelSize\</span>
<span class="stringliteral">    readVec\</span>
<span class="stringliteral">    phaseVec\</span>
<span class="stringliteral">    sliceVec\</span>
<span class="stringliteral">"</span>
</pre></div>
<p>Definition at line <a class="el" href="image_8hpp-source.html#l00077">77</a> of file <a class="el" href="image_8hpp-source.html">image.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="f3656b415fa1872a8da29f82cb98ed6e"></a><!-- doxytag: member="isis::data::Image::set" ref="f3656b415fa1872a8da29f82cb98ed6e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisis_1_1data_1_1__internal_1_1SortedChunkList.html">_internal::SortedChunkList</a> <a class="el" href="classisis_1_1data_1_1Image.html#f3656b415fa1872a8da29f82cb98ed6e">isis::data::Image::set</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="image_8hpp-source.html#l00039">39</a> of file <a class="el" href="image_8hpp-source.html">image.hpp</a>.</p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>/SCR/isis/lib/Core/DataStorage/<a class="el" href="image_8hpp-source.html">image.hpp</a><li>/SCR/isis/lib/Core/DataStorage/<a class="el" href="image_8cpp-source.html">image.cpp</a><li>/SCR/isis/lib/Core/DataStorage/<a class="el" href="needed_8cpp-source.html">needed.cpp</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Tue Dec 14 17:52:44 2010 for ISIS Core Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
