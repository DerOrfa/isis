<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ISIS Core Library: isis::data::ValuePtr&lt; TYPE &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">ISIS Core Library&#160;<span id="projectnumber">(r115-gcf9c9cc)</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceisis.html">isis</a>      </li>
      <li class="navelem"><a class="el" href="namespaceisis_1_1data.html">data</a>      </li>
      <li class="navelem"><a class="el" href="classisis_1_1data_1_1ValuePtr.html">ValuePtr</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a>  </div>
  <div class="headertitle">
<h1>isis::data::ValuePtr&lt; TYPE &gt; Class Template Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="isis::data::ValuePtr" --><!-- doxytag: inherits="isis::data::_internal::ValuePtrBase" -->
<p>Generic class for type (and length) - aware pointers.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="typeptr_8hpp_source.html">typeptr.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for isis::data::ValuePtr&lt; TYPE &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classisis_1_1data_1_1ValuePtr.png" usemap="#isis::data::ValuePtr&lt; TYPE &gt;_map" alt=""/>
  <map id="isis::data::ValuePtr&lt; TYPE &gt;_map" name="isis::data::ValuePtr&lt; TYPE &gt;_map">
<area href="classisis_1_1data_1_1__internal_1_1ValuePtrBase.html" alt="isis::data::_internal::ValuePtrBase" shape="rect" coords="0,56,198,80"/>
<area href="classisis_1_1util_1_1__internal_1_1GenericValue.html" alt="isis::util::_internal::GenericValue" shape="rect" coords="0,0,198,24"/>
</map>
 </div></div>

<p><a href="classisis_1_1data_1_1ValuePtr-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structisis_1_1data_1_1ValuePtr_1_1BasicDeleter.html">BasicDeleter</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Default delete-functor for c-arrays (uses free()).  <a href="structisis_1_1data_1_1ValuePtr_1_1BasicDeleter.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structisis_1_1data_1_1ValuePtr_1_1NonDeleter.html">NonDeleter</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">delete-functor which does nothing (in case someone else manages the data).  <a href="structisis_1_1data_1_1ValuePtr_1_1NonDeleter.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structisis_1_1data_1_1ValuePtr_1_1ObjectArrayDeleter.html">ObjectArrayDeleter</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Default delete-functor for arrays of objects (uses delete[]).  <a href="structisis_1_1data_1_1ValuePtr_1_1ObjectArrayDeleter.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1ValuePtr.html#ab8384c8cbb5f61685beb00d5f68ff7a3">bytesPerElem</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::pair<br class="typebreak"/>
&lt; <a class="el" href="classisis_1_1util_1_1__internal_1_1ValueReference.html">util::ValueReference</a>, <br class="typebreak"/>
<a class="el" href="classisis_1_1util_1_1__internal_1_1ValueReference.html">util::ValueReference</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1ValuePtr.html#a59da53e38a246552ad516e505ac962f6">getMinMax</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get minimum/maximum of a <a class="el" href="classisis_1_1data_1_1ValuePtr.html" title="Generic class for type (and length) - aware pointers.">ValuePtr</a>.  <a href="#a59da53e38a246552ad516e505ac962f6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boost::shared_ptr&lt; const void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1ValuePtr.html#a6aa758bbc3ba9e6e89ac7d76889554ec">getRawAddress</a> (size_t offset=0) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the raw address the <a class="el" href="classisis_1_1data_1_1ValuePtr.html" title="Generic class for type (and length) - aware pointers.">ValuePtr</a> points to.  <a href="#a6aa758bbc3ba9e6e89ac7d76889554ec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boost::shared_ptr&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1ValuePtr.html#afdca3295c4f82d4618a25b952b0a0dfc">getRawAddress</a> (size_t offset=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceisis_1_1data.html#ac2873e5e7a9637d4ac68253dcf140ff4">scaling_pair</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1ValuePtr.html#a32341e568dd00966bca4512a1dcb64c1">getScalingTo</a> (unsigned short typeID, <a class="el" href="namespaceisis_1_1data.html#a69354ef53dcb79cbe577ae5fe8764e49">autoscaleOption</a> scaleopt=autoscale) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">get the scaling (and offset) which would be used in an conversion  <a href="#a32341e568dd00966bca4512a1dcb64c1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1ValuePtr.html#af313a270b76ec4c27356aba1daa74c57">getTypeID</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1ValuePtr.html#a46dbff9f3e2c7a4faef86f31965339e7">getTypeName</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1ValuePtr.html#a5bd59ad4040cf15fbdb20beaf1fe4ada">isFloat</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1ValuePtr.html#a103c0d4ea893cfde7b52d280c1f20f55">isInteger</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1ValuePtr.html#a8a307eca934ade3dfccbc7e41fb01208">operator boost::shared_ptr&lt; TYPE &gt; &amp;</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implicit conversion to boost::shared_ptr&lt;TYPE&gt; The returned smart pointer will be part of the reference-counting and will correctly delete the data (using the given deleter) if required.  <a href="#a8a307eca934ade3dfccbc7e41fb01208"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1ValuePtr.html#a869d6aa942d986d201d6d4255401845b">operator const boost::shared_ptr&lt; TYPE &gt; &amp;</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const TYPE &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1ValuePtr.html#a8e4c8ddd427bb142ef5d88e636f7932e">operator[]</a> (size_t idx) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TYPE &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1ValuePtr.html#a042d66ffcc5985b998096722446c3bb7">operator[]</a> (size_t idx)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference element at at given index.  <a href="#a042d66ffcc5985b998096722446c3bb7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classisis_1_1util_1_1__internal_1_1ValueReference.html">Reference</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1ValuePtr.html#a9f8ecd913db39413ce3fee2dc1d7c002">splice</a> (size_t size) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Splice up the <a class="el" href="classisis_1_1data_1_1ValuePtr.html" title="Generic class for type (and length) - aware pointers.">ValuePtr</a> into equal sized blocks.  <a href="#a9f8ecd913db39413ce3fee2dc1d7c002"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1ValuePtr.html#ac13d1b521078490e35dd8201af1899be">toString</a> (bool labeled=false) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1ValuePtr.html#ab82a777f8994d6daecf569db872b6c83">ValuePtr</a> (TYPE *const ptr, size_t length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates <a class="el" href="classisis_1_1data_1_1ValuePtr.html" title="Generic class for type (and length) - aware pointers.">ValuePtr</a> from a pointer of type TYPE.  <a href="#ab82a777f8994d6daecf569db872b6c83"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename D &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1ValuePtr.html#a6136626a335c6998c5ee5fd3cce57496">ValuePtr</a> (TYPE *const ptr, size_t length, D d)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates <a class="el" href="classisis_1_1data_1_1ValuePtr.html" title="Generic class for type (and length) - aware pointers.">ValuePtr</a> from a pointer of type TYPE.  <a href="#a6136626a335c6998c5ee5fd3cce57496"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1ValuePtr.html#ac0be806ada68648eacb2fe03fb5982ac">ValuePtr</a> (const boost::shared_ptr&lt; TYPE &gt; &amp;ptr, size_t length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates <a class="el" href="classisis_1_1data_1_1ValuePtr.html" title="Generic class for type (and length) - aware pointers.">ValuePtr</a> from a boost:shared_ptr of the same type.  <a href="#ac0be806ada68648eacb2fe03fb5982ac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1ValuePtr.html#ab9a93ea4e4f3495185f14a2a6b62fcd9">ValuePtr</a> (size_t length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classisis_1_1data_1_1ValuePtr.html" title="Generic class for type (and length) - aware pointers.">ValuePtr</a> pointing to a newly allocated array of elements of the given type.  <a href="#ab9a93ea4e4f3495185f14a2a6b62fcd9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1ValuePtr.html#a09d9be41ed5d473805eede680fcd2452">~ValuePtr</a> ()</td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1ValuePtr.html#abdbdd90b9df012ab31b24d8bf0b129ed">staticName</a> ()</td></tr>
<tr><td colspan="2"><h2><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1ValuePtr.html#afaf56a4a73ada017a6eefbdb03cb82a2">staticID</a> = util::_internal::TypeID&lt;TYPE&gt;::value &lt;&lt; 8</td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ValuePtrBase *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1ValuePtr.html#a2d302e9026427e86c3128184f5ce3a0e">clone</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classisis_1_1data_1_1ValuePtr.html" title="Generic class for type (and length) - aware pointers.">ValuePtr</a> of the same type pointing at the same address.  <a href="#a2d302e9026427e86c3128184f5ce3a0e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1ValuePtr.html#a2afd1139ab3b8e91e882fbe61ec6c5fb">ValuePtr</a> ()</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename TYPE&gt;<br/>
 class isis::data::ValuePtr&lt; TYPE &gt;</h3>

<p>Generic class for type (and length) - aware pointers. </p>
<p>The class is designed for arrays, but you can also "point" to an single element by just use "1" for the length. The pointers are reference counted and will be deleted automatically by a customizable deleter. The copy is cheap, thus the copy of a <a class="el" href="classisis_1_1data_1_1ValuePtr.html" title="Generic class for type (and length) - aware pointers.">ValuePtr</a> will reference the same data. The usual pointer dereferencing interface ("*", "-&gt;" and "[]") is supported. </p>

<p>Definition at line <a class="el" href="typeptr_8hpp_source.html#l00087">87</a> of file <a class="el" href="typeptr_8hpp_source.html">typeptr.hpp</a>.</p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a2afd1139ab3b8e91e882fbe61ec6c5fb"></a><!-- doxytag: member="isis::data::ValuePtr::ValuePtr" ref="a2afd1139ab3b8e91e882fbe61ec6c5fb" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisis_1_1data_1_1ValuePtr.html">isis::data::ValuePtr</a>&lt; TYPE &gt;::<a class="el" href="classisis_1_1data_1_1ValuePtr.html">ValuePtr</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="typeptr_8hpp_source.html#l00091">91</a> of file <a class="el" href="typeptr_8hpp_source.html">typeptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab9a93ea4e4f3495185f14a2a6b62fcd9"></a><!-- doxytag: member="isis::data::ValuePtr::ValuePtr" ref="ab9a93ea4e4f3495185f14a2a6b62fcd9" args="(size_t length)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisis_1_1data_1_1ValuePtr.html">isis::data::ValuePtr</a>&lt; TYPE &gt;::<a class="el" href="classisis_1_1data_1_1ValuePtr.html">ValuePtr</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a <a class="el" href="classisis_1_1data_1_1ValuePtr.html" title="Generic class for type (and length) - aware pointers.">ValuePtr</a> pointing to a newly allocated array of elements of the given type. </p>
<p>The array is zero-initialized. If the requested length is 0 no memory will be allocated and the pointer be "empty". </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>amount of elements in the new array </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="typeptr_8hpp_source.html#l00126">126</a> of file <a class="el" href="typeptr_8hpp_source.html">typeptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac0be806ada68648eacb2fe03fb5982ac"></a><!-- doxytag: member="isis::data::ValuePtr::ValuePtr" ref="ac0be806ada68648eacb2fe03fb5982ac" args="(const boost::shared_ptr&lt; TYPE &gt; &amp;ptr, size_t length)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisis_1_1data_1_1ValuePtr.html">isis::data::ValuePtr</a>&lt; TYPE &gt;::<a class="el" href="classisis_1_1data_1_1ValuePtr.html">ValuePtr</a> </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; TYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates <a class="el" href="classisis_1_1data_1_1ValuePtr.html" title="Generic class for type (and length) - aware pointers.">ValuePtr</a> from a boost:shared_ptr of the same type. </p>
<p>It will inherit the deleter of the shared_ptr. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>the shared_ptr to share the data with </td></tr>
    <tr><td class="paramname">length</td><td>the length of the used array (<a class="el" href="classisis_1_1data_1_1ValuePtr.html" title="Generic class for type (and length) - aware pointers.">ValuePtr</a> does NOT check for length, this is just here for child classes which may want to check) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="typeptr_8hpp_source.html#l00142">142</a> of file <a class="el" href="typeptr_8hpp_source.html">typeptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab82a777f8994d6daecf569db872b6c83"></a><!-- doxytag: member="isis::data::ValuePtr::ValuePtr" ref="ab82a777f8994d6daecf569db872b6c83" args="(TYPE *const ptr, size_t length)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisis_1_1data_1_1ValuePtr.html">isis::data::ValuePtr</a>&lt; TYPE &gt;::<a class="el" href="classisis_1_1data_1_1ValuePtr.html">ValuePtr</a> </td>
          <td>(</td>
          <td class="paramtype">TYPE *const&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates <a class="el" href="classisis_1_1data_1_1ValuePtr.html" title="Generic class for type (and length) - aware pointers.">ValuePtr</a> from a pointer of type TYPE. </p>
<p>The pointers are automatically deleted by an instance of <a class="el" href="structisis_1_1data_1_1ValuePtr_1_1BasicDeleter.html" title="Default delete-functor for c-arrays (uses free()).">BasicDeleter</a> and should not be used outside once used here. If ptr is a pointer to C++ objects (delete[] needed) you must use <a class="el" href="classisis_1_1data_1_1ValuePtr.html" title="Generic class for type (and length) - aware pointers.">ValuePtr</a>(ptr,len,<a class="el" href="classisis_1_1data_1_1ValuePtr.html" title="Generic class for type (and length) - aware pointers.">ValuePtr</a>&lt;TYPE&gt;::ObjectArrayDeleter())! </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>the pointer to the used array </td></tr>
    <tr><td class="paramname">length</td><td>the length of the used array (<a class="el" href="classisis_1_1data_1_1ValuePtr.html" title="Generic class for type (and length) - aware pointers.">ValuePtr</a> does NOT check for length, this is just here for child classes which may want to check) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="typeptr_8hpp_source.html#l00153">153</a> of file <a class="el" href="typeptr_8hpp_source.html">typeptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6136626a335c6998c5ee5fd3cce57496"></a><!-- doxytag: member="isis::data::ValuePtr::ValuePtr" ref="a6136626a335c6998c5ee5fd3cce57496" args="(TYPE *const ptr, size_t length, D d)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE&gt; </div>
<div class="memtemplate">
template&lt;typename D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisis_1_1data_1_1ValuePtr.html">isis::data::ValuePtr</a>&lt; TYPE &gt;::<a class="el" href="classisis_1_1data_1_1ValuePtr.html">ValuePtr</a> </td>
          <td>(</td>
          <td class="paramtype">TYPE *const&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">D&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates <a class="el" href="classisis_1_1data_1_1ValuePtr.html" title="Generic class for type (and length) - aware pointers.">ValuePtr</a> from a pointer of type TYPE. </p>
<p>The pointers are automatically deleted by an copy of d and should not be used outside once used here (this does not apply, if d does not delete). D must implement operator()(TYPE *p). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>the pointer to the used array </td></tr>
    <tr><td class="paramname">length</td><td>the length of the used array in elements (<a class="el" href="classisis_1_1data_1_1ValuePtr.html" title="Generic class for type (and length) - aware pointers.">ValuePtr</a> does NOT check for length), </td></tr>
    <tr><td class="paramname">d</td><td>the deleter to be used when the data shall be deleted ( d() is called then ) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="typeptr_8hpp_source.html#l00165">165</a> of file <a class="el" href="typeptr_8hpp_source.html">typeptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a09d9be41ed5d473805eede680fcd2452"></a><!-- doxytag: member="isis::data::ValuePtr::~ValuePtr" ref="a09d9be41ed5d473805eede680fcd2452" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classisis_1_1data_1_1ValuePtr.html">isis::data::ValuePtr</a>&lt; TYPE &gt;::~<a class="el" href="classisis_1_1data_1_1ValuePtr.html">ValuePtr</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="typeptr_8hpp_source.html#l00167">167</a> of file <a class="el" href="typeptr_8hpp_source.html">typeptr.hpp</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ab8384c8cbb5f61685beb00d5f68ff7a3"></a><!-- doxytag: member="isis::data::ValuePtr::bytesPerElem" ref="ab8384c8cbb5f61685beb00d5f68ff7a3" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classisis_1_1data_1_1ValuePtr.html">isis::data::ValuePtr</a>&lt; TYPE &gt;::bytesPerElem </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the byte-size of the type of the data this <a class="el" href="classisis_1_1data_1_1ValuePtr.html" title="Generic class for type (and length) - aware pointers.">ValuePtr</a> points to. </dd></dl>

<p>Implements <a class="el" href="classisis_1_1data_1_1__internal_1_1ValuePtrBase.html#af2699cc78c91ebc74e724dfeaff6407b">isis::data::_internal::ValuePtrBase</a>.</p>

<p>Definition at line <a class="el" href="typeptr_8hpp_source.html#l00227">227</a> of file <a class="el" href="typeptr_8hpp_source.html">typeptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2d302e9026427e86c3128184f5ce3a0e"></a><!-- doxytag: member="isis::data::ValuePtr::clone" ref="a2d302e9026427e86c3128184f5ce3a0e" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ValuePtrBase* <a class="el" href="classisis_1_1data_1_1ValuePtr.html">isis::data::ValuePtr</a>&lt; TYPE &gt;::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a <a class="el" href="classisis_1_1data_1_1ValuePtr.html" title="Generic class for type (and length) - aware pointers.">ValuePtr</a> of the same type pointing at the same address. </p>

<p>Implements <a class="el" href="classisis_1_1data_1_1__internal_1_1ValuePtrBase.html#a67a01586958fb8c49d361ba7bbf546b8">isis::data::_internal::ValuePtrBase</a>.</p>

<p>Definition at line <a class="el" href="typeptr_8hpp_source.html#l00092">92</a> of file <a class="el" href="typeptr_8hpp_source.html">typeptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a59da53e38a246552ad516e505ac962f6"></a><!-- doxytag: member="isis::data::ValuePtr::getMinMax" ref="a59da53e38a246552ad516e505ac962f6" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classisis_1_1util_1_1__internal_1_1ValueReference.html">util::ValueReference</a>, <a class="el" href="classisis_1_1util_1_1__internal_1_1ValueReference.html">util::ValueReference</a>&gt; <a class="el" href="classisis_1_1data_1_1ValuePtr.html">isis::data::ValuePtr</a>&lt; TYPE &gt;::getMinMax </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get minimum/maximum of a <a class="el" href="classisis_1_1data_1_1ValuePtr.html" title="Generic class for type (and length) - aware pointers.">ValuePtr</a>. </p>
<p>This computes the minimum and maximum value of the stored data and stores them in ValueReference-Objects. The computes min/max are of the same type as the stored data, but can be compared to other ValueReference without knowing this type via the lt/gt function of ValueBase. The following code checks if the value range of ValuePtr-object data1 is a real subset of data2: </p>
<div class="fragment"><pre class="fragment"> std::pair&lt;util::ValueReference,util::ValueReference&gt; minmax1=data1.getMinMax(), minmax2=data2.getMinMax();
 <span class="keywordflow">if</span>(minmax1.first-&gt;gt(minmax2.second) &amp;&amp; minmax1.second-&gt;lt(minmax2.second)
  std::cout &lt;&lt; minmax1 &lt;&lt; <span class="stringliteral">&quot; is a subset of &quot;</span> minmax2 &lt;&lt; std::endl;
</pre></div> <dl class="return"><dt><b>Returns:</b></dt><dd>a pair of ValueReferences referring to the found minimum/maximum of the data </dd></dl>

<p>Implements <a class="el" href="classisis_1_1data_1_1__internal_1_1ValuePtrBase.html#a4fd1648eeedd918b1c22fd166bfa4b4a">isis::data::_internal::ValuePtrBase</a>.</p>

<p>Definition at line <a class="el" href="typeptr_8hpp_source.html#l00229">229</a> of file <a class="el" href="typeptr_8hpp_source.html">typeptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6aa758bbc3ba9e6e89ac7d76889554ec"></a><!-- doxytag: member="isis::data::ValuePtr::getRawAddress" ref="a6aa758bbc3ba9e6e89ac7d76889554ec" args="(size_t offset=0) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt;const void&gt; <a class="el" href="classisis_1_1data_1_1ValuePtr.html">isis::data::ValuePtr</a>&lt; TYPE &gt;::getRawAddress </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the raw address the <a class="el" href="classisis_1_1data_1_1ValuePtr.html" title="Generic class for type (and length) - aware pointers.">ValuePtr</a> points to. </p>
<p>An offset can be added to the result. If it is not zero, the resulting shared_ptr will use DelProxy as deleter. Thus, it will increase the reference count of the original pointer by one and decrease it when the deletion of the offset pointer is triggered. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>ammount of bytes to displace the resulting pointer from the actual pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a shared_ptr with the memory address of the data handled by this <a class="el" href="classisis_1_1data_1_1ValuePtr.html" title="Generic class for type (and length) - aware pointers.">ValuePtr</a>. </dd></dl>

<p>Implements <a class="el" href="classisis_1_1data_1_1__internal_1_1ValuePtrBase.html#a2e7dc25df6fc915321f78118fad1b596">isis::data::_internal::ValuePtrBase</a>.</p>

<p>Definition at line <a class="el" href="typeptr_8hpp_source.html#l00169">169</a> of file <a class="el" href="typeptr_8hpp_source.html">typeptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afdca3295c4f82d4618a25b952b0a0dfc"></a><!-- doxytag: member="isis::data::ValuePtr::getRawAddress" ref="afdca3295c4f82d4618a25b952b0a0dfc" args="(size_t offset=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt;void&gt; <a class="el" href="classisis_1_1data_1_1ValuePtr.html">isis::data::ValuePtr</a>&lt; TYPE &gt;::getRawAddress </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the raw address the <a class="el" href="classisis_1_1data_1_1ValuePtr.html" title="Generic class for type (and length) - aware pointers.">ValuePtr</a> points to. </p>
<p>An offset can be added to the result. If it is not zero, the resulting shared_ptr will use DelProxy as deleter. Thus, it will increase the reference count of the original pointer by one and decrease it when the deletion of the offset pointer is triggered. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>ammount of bytes to displace the resulting pointer from the actual pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a shared_ptr with the memory address of the data handled by this <a class="el" href="classisis_1_1data_1_1ValuePtr.html" title="Generic class for type (and length) - aware pointers.">ValuePtr</a>. </dd></dl>
 
<p>Implements <a class="el" href="classisis_1_1data_1_1__internal_1_1ValuePtrBase.html#aee280aac05a3e26d320894bc6948815e">isis::data::_internal::ValuePtrBase</a>.</p>

<p>Definition at line <a class="el" href="typeptr_8hpp_source.html#l00177">177</a> of file <a class="el" href="typeptr_8hpp_source.html">typeptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a32341e568dd00966bca4512a1dcb64c1"></a><!-- doxytag: member="isis::data::ValuePtr::getScalingTo" ref="a32341e568dd00966bca4512a1dcb64c1" args="(unsigned short typeID, autoscaleOption scaleopt=autoscale) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceisis_1_1data.html#ac2873e5e7a9637d4ac68253dcf140ff4">scaling_pair</a> <a class="el" href="classisis_1_1data_1_1ValuePtr.html">isis::data::ValuePtr</a>&lt; TYPE &gt;::getScalingTo </td>
          <td>(</td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>typeID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceisis_1_1data.html#a69354ef53dcb79cbe577ae5fe8764e49">autoscaleOption</a>&#160;</td>
          <td class="paramname"><em>scaleopt</em> = <code>autoscale</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>get the scaling (and offset) which would be used in an conversion </p>

<p>Implements <a class="el" href="classisis_1_1data_1_1__internal_1_1ValuePtrBase.html#a73785845e502284467ea8684ca5ef4a5">isis::data::_internal::ValuePtrBase</a>.</p>

<p>Definition at line <a class="el" href="typeptr_8hpp_source.html#l00266">266</a> of file <a class="el" href="typeptr_8hpp_source.html">typeptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af313a270b76ec4c27356aba1daa74c57"></a><!-- doxytag: member="isis::data::ValuePtr::getTypeID" ref="af313a270b76ec4c27356aba1daa74c57" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned short <a class="el" href="classisis_1_1data_1_1ValuePtr.html">isis::data::ValuePtr</a>&lt; TYPE &gt;::getTypeID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the ID of its actual type </dd></dl>

<p>Implements <a class="el" href="classisis_1_1util_1_1__internal_1_1GenericValue.html#acd463f6f7eb6eb9a5b899daec570ad41">isis::util::_internal::GenericValue</a>.</p>

<p>Definition at line <a class="el" href="typeptr_8hpp_source.html#l00198">198</a> of file <a class="el" href="typeptr_8hpp_source.html">typeptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a46dbff9f3e2c7a4faef86f31965339e7"></a><!-- doxytag: member="isis::data::ValuePtr::getTypeName" ref="a46dbff9f3e2c7a4faef86f31965339e7" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classisis_1_1data_1_1ValuePtr.html">isis::data::ValuePtr</a>&lt; TYPE &gt;::getTypeName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the name of its actual type </dd></dl>

<p>Implements <a class="el" href="classisis_1_1util_1_1__internal_1_1GenericValue.html#ad6c1f5b417b6a58d028b1c4cef85ac7e">isis::util::_internal::GenericValue</a>.</p>

<p>Definition at line <a class="el" href="typeptr_8hpp_source.html#l00197">197</a> of file <a class="el" href="typeptr_8hpp_source.html">typeptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5bd59ad4040cf15fbdb20beaf1fe4ada"></a><!-- doxytag: member="isis::data::ValuePtr::isFloat" ref="a5bd59ad4040cf15fbdb20beaf1fe4ada" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classisis_1_1data_1_1ValuePtr.html">isis::data::ValuePtr</a>&lt; TYPE &gt;::isFloat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the type is a floating point scalar </dd></dl>

<p>Implements <a class="el" href="classisis_1_1util_1_1__internal_1_1GenericValue.html#aa929b28db7f737a5329d023b1857afec">isis::util::_internal::GenericValue</a>.</p>

<p>Definition at line <a class="el" href="typeptr_8hpp_source.html#l00199">199</a> of file <a class="el" href="typeptr_8hpp_source.html">typeptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a103c0d4ea893cfde7b52d280c1f20f55"></a><!-- doxytag: member="isis::data::ValuePtr::isInteger" ref="a103c0d4ea893cfde7b52d280c1f20f55" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classisis_1_1data_1_1ValuePtr.html">isis::data::ValuePtr</a>&lt; TYPE &gt;::isInteger </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the type is a integral scalar </dd></dl>

<p>Implements <a class="el" href="classisis_1_1util_1_1__internal_1_1GenericValue.html#ae9a0682484b9213f564a3cb117f94dfc">isis::util::_internal::GenericValue</a>.</p>

<p>Definition at line <a class="el" href="typeptr_8hpp_source.html#l00200">200</a> of file <a class="el" href="typeptr_8hpp_source.html">typeptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8a307eca934ade3dfccbc7e41fb01208"></a><!-- doxytag: member="isis::data::ValuePtr::operator boost::shared_ptr&lt; TYPE &gt; &amp;" ref="a8a307eca934ade3dfccbc7e41fb01208" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisis_1_1data_1_1ValuePtr.html">isis::data::ValuePtr</a>&lt; TYPE &gt;::operator boost::shared_ptr&lt; TYPE &gt; &amp; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implicit conversion to boost::shared_ptr&lt;TYPE&gt; The returned smart pointer will be part of the reference-counting and will correctly delete the data (using the given deleter) if required. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>boost::shared_ptr&lt;TYPE&gt; handling same data as the object. </dd></dl>

<p>Definition at line <a class="el" href="typeptr_8hpp_source.html#l00224">224</a> of file <a class="el" href="typeptr_8hpp_source.html">typeptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a869d6aa942d986d201d6d4255401845b"></a><!-- doxytag: member="isis::data::ValuePtr::operator const boost::shared_ptr&lt; TYPE &gt; &amp;" ref="a869d6aa942d986d201d6d4255401845b" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisis_1_1data_1_1ValuePtr.html">isis::data::ValuePtr</a>&lt; TYPE &gt;::operator const boost::shared_ptr&lt; TYPE &gt; &amp; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="typeptr_8hpp_source.html#l00225">225</a> of file <a class="el" href="typeptr_8hpp_source.html">typeptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8e4c8ddd427bb142ef5d88e636f7932e"></a><!-- doxytag: member="isis::data::ValuePtr::operator[]" ref="a8e4c8ddd427bb142ef5d88e636f7932e" args="(size_t idx) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const TYPE&amp; <a class="el" href="classisis_1_1data_1_1ValuePtr.html">isis::data::ValuePtr</a>&lt; TYPE &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="typeptr_8hpp_source.html#l00215">215</a> of file <a class="el" href="typeptr_8hpp_source.html">typeptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a042d66ffcc5985b998096722446c3bb7"></a><!-- doxytag: member="isis::data::ValuePtr::operator[]" ref="a042d66ffcc5985b998096722446c3bb7" args="(size_t idx)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TYPE&amp; <a class="el" href="classisis_1_1data_1_1ValuePtr.html">isis::data::ValuePtr</a>&lt; TYPE &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reference element at at given index. </p>
<p>If index is invalid, behaviour is undefined. Probably it will crash. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>reference to element at at given index. </dd></dl>

<p>Definition at line <a class="el" href="typeptr_8hpp_source.html#l00212">212</a> of file <a class="el" href="typeptr_8hpp_source.html">typeptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9f8ecd913db39413ce3fee2dc1d7c002"></a><!-- doxytag: member="isis::data::ValuePtr::splice" ref="a9f8ecd913db39413ce3fee2dc1d7c002" args="(size_t size) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classisis_1_1util_1_1__internal_1_1ValueReference.html">Reference</a>&gt; <a class="el" href="classisis_1_1data_1_1ValuePtr.html">isis::data::ValuePtr</a>&lt; TYPE &gt;::splice </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Splice up the <a class="el" href="classisis_1_1data_1_1ValuePtr.html" title="Generic class for type (and length) - aware pointers.">ValuePtr</a> into equal sized blocks. </p>
<p>This virtually creates new data blocks of the given size by computing new pointers into the block and creating <a class="el" href="classisis_1_1data_1_1ValuePtr.html" title="Generic class for type (and length) - aware pointers.">ValuePtr</a> objects for them. This <a class="el" href="classisis_1_1data_1_1ValuePtr.html" title="Generic class for type (and length) - aware pointers.">ValuePtr</a> objects use the reference counting of the original <a class="el" href="classisis_1_1data_1_1ValuePtr.html" title="Generic class for type (and length) - aware pointers.">ValuePtr</a> via DelProxy, so the original data are only deleted (as a whole) when all spliced and all "normal" <a class="el" href="classisis_1_1data_1_1ValuePtr.html" title="Generic class for type (and length) - aware pointers.">ValuePtr</a> for this data are deleted. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>the maximum size of the spliced parts of the data (the last part can be smaller) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a vector of references to ValuePtr's which point to the parts of the spliced data </dd></dl>

<p>Implements <a class="el" href="classisis_1_1data_1_1__internal_1_1ValuePtrBase.html#a8d776ecb43227d021c880e616e2a9f26">isis::data::_internal::ValuePtrBase</a>.</p>

<p>Definition at line <a class="el" href="typeptr_8hpp_source.html#l00241">241</a> of file <a class="el" href="typeptr_8hpp_source.html">typeptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abdbdd90b9df012ab31b24d8bf0b129ed"></a><!-- doxytag: member="isis::data::ValuePtr::staticName" ref="abdbdd90b9df012ab31b24d8bf0b129ed" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static std::string <a class="el" href="classisis_1_1data_1_1ValuePtr.html">isis::data::ValuePtr</a>&lt; TYPE &gt;::staticName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the name of the type </dd></dl>
 
<p>Definition at line <a class="el" href="typeptr_8hpp_source.html#l00203">203</a> of file <a class="el" href="typeptr_8hpp_source.html">typeptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac13d1b521078490e35dd8201af1899be"></a><!-- doxytag: member="isis::data::ValuePtr::toString" ref="ac13d1b521078490e35dd8201af1899be" args="(bool labeled=false) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string <a class="el" href="classisis_1_1data_1_1ValuePtr.html">isis::data::ValuePtr</a>&lt; TYPE &gt;::toString </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>labeled</em> = <code>false</code></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the string representation of the <a class="el" href="classisis_1_1util_1_1Value.html" title="Generic class for type aware variables.">Value</a>. </p>
<p>This tries to use the isis type conversion to create a string from the <a class="el" href="classisis_1_1util_1_1Value.html" title="Generic class for type aware variables.">Value</a>. If thats no available, it will fall back to boost::lexical_cast. And it will send a warning to CoreDebug. If the lexical cast fails as well, boost::bad_lexical_cast is thrown. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">labeled</td><td>if true the typename will be appended to the resulting string in brackets. </td></tr>
  </table>
  </dd>
</dl>
 
<p>Implements <a class="el" href="classisis_1_1util_1_1__internal_1_1GenericValue.html#a54e2a61ebef7a0b7c07cd6e579c5f64a">isis::util::_internal::GenericValue</a>.</p>

<p>Definition at line <a class="el" href="typeptr_8hpp_source.html#l00182">182</a> of file <a class="el" href="typeptr_8hpp_source.html">typeptr.hpp</a>.</p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="afaf56a4a73ada017a6eefbdb03cb82a2"></a><!-- doxytag: member="isis::data::ValuePtr::staticID" ref="afaf56a4a73ada017a6eefbdb03cb82a2" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const unsigned short <a class="el" href="classisis_1_1data_1_1ValuePtr.html">isis::data::ValuePtr</a>&lt; TYPE &gt;::<a class="el" href="classisis_1_1data_1_1ValuePtr.html#afaf56a4a73ada017a6eefbdb03cb82a2">staticID</a> = util::_internal::TypeID&lt;TYPE&gt;::value &lt;&lt; 8<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="typeptr_8hpp_source.html#l00096">96</a> of file <a class="el" href="typeptr_8hpp_source.html">typeptr.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/SCR/isis/lib/Core/DataStorage/<a class="el" href="typeptr_8hpp_source.html">typeptr.hpp</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Oct 7 2011 18:02:30 for ISIS Core Library by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
