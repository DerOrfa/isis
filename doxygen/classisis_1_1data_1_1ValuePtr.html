<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ISIS Core Library: isis::data::ValuePtr&lt; TYPE &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespaceisis.html">isis</a>      </li>
      <li><a class="el" href="namespaceisis_1_1data.html">data</a>      </li>
      <li><a class="el" href="classisis_1_1data_1_1ValuePtr.html">isis::data::ValuePtr&lt; TYPE &gt;</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a>  </div>
  <div class="headertitle">
<h1>isis::data::ValuePtr&lt; TYPE &gt; Class Template Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="isis::data::ValuePtr" --><!-- doxytag: inherits="isis::data::_internal::ValuePtrBase" -->
<p>Generic class for type (and length) - aware pointers.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="typeptr_8hpp_source.html">typeptr.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for isis::data::ValuePtr&lt; TYPE &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classisis_1_1data_1_1ValuePtr.png" usemap="#isis::data::ValuePtr&lt; TYPE &gt;_map" alt=""/>
  <map id="isis::data::ValuePtr&lt; TYPE &gt;_map" name="isis::data::ValuePtr&lt; TYPE &gt;_map">
<area href="classisis_1_1data_1_1__internal_1_1ValuePtrBase.html" alt="isis::data::_internal::ValuePtrBase" shape="rect" coords="0,56,198,80"/>
<area href="classisis_1_1util_1_1__internal_1_1GenericValue.html" alt="isis::util::_internal::GenericValue" shape="rect" coords="0,0,198,24"/>
</map>
</div>

<p><a href="classisis_1_1data_1_1ValuePtr-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structisis_1_1data_1_1ValuePtr_1_1BasicDeleter.html">BasicDeleter</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default delete-functor for c-arrays (uses free()).  <a href="structisis_1_1data_1_1ValuePtr_1_1BasicDeleter.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1ValuePtr_1_1DelProxy.html">DelProxy</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Proxy-Deleter to encapsulate the real deleter/shared_ptr when creating shared_ptr for parts of a shared_ptr.  <a href="classisis_1_1data_1_1ValuePtr_1_1DelProxy.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structisis_1_1data_1_1ValuePtr_1_1NonDeleter.html">NonDeleter</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">delete-functor which does nothing (in case someone else manages the data).  <a href="structisis_1_1data_1_1ValuePtr_1_1NonDeleter.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structisis_1_1data_1_1ValuePtr_1_1ObjectArrayDeleter.html">ObjectArrayDeleter</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default delete-functor for arrays of objects (uses delete[]).  <a href="structisis_1_1data_1_1ValuePtr_1_1ObjectArrayDeleter.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1ValuePtr.html#ab8384c8cbb5f61685beb00d5f68ff7a3">bytesPerElem</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ValuePtrBase::Reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1ValuePtr.html#a530aa042cf91fae43d4dd87f1a12ce8d">cloneToNew</a> (size_t _length) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new <a class="el" href="classisis_1_1data_1_1ValuePtr.html" title="Generic class for type (and length) - aware pointers.">ValuePtr</a>, of the same type, but differnent size in memory.  <a href="#a530aa042cf91fae43d4dd87f1a12ce8d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1ValuePtr.html#a717331f6485f5987da2c566c1a68bcc4">compare</a> (size_t start, size_t end, const <a class="el" href="classisis_1_1data_1_1__internal_1_1ValuePtrBase.html">_internal::ValuePtrBase</a> &amp;dst, size_t dst_start) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compare the data of two <a class="el" href="classisis_1_1data_1_1ValuePtr.html" title="Generic class for type (and length) - aware pointers.">ValuePtr</a>.  <a href="#a717331f6485f5987da2c566c1a68bcc4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1ValuePtr.html#a36ca205694f29c3d1db60d290b0b8a3c">copyFromMem</a> (const TYPE *const src, size_t _length)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy elements from raw memory.  <a href="#a36ca205694f29c3d1db60d290b0b8a3c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1ValuePtr.html#aadedc36bf52db7aac9f0253bddd632a6">copyToMem</a> (size_t start, size_t end, TYPE *const dst) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy elements within a range [start,end] to raw memory.  <a href="#aadedc36bf52db7aac9f0253bddd632a6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::pair<br class="typebreak"/>
&lt; <a class="el" href="classisis_1_1util_1_1__internal_1_1ValueReference.html">util::ValueReference</a>, <br class="typebreak"/>
<a class="el" href="classisis_1_1util_1_1__internal_1_1ValueReference.html">util::ValueReference</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1ValuePtr.html#a59da53e38a246552ad516e505ac962f6">getMinMax</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get minimum/maximum of a <a class="el" href="classisis_1_1data_1_1ValuePtr.html" title="Generic class for type (and length) - aware pointers.">ValuePtr</a>.  <a href="#a59da53e38a246552ad516e505ac962f6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const boost::weak_ptr&lt; void &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1ValuePtr.html#a524f76b5e9cd57aea97a079593a3d110">getRawAddress</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the raw address the <a class="el" href="classisis_1_1data_1_1ValuePtr.html" title="Generic class for type (and length) - aware pointers.">ValuePtr</a> points to.  <a href="#a524f76b5e9cd57aea97a079593a3d110"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual unsigned short&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1ValuePtr.html#a1f1a3aac1d30803e9d0ba672cc406c44">getTypeID</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1ValuePtr.html#adb0c1b11ecb6e7c3dbaf65aca24484fd">getTypeName</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1ValuePtr.html#a8a307eca934ade3dfccbc7e41fb01208">operator boost::shared_ptr&lt; TYPE &gt; &amp;</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implicit conversion to boost::shared_ptr&lt;TYPE&gt; The returned smart pointer will be part of the reference-counting and will correctly delete the data (using the given deleter) if required.  <a href="#a8a307eca934ade3dfccbc7e41fb01208"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1ValuePtr.html#a869d6aa942d986d201d6d4255401845b">operator const boost::shared_ptr&lt; TYPE &gt; &amp;</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const TYPE &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1ValuePtr.html#a8e4c8ddd427bb142ef5d88e636f7932e">operator[]</a> (size_t idx) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TYPE &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1ValuePtr.html#a042d66ffcc5985b998096722446c3bb7">operator[]</a> (size_t idx)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reference element at at given index.  <a href="#a042d66ffcc5985b998096722446c3bb7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classisis_1_1util_1_1__internal_1_1ValueReference.html">Reference</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1ValuePtr.html#a9f8ecd913db39413ce3fee2dc1d7c002">splice</a> (size_t size) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Splice up the <a class="el" href="classisis_1_1data_1_1ValuePtr.html" title="Generic class for type (and length) - aware pointers.">ValuePtr</a> into equal sized blocks.  <a href="#a9f8ecd913db39413ce3fee2dc1d7c002"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1ValuePtr.html#ac13d1b521078490e35dd8201af1899be">toString</a> (bool labeled=false) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1ValuePtr.html#ab82a777f8994d6daecf569db872b6c83">ValuePtr</a> (TYPE *const ptr, size_t length)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates <a class="el" href="classisis_1_1data_1_1ValuePtr.html" title="Generic class for type (and length) - aware pointers.">ValuePtr</a> from a pointer of type TYPE.  <a href="#ab82a777f8994d6daecf569db872b6c83"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename D &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1ValuePtr.html#a6136626a335c6998c5ee5fd3cce57496">ValuePtr</a> (TYPE *const ptr, size_t length, D d)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates <a class="el" href="classisis_1_1data_1_1ValuePtr.html" title="Generic class for type (and length) - aware pointers.">ValuePtr</a> from a pointer of type TYPE.  <a href="#a6136626a335c6998c5ee5fd3cce57496"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1ValuePtr.html#a2afd1139ab3b8e91e882fbe61ec6c5fb">ValuePtr</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Contructor for empty pointer.  <a href="#a2afd1139ab3b8e91e882fbe61ec6c5fb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1ValuePtr.html#a09d9be41ed5d473805eede680fcd2452">~ValuePtr</a> ()</td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classisis_1_1data_1_1ValuePtr.html">ValuePtr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1ValuePtr.html#a83dba2fdd968fabb2672dd04c30ece78">allocate</a> (size_t len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new <a class="el" href="classisis_1_1data_1_1ValuePtr.html" title="Generic class for type (and length) - aware pointers.">ValuePtr</a> which uses newly allocated memory.  <a href="#a83dba2fdd968fabb2672dd04c30ece78"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1ValuePtr.html#abdbdd90b9df012ab31b24d8bf0b129ed">staticName</a> ()</td></tr>
<tr><td colspan="2"><h2><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const unsigned short&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1ValuePtr.html#afaf56a4a73ada017a6eefbdb03cb82a2">staticID</a> = util::_internal::TypeID&lt;TYPE&gt;::value &lt;&lt; 8</td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ValuePtrBase *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1ValuePtr.html#a2d302e9026427e86c3128184f5ce3a0e">clone</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a <a class="el" href="classisis_1_1data_1_1ValuePtr.html" title="Generic class for type (and length) - aware pointers.">ValuePtr</a> of the same type pointing at the same address.  <a href="#a2d302e9026427e86c3128184f5ce3a0e"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename TYPE&gt;<br/>
 class isis::data::ValuePtr&lt; TYPE &gt;</h3>

<p>Generic class for type (and length) - aware pointers. </p>
<p>The class is designed for arrays, but you can also "point" to an single element by just use "1" for the length. The pointers are reference counted and will be deleted automatically by a customizable deleter. The copy is cheap, thus the copy of a <a class="el" href="classisis_1_1data_1_1ValuePtr.html" title="Generic class for type (and length) - aware pointers.">ValuePtr</a> will reference the same data. The usual dereferencing pointer interface ("*" and "-&gt;") is supported. </p>

<p>Definition at line <a class="el" href="typeptr_8hpp_source.html#l00065">65</a> of file <a class="el" href="typeptr_8hpp_source.html">typeptr.hpp</a>.</p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a2afd1139ab3b8e91e882fbe61ec6c5fb"></a><!-- doxytag: member="isis::data::ValuePtr::ValuePtr" ref="a2afd1139ab3b8e91e882fbe61ec6c5fb" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisis_1_1data_1_1ValuePtr.html">isis::data::ValuePtr</a>&lt; TYPE &gt;::<a class="el" href="classisis_1_1data_1_1ValuePtr.html">ValuePtr</a> </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Contructor for empty pointer. </p>
<p>length will be 0 and every attempt to dereference it will raise an exception. </p>

<p>Definition at line <a class="el" href="typeptr_8hpp_source.html#l00122">122</a> of file <a class="el" href="typeptr_8hpp_source.html">typeptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab82a777f8994d6daecf569db872b6c83"></a><!-- doxytag: member="isis::data::ValuePtr::ValuePtr" ref="ab82a777f8994d6daecf569db872b6c83" args="(TYPE *const ptr, size_t length)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisis_1_1data_1_1ValuePtr.html">isis::data::ValuePtr</a>&lt; TYPE &gt;::<a class="el" href="classisis_1_1data_1_1ValuePtr.html">ValuePtr</a> </td>
          <td>(</td>
          <td class="paramtype">TYPE *const &nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates <a class="el" href="classisis_1_1data_1_1ValuePtr.html" title="Generic class for type (and length) - aware pointers.">ValuePtr</a> from a pointer of type TYPE. </p>
<p>The pointers are automatically deleted by an instance of <a class="el" href="structisis_1_1data_1_1ValuePtr_1_1BasicDeleter.html" title="Default delete-functor for c-arrays (uses free()).">BasicDeleter</a> and should not be used outside once used here. If ptr is a pointer to C++ objects (delete[] needed) you must use <a class="el" href="classisis_1_1data_1_1ValuePtr.html" title="Generic class for type (and length) - aware pointers.">ValuePtr</a>(ptr,len,<a class="el" href="classisis_1_1data_1_1ValuePtr.html" title="Generic class for type (and length) - aware pointers.">ValuePtr</a>&lt;TYPE&gt;ObjectArrayDeleter())! </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>the pointer to the used array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>the length of the used array (<a class="el" href="classisis_1_1data_1_1ValuePtr.html" title="Generic class for type (and length) - aware pointers.">ValuePtr</a> does NOT check for length, this is just here for child classes which may want to check) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="typeptr_8hpp_source.html#l00135">135</a> of file <a class="el" href="typeptr_8hpp_source.html">typeptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6136626a335c6998c5ee5fd3cce57496"></a><!-- doxytag: member="isis::data::ValuePtr::ValuePtr" ref="a6136626a335c6998c5ee5fd3cce57496" args="(TYPE *const ptr, size_t length, D d)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE&gt; </div>
<div class="memtemplate">
template&lt;typename D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisis_1_1data_1_1ValuePtr.html">isis::data::ValuePtr</a>&lt; TYPE &gt;::<a class="el" href="classisis_1_1data_1_1ValuePtr.html">ValuePtr</a> </td>
          <td>(</td>
          <td class="paramtype">TYPE *const &nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">D&nbsp;</td>
          <td class="paramname"> <em>d</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates <a class="el" href="classisis_1_1data_1_1ValuePtr.html" title="Generic class for type (and length) - aware pointers.">ValuePtr</a> from a pointer of type TYPE. </p>
<p>The pointers are automatically deleted by an copy of d and should not be used outside once used here (this does not apply, if d does not delete). D must implement operator()(TYPE *p). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>the pointer to the used array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>the length of the used array in elements (<a class="el" href="classisis_1_1data_1_1ValuePtr.html" title="Generic class for type (and length) - aware pointers.">ValuePtr</a> does NOT check for length), </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>d</em>&nbsp;</td><td>the deleter to be used when the data shall be deleted ( d() is called then ) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="typeptr_8hpp_source.html#l00148">148</a> of file <a class="el" href="typeptr_8hpp_source.html">typeptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a09d9be41ed5d473805eede680fcd2452"></a><!-- doxytag: member="isis::data::ValuePtr::~ValuePtr" ref="a09d9be41ed5d473805eede680fcd2452" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classisis_1_1data_1_1ValuePtr.html">isis::data::ValuePtr</a>&lt; TYPE &gt;::~<a class="el" href="classisis_1_1data_1_1ValuePtr.html">ValuePtr</a> </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="typeptr_8hpp_source.html#l00151">151</a> of file <a class="el" href="typeptr_8hpp_source.html">typeptr.hpp</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a83dba2fdd968fabb2672dd04c30ece78"></a><!-- doxytag: member="isis::data::ValuePtr::allocate" ref="a83dba2fdd968fabb2672dd04c30ece78" args="(size_t len)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classisis_1_1data_1_1ValuePtr.html">ValuePtr</a> <a class="el" href="classisis_1_1data_1_1ValuePtr.html">isis::data::ValuePtr</a>&lt; TYPE &gt;::allocate </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="classisis_1_1data_1_1ValuePtr.html" title="Generic class for type (and length) - aware pointers.">ValuePtr</a> which uses newly allocated memory. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>requested size of the memory block in elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a <a class="el" href="classisis_1_1data_1_1ValuePtr.html" title="Generic class for type (and length) - aware pointers.">ValuePtr</a>&lt;TYPE&gt; of given len </dd></dl>

<p>Definition at line <a class="el" href="typeptr_8hpp_source.html#l00158">158</a> of file <a class="el" href="typeptr_8hpp_source.html">typeptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab8384c8cbb5f61685beb00d5f68ff7a3"></a><!-- doxytag: member="isis::data::ValuePtr::bytesPerElem" ref="ab8384c8cbb5f61685beb00d5f68ff7a3" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classisis_1_1data_1_1ValuePtr.html">isis::data::ValuePtr</a>&lt; TYPE &gt;::bytesPerElem </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the byte-size of the type of the data this <a class="el" href="classisis_1_1data_1_1ValuePtr.html" title="Generic class for type (and length) - aware pointers.">ValuePtr</a> points to. </dd></dl>

<p>Implements <a class="el" href="classisis_1_1data_1_1__internal_1_1ValuePtrBase.html#af2699cc78c91ebc74e724dfeaff6407b">isis::data::_internal::ValuePtrBase</a>.</p>

<p>Definition at line <a class="el" href="typeptr_8hpp_source.html#l00268">268</a> of file <a class="el" href="typeptr_8hpp_source.html">typeptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2d302e9026427e86c3128184f5ce3a0e"></a><!-- doxytag: member="isis::data::ValuePtr::clone" ref="a2d302e9026427e86c3128184f5ce3a0e" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ValuePtrBase* <a class="el" href="classisis_1_1data_1_1ValuePtr.html">isis::data::ValuePtr</a>&lt; TYPE &gt;::clone </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a <a class="el" href="classisis_1_1data_1_1ValuePtr.html" title="Generic class for type (and length) - aware pointers.">ValuePtr</a> of the same type pointing at the same address. </p>

<p>Implements <a class="el" href="classisis_1_1data_1_1__internal_1_1ValuePtrBase.html#a67a01586958fb8c49d361ba7bbf546b8">isis::data::_internal::ValuePtrBase</a>.</p>

<p>Definition at line <a class="el" href="typeptr_8hpp_source.html#l00070">70</a> of file <a class="el" href="typeptr_8hpp_source.html">typeptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a530aa042cf91fae43d4dd87f1a12ce8d"></a><!-- doxytag: member="isis::data::ValuePtr::cloneToNew" ref="a530aa042cf91fae43d4dd87f1a12ce8d" args="(size_t _length) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ValuePtrBase::Reference <a class="el" href="classisis_1_1data_1_1ValuePtr.html">isis::data::ValuePtr</a>&lt; TYPE &gt;::cloneToNew </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>length</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="classisis_1_1data_1_1ValuePtr.html" title="Generic class for type (and length) - aware pointers.">ValuePtr</a>, of the same type, but differnent size in memory. </p>
<p>(The actual data are _not_ copied) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>length of the new memory block in elements of the given TYPE </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classisis_1_1data_1_1__internal_1_1ValuePtrBase.html#a00fee5233f99063255d30dd0958f8086">isis::data::_internal::ValuePtrBase</a>.</p>

<p>Definition at line <a class="el" href="typeptr_8hpp_source.html#l00264">264</a> of file <a class="el" href="typeptr_8hpp_source.html">typeptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a717331f6485f5987da2c566c1a68bcc4"></a><!-- doxytag: member="isis::data::ValuePtr::compare" ref="a717331f6485f5987da2c566c1a68bcc4" args="(size_t start, size_t end, const _internal::ValuePtrBase &amp;dst, size_t dst_start) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classisis_1_1data_1_1ValuePtr.html">isis::data::ValuePtr</a>&lt; TYPE &gt;::compare </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classisis_1_1data_1_1__internal_1_1ValuePtrBase.html">_internal::ValuePtrBase</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>dst_start</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compare the data of two <a class="el" href="classisis_1_1data_1_1ValuePtr.html" title="Generic class for type (and length) - aware pointers.">ValuePtr</a>. </p>
<p>Counts how many elements in this and the given <a class="el" href="classisis_1_1data_1_1ValuePtr.html" title="Generic class for type (and length) - aware pointers.">ValuePtr</a> are different within the given range. If the type of this is not equal to the type of the given <a class="el" href="classisis_1_1data_1_1ValuePtr.html" title="Generic class for type (and length) - aware pointers.">ValuePtr</a> the whole length is assumed to be different. If the given range does not fit into this or the given <a class="el" href="classisis_1_1data_1_1ValuePtr.html" title="Generic class for type (and length) - aware pointers.">ValuePtr</a> an error is send to the runtime log and the function will probably crash. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>the first element in this, which schould be compared to the first element in the given TyprPtr </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>the first element in this, which schould _not_ be compared anymore to the given TyprPtr </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>the given <a class="el" href="classisis_1_1data_1_1ValuePtr.html" title="Generic class for type (and length) - aware pointers.">ValuePtr</a> this should be compared to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dst_start</em>&nbsp;</td><td>the first element in the given TyprPtr, which schould be compared to the first element in this </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the amount of elements which actually differ in both <a class="el" href="classisis_1_1data_1_1ValuePtr.html" title="Generic class for type (and length) - aware pointers.">ValuePtr</a> or the whole length of the range when the types are not equal. </dd></dl>

<p>Implements <a class="el" href="classisis_1_1data_1_1__internal_1_1ValuePtrBase.html#a8b57958656efea29df269bf69b80905b">isis::data::_internal::ValuePtrBase</a>.</p>

<p>Definition at line <a class="el" href="typeptr_8hpp_source.html#l00188">188</a> of file <a class="el" href="typeptr_8hpp_source.html">typeptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a36ca205694f29c3d1db60d290b0b8a3c"></a><!-- doxytag: member="isis::data::ValuePtr::copyFromMem" ref="a36ca205694f29c3d1db60d290b0b8a3c" args="(const TYPE *const src, size_t _length)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classisis_1_1data_1_1ValuePtr.html">isis::data::ValuePtr</a>&lt; TYPE &gt;::copyFromMem </td>
          <td>(</td>
          <td class="paramtype">const TYPE *const &nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>_length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy elements from raw memory. </p>

<p>Definition at line <a class="el" href="typeptr_8hpp_source.html#l00171">171</a> of file <a class="el" href="typeptr_8hpp_source.html">typeptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aadedc36bf52db7aac9f0253bddd632a6"></a><!-- doxytag: member="isis::data::ValuePtr::copyToMem" ref="aadedc36bf52db7aac9f0253bddd632a6" args="(size_t start, size_t end, TYPE *const dst) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classisis_1_1data_1_1ValuePtr.html">isis::data::ValuePtr</a>&lt; TYPE &gt;::copyToMem </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TYPE *const &nbsp;</td>
          <td class="paramname"> <em>dst</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy elements within a range [start,end] to raw memory. </p>

<p>Definition at line <a class="el" href="typeptr_8hpp_source.html#l00179">179</a> of file <a class="el" href="typeptr_8hpp_source.html">typeptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a59da53e38a246552ad516e505ac962f6"></a><!-- doxytag: member="isis::data::ValuePtr::getMinMax" ref="a59da53e38a246552ad516e505ac962f6" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classisis_1_1util_1_1__internal_1_1ValueReference.html">util::ValueReference</a>, <a class="el" href="classisis_1_1util_1_1__internal_1_1ValueReference.html">util::ValueReference</a>&gt; <a class="el" href="classisis_1_1data_1_1ValuePtr.html">isis::data::ValuePtr</a>&lt; TYPE &gt;::getMinMax </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get minimum/maximum of a <a class="el" href="classisis_1_1data_1_1ValuePtr.html" title="Generic class for type (and length) - aware pointers.">ValuePtr</a>. </p>
<p>This computes the minimum and maximum value of the stored data and stores them in ValueReference-Objects. The computes min/max are of the same type as the stored data, but can be compared to other ValueReference without knowing this type via the lt/gt function of ValueBase. The following code checks if the value range of ValuePtr-object data1 is a real subset of data2: </p>
<div class="fragment"><pre class="fragment"> std::pair&lt;util::ValueReference,util::ValueReference&gt; minmax1=data1.getMinMax(), minmax2=data2.getMinMax();
 <span class="keywordflow">if</span>(minmax1.first-&gt;gt(minmax2.second) &amp;&amp; minmax1.second-&gt;lt(minmax2.second)
  std::cout &lt;&lt; minmax1 &lt;&lt; <span class="stringliteral">&quot; is a subset of &quot;</span> minmax2 &lt;&lt; std::endl;
</pre></div> <dl class="return"><dt><b>Returns:</b></dt><dd>a pair of ValueReferences referring to the found minimum/maximum of the data </dd></dl>

<p>Implements <a class="el" href="classisis_1_1data_1_1__internal_1_1ValuePtrBase.html#a4fd1648eeedd918b1c22fd166bfa4b4a">isis::data::_internal::ValuePtrBase</a>.</p>

<p>Definition at line <a class="el" href="typeptr_8hpp_source.html#l00272">272</a> of file <a class="el" href="typeptr_8hpp_source.html">typeptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a524f76b5e9cd57aea97a079593a3d110"></a><!-- doxytag: member="isis::data::ValuePtr::getRawAddress" ref="a524f76b5e9cd57aea97a079593a3d110" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const boost::weak_ptr&lt;void&gt; <a class="el" href="classisis_1_1data_1_1ValuePtr.html">isis::data::ValuePtr</a>&lt; TYPE &gt;::getRawAddress </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the raw address the <a class="el" href="classisis_1_1data_1_1ValuePtr.html" title="Generic class for type (and length) - aware pointers.">ValuePtr</a> points to. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a weak_ptr&lt;void&gt; with the memory address of the data handled by this <a class="el" href="classisis_1_1data_1_1ValuePtr.html" title="Generic class for type (and length) - aware pointers.">ValuePtr</a>. </dd></dl>

<p>Implements <a class="el" href="classisis_1_1data_1_1__internal_1_1ValuePtrBase.html#a452fc2f4326092ab474dade5315b92cf">isis::data::_internal::ValuePtrBase</a>.</p>

<p>Definition at line <a class="el" href="typeptr_8hpp_source.html#l00166">166</a> of file <a class="el" href="typeptr_8hpp_source.html">typeptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1f1a3aac1d30803e9d0ba672cc406c44"></a><!-- doxytag: member="isis::data::ValuePtr::getTypeID" ref="a1f1a3aac1d30803e9d0ba672cc406c44" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned short <a class="el" href="classisis_1_1data_1_1ValuePtr.html">isis::data::ValuePtr</a>&lt; TYPE &gt;::getTypeID </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the ID of its actual type </dd></dl>
 
<p>Implements <a class="el" href="classisis_1_1util_1_1__internal_1_1GenericValue.html#acd463f6f7eb6eb9a5b899daec570ad41">isis::util::_internal::GenericValue</a>.</p>

<p>Definition at line <a class="el" href="typeptr_8hpp_source.html#l00236">236</a> of file <a class="el" href="typeptr_8hpp_source.html">typeptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adb0c1b11ecb6e7c3dbaf65aca24484fd"></a><!-- doxytag: member="isis::data::ValuePtr::getTypeName" ref="adb0c1b11ecb6e7c3dbaf65aca24484fd" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string <a class="el" href="classisis_1_1data_1_1ValuePtr.html">isis::data::ValuePtr</a>&lt; TYPE &gt;::getTypeName </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the name of its actual type </dd></dl>
 
<p>Implements <a class="el" href="classisis_1_1util_1_1__internal_1_1GenericValue.html#ad6c1f5b417b6a58d028b1c4cef85ac7e">isis::util::_internal::GenericValue</a>.</p>

<p>Definition at line <a class="el" href="typeptr_8hpp_source.html#l00232">232</a> of file <a class="el" href="typeptr_8hpp_source.html">typeptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8a307eca934ade3dfccbc7e41fb01208"></a><!-- doxytag: member="isis::data::ValuePtr::operator boost::shared_ptr&lt; TYPE &gt; &amp;" ref="a8a307eca934ade3dfccbc7e41fb01208" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisis_1_1data_1_1ValuePtr.html">isis::data::ValuePtr</a>&lt; TYPE &gt;::operator boost::shared_ptr&lt; TYPE &gt; &amp; </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implicit conversion to boost::shared_ptr&lt;TYPE&gt; The returned smart pointer will be part of the reference-counting and will correctly delete the data (using the given deleter) if required. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>boost::shared_ptr&lt;TYPE&gt; handling same data as the object. </dd></dl>

<p>Definition at line <a class="el" href="typeptr_8hpp_source.html#l00261">261</a> of file <a class="el" href="typeptr_8hpp_source.html">typeptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a869d6aa942d986d201d6d4255401845b"></a><!-- doxytag: member="isis::data::ValuePtr::operator const boost::shared_ptr&lt; TYPE &gt; &amp;" ref="a869d6aa942d986d201d6d4255401845b" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisis_1_1data_1_1ValuePtr.html">isis::data::ValuePtr</a>&lt; TYPE &gt;::operator const boost::shared_ptr&lt; TYPE &gt; &amp; </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="typeptr_8hpp_source.html#l00262">262</a> of file <a class="el" href="typeptr_8hpp_source.html">typeptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8e4c8ddd427bb142ef5d88e636f7932e"></a><!-- doxytag: member="isis::data::ValuePtr::operator[]" ref="a8e4c8ddd427bb142ef5d88e636f7932e" args="(size_t idx) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const TYPE&amp; <a class="el" href="classisis_1_1data_1_1ValuePtr.html">isis::data::ValuePtr</a>&lt; TYPE &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>idx</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="typeptr_8hpp_source.html#l00252">252</a> of file <a class="el" href="typeptr_8hpp_source.html">typeptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a042d66ffcc5985b998096722446c3bb7"></a><!-- doxytag: member="isis::data::ValuePtr::operator[]" ref="a042d66ffcc5985b998096722446c3bb7" args="(size_t idx)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TYPE&amp; <a class="el" href="classisis_1_1data_1_1ValuePtr.html">isis::data::ValuePtr</a>&lt; TYPE &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>idx</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reference element at at given index. </p>
<p>If index is invalid, behaviour is undefined. Probably it will crash. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>reference to element at at given index. </dd></dl>

<p>Definition at line <a class="el" href="typeptr_8hpp_source.html#l00249">249</a> of file <a class="el" href="typeptr_8hpp_source.html">typeptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9f8ecd913db39413ce3fee2dc1d7c002"></a><!-- doxytag: member="isis::data::ValuePtr::splice" ref="a9f8ecd913db39413ce3fee2dc1d7c002" args="(size_t size) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classisis_1_1util_1_1__internal_1_1ValueReference.html">Reference</a>&gt; <a class="el" href="classisis_1_1data_1_1ValuePtr.html">isis::data::ValuePtr</a>&lt; TYPE &gt;::splice </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Splice up the <a class="el" href="classisis_1_1data_1_1ValuePtr.html" title="Generic class for type (and length) - aware pointers.">ValuePtr</a> into equal sized blocks. </p>
<p>This virtually creates new data blocks of the given size by computing new pointers into the block and creating <a class="el" href="classisis_1_1data_1_1ValuePtr.html" title="Generic class for type (and length) - aware pointers.">ValuePtr</a> objects for them. This <a class="el" href="classisis_1_1data_1_1ValuePtr.html" title="Generic class for type (and length) - aware pointers.">ValuePtr</a> objects use the reference counting of the original <a class="el" href="classisis_1_1data_1_1ValuePtr.html" title="Generic class for type (and length) - aware pointers.">ValuePtr</a> via <a class="el" href="classisis_1_1data_1_1ValuePtr_1_1DelProxy.html" title="Proxy-Deleter to encapsulate the real deleter/shared_ptr when creating shared_ptr for parts of a shar...">DelProxy</a>, so the original data are only deleted (as a whole) when all spliced and all "normal" <a class="el" href="classisis_1_1data_1_1ValuePtr.html" title="Generic class for type (and length) - aware pointers.">ValuePtr</a> for this data are deleted. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>the maximum size of the spliced parts of the data (the last part can be smaller) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a vector of references to ValuePtr's which point to the parts of the spliced data </dd></dl>

<p>Implements <a class="el" href="classisis_1_1data_1_1__internal_1_1ValuePtrBase.html#a8d776ecb43227d021c880e616e2a9f26">isis::data::_internal::ValuePtrBase</a>.</p>

<p>Definition at line <a class="el" href="typeptr_8hpp_source.html#l00283">283</a> of file <a class="el" href="typeptr_8hpp_source.html">typeptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abdbdd90b9df012ab31b24d8bf0b129ed"></a><!-- doxytag: member="isis::data::ValuePtr::staticName" ref="abdbdd90b9df012ab31b24d8bf0b129ed" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static std::string <a class="el" href="classisis_1_1data_1_1ValuePtr.html">isis::data::ValuePtr</a>&lt; TYPE &gt;::staticName </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the name of the type </dd></dl>
 
<p>Definition at line <a class="el" href="typeptr_8hpp_source.html#l00240">240</a> of file <a class="el" href="typeptr_8hpp_source.html">typeptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac13d1b521078490e35dd8201af1899be"></a><!-- doxytag: member="isis::data::ValuePtr::toString" ref="ac13d1b521078490e35dd8201af1899be" args="(bool labeled=false) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string <a class="el" href="classisis_1_1data_1_1ValuePtr.html">isis::data::ValuePtr</a>&lt; TYPE &gt;::toString </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>labeled</em> = <code>false</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the value represented as text. </dd></dl>
 
<p>Implements <a class="el" href="classisis_1_1util_1_1__internal_1_1GenericValue.html#a54e2a61ebef7a0b7c07cd6e579c5f64a">isis::util::_internal::GenericValue</a>.</p>

<p>Definition at line <a class="el" href="typeptr_8hpp_source.html#l00217">217</a> of file <a class="el" href="typeptr_8hpp_source.html">typeptr.hpp</a>.</p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="afaf56a4a73ada017a6eefbdb03cb82a2"></a><!-- doxytag: member="isis::data::ValuePtr::staticID" ref="afaf56a4a73ada017a6eefbdb03cb82a2" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const unsigned short <a class="el" href="classisis_1_1data_1_1ValuePtr.html">isis::data::ValuePtr</a>&lt; TYPE &gt;::<a class="el" href="classisis_1_1data_1_1ValuePtr.html#afaf56a4a73ada017a6eefbdb03cb82a2">staticID</a> = util::_internal::TypeID&lt;TYPE&gt;::value &lt;&lt; 8<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="typeptr_8hpp_source.html#l00094">94</a> of file <a class="el" href="typeptr_8hpp_source.html">typeptr.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/scr/thulium1/isis/lib/Core/DataStorage/<a class="el" href="typeptr_8hpp_source.html">typeptr.hpp</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Apr 19 2011 16:19:29 for ISIS Core Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
