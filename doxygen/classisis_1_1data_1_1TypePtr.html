<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>ISIS Core Library: isis::data::TypePtr&lt; TYPE &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceisis.html">isis</a>::<a class="el" href="namespaceisis_1_1data.html">data</a>::<a class="el" href="classisis_1_1data_1_1TypePtr.html">TypePtr</a>
  </div>
</div>
<div class="contents">
<h1>isis::data::TypePtr&lt; TYPE &gt; Class Template Reference</h1><!-- doxytag: class="isis::data::TypePtr" --><!-- doxytag: inherits="isis::data::_internal::TypePtrBase" -->Generic class for type (and length) - aware pointers.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="typeptr_8hpp-source.html">typeptr.hpp</a>&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for isis::data::TypePtr&lt; TYPE &gt;:</div>
<div class="dynsection">

<p><center><img src="classisis_1_1data_1_1TypePtr.png" usemap="#isis::data::TypePtr< TYPE >_map" border="0" alt=""></center>
<map name="isis::data::TypePtr< TYPE >_map">
<area href="classisis_1_1data_1_1__internal_1_1TypePtrBase.html" alt="isis::data::_internal::TypePtrBase" shape="rect" coords="0,56,193,80">
<area href="classisis_1_1util_1_1__internal_1_1GenericType.html" alt="isis::util::_internal::GenericType" shape="rect" coords="0,0,193,24">
</map>
</div>

<p>
<a href="classisis_1_1data_1_1TypePtr-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1TypePtr.html#3e7099af6b522b8c2fd2f1368bc39e6f">bytes_per_elem</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">TypePtrBase::Reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1TypePtr.html#9da817b44c06ec8ea3a516fabbcbb818">cloneToMem</a> (size_t length) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new <a class="el" href="classisis_1_1data_1_1TypePtr.html" title="Generic class for type (and length) - aware pointers.">TypePtr</a>, of the same type, but differnent size in memory.  <a href="#9da817b44c06ec8ea3a516fabbcbb818"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1TypePtr.html#208be5b0d5ac9173cf0fb1c0b5caf80d">cmp</a> (size_t start, size_t end, const <a class="el" href="classisis_1_1data_1_1__internal_1_1TypePtrBase.html">_internal::TypePtrBase</a> &amp;dst, size_t dst_start) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1TypePtr.html#233d18b292dfae29e1e786f61d2bda0d">copyFromMem</a> (const TYPE *const src, size_t length)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy elements from raw memory.  <a href="#233d18b292dfae29e1e786f61d2bda0d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1TypePtr.html#ad7acfd8d6d30cab55931b5f5999e0bb">copyToMem</a> (size_t start, size_t end, TYPE *const dst) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy elements within a range [start,end] to raw memory.  <a href="#ad7acfd8d6d30cab55931b5f5999e0bb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1TypePtr.html#3325b528c8adb1161f9fc4f0dd113456">getMinMax</a> (<a class="el" href="classisis_1_1util_1_1__internal_1_1TypeReference.html">util::TypeReference</a> &amp;min, <a class="el" href="classisis_1_1util_1_1__internal_1_1TypeReference.html">util::TypeReference</a> &amp;max) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1TypePtr.html#496dae890517e1d79a5df2f78df94a85">operator boost::shared_ptr&lt; TYPE &gt; &amp;</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implicit conversion to boost::shared_ptr&lt;TYPE&gt; The returned smart pointer will be part of the reference-counting and will correctly delete the <a class="el" href="namespaceisis_1_1data.html">data</a> (using the given deleter) if required.  <a href="#496dae890517e1d79a5df2f78df94a85"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1TypePtr.html#f4a7b61430f49e2b1a1e1d8648270b51">operator const boost::shared_ptr&lt; TYPE &gt; &amp;</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const TYPE &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1TypePtr.html#f316888e2504a72140833fbf80e3227a">operator[]</a> (size_t idx) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">TYPE &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1TypePtr.html#13d1295cbbab2124a6b6c00fe332132c">operator[]</a> (size_t idx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reference element at at given index.  <a href="#13d1295cbbab2124a6b6c00fe332132c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; <a class="el" href="classisis_1_1util_1_1__internal_1_1TypeReference.html">Reference</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1TypePtr.html#05fef130b711778ae0e18b1da61a6e62">splice</a> (size_t size) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Split up into cheap copies of given length.  <a href="#05fef130b711778ae0e18b1da61a6e62"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1TypePtr.html#b204bcc65e1e81f9f8454af7e118990e">toString</a> (bool labeled=false) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual unsigned short&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1TypePtr.html#9763c03ae6d4d2ae12411937dcc071dc">typeID</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1TypePtr.html#df227c719e70f691efac15a2522d292e">typeName</a> () const </td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename D&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1TypePtr.html#3124a061f6b3d404e42697c89a20b146">TypePtr</a> (TYPE *const ptr, size_t length, D d)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates <a class="el" href="classisis_1_1data_1_1TypePtr.html" title="Generic class for type (and length) - aware pointers.">TypePtr</a> from a pointer of type TYPE.  <a href="#3124a061f6b3d404e42697c89a20b146"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1TypePtr.html#4f9ee1bd8a05407442ef22baed624896">TypePtr</a> (TYPE *const ptr, size_t length)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates <a class="el" href="classisis_1_1data_1_1TypePtr.html" title="Generic class for type (and length) - aware pointers.">TypePtr</a> from a pointer of type TYPE.  <a href="#4f9ee1bd8a05407442ef22baed624896"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1TypePtr.html#cef755dbcc6af117953467b62e54b793">TypePtr</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Contructor for empty pointer.  <a href="#cef755dbcc6af117953467b62e54b793"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1TypePtr.html#bcc81630f2b9c36e5b310e409c111cb4">~TypePtr</a> ()</td></tr>

<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1TypePtr.html#10b53968f191a0b23737d4950f5dfae7">staticName</a> ()</td></tr>

<tr><td colspan="2"><br><h2>Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const unsigned short&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1TypePtr.html#9c0439afbff4e6ff5a3a68d326d8bdef">staticID</a> = util::_internal::TypeId&lt;TYPE&gt;::value &lt;&lt; 8</td></tr>

<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TypePtrBase *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1TypePtr.html#40cfef72e22073b680ae132290466d7a">clone</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a <a class="el" href="classisis_1_1data_1_1TypePtr.html" title="Generic class for type (and length) - aware pointers.">TypePtr</a> of the same type pointing at the same address.  <a href="#40cfef72e22073b680ae132290466d7a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const boost::weak_ptr&lt; void &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1TypePtr.html#6a0e5ca9d1e95a6815a76eb0a2046314">getRawAddress</a> () const </td></tr>

<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structisis_1_1data_1_1TypePtr_1_1BasicDeleter.html">BasicDeleter</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default delete-functor for c-arrays (uses free()).  <a href="structisis_1_1data_1_1TypePtr_1_1BasicDeleter.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisis_1_1data_1_1TypePtr_1_1DelProxy.html">DelProxy</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Proxy-Deleter to encapsulate the real deleter/shared_ptr when creating shared_ptr for parts of a shared_ptr.  <a href="classisis_1_1data_1_1TypePtr_1_1DelProxy.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structisis_1_1data_1_1TypePtr_1_1NonDeleter.html">NonDeleter</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">delete-functor which does nothing (in case someone else manages the <a class="el" href="namespaceisis_1_1data.html">data</a>).  <a href="structisis_1_1data_1_1TypePtr_1_1NonDeleter.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structisis_1_1data_1_1TypePtr_1_1ObjectArrayDeleter.html">ObjectArrayDeleter</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default delete-functor for arrays of objects (uses delete[]).  <a href="structisis_1_1data_1_1TypePtr_1_1ObjectArrayDeleter.html#_details">More...</a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename TYPE&gt;<br>
 class isis::data::TypePtr&lt; TYPE &gt;</h3>

Generic class for type (and length) - aware pointers. 
<p>
The class is designed for arrays, but you can also "point" to an single element by just use "1" for the length. The pointers are reference counted and will be deleted automatically by a customizable deleter. The copy is cheap, thus the copy of a <a class="el" href="classisis_1_1data_1_1TypePtr.html" title="Generic class for type (and length) - aware pointers.">TypePtr</a> will reference the same <a class="el" href="namespaceisis_1_1data.html">data</a>. The usual dereferencing pointer interface ("*" and "-&gt;") is supported. 
<p>Definition at line <a class="el" href="typeptr_8hpp-source.html#l00065">65</a> of file <a class="el" href="typeptr_8hpp-source.html">typeptr.hpp</a>.</p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="cef755dbcc6af117953467b62e54b793"></a><!-- doxytag: member="isis::data::TypePtr::TypePtr" ref="cef755dbcc6af117953467b62e54b793" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisis_1_1data_1_1TypePtr.html">isis::data::TypePtr</a>&lt; TYPE &gt;::<a class="el" href="classisis_1_1data_1_1TypePtr.html">TypePtr</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Contructor for empty pointer. 
<p>
length will be 0 and every attempt to dereference it will raise an exception. 
<p>Definition at line <a class="el" href="typeptr_8hpp-source.html#l00125">125</a> of file <a class="el" href="typeptr_8hpp-source.html">typeptr.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="4f9ee1bd8a05407442ef22baed624896"></a><!-- doxytag: member="isis::data::TypePtr::TypePtr" ref="4f9ee1bd8a05407442ef22baed624896" args="(TYPE *const ptr, size_t length)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisis_1_1data_1_1TypePtr.html">isis::data::TypePtr</a>&lt; TYPE &gt;::<a class="el" href="classisis_1_1data_1_1TypePtr.html">TypePtr</a>           </td>
          <td>(</td>
          <td class="paramtype">TYPE *const &nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates <a class="el" href="classisis_1_1data_1_1TypePtr.html" title="Generic class for type (and length) - aware pointers.">TypePtr</a> from a pointer of type TYPE. 
<p>
The pointers are automatically deleted by an instance of <a class="el" href="structisis_1_1data_1_1TypePtr_1_1BasicDeleter.html" title="Default delete-functor for c-arrays (uses free()).">BasicDeleter</a> and should not be used outside once used here. If ptr is a pointer to C++ objects (delete[] needed) you must use <a class="el" href="classisis_1_1data_1_1TypePtr.html" title="Generic class for type (and length) - aware pointers.">TypePtr</a>(ptr,len,<a class="el" href="classisis_1_1data_1_1TypePtr.html" title="Generic class for type (and length) - aware pointers.">TypePtr</a>&lt;TYPE&gt;ObjectArrayDeleter())! <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>the pointer to the used array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>the length of the used array (<a class="el" href="classisis_1_1data_1_1TypePtr.html" title="Generic class for type (and length) - aware pointers.">TypePtr</a> does NOT check for length, this is just here for child classes which may want to check) </td></tr>
  </table>
</dl>

<p>Definition at line <a class="el" href="typeptr_8hpp-source.html#l00137">137</a> of file <a class="el" href="typeptr_8hpp-source.html">typeptr.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="3124a061f6b3d404e42697c89a20b146"></a><!-- doxytag: member="isis::data::TypePtr::TypePtr" ref="3124a061f6b3d404e42697c89a20b146" args="(TYPE *const ptr, size_t length, D d)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE&gt; </div>
<div class="memtemplate">
template&lt;typename D&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisis_1_1data_1_1TypePtr.html">isis::data::TypePtr</a>&lt; TYPE &gt;::<a class="el" href="classisis_1_1data_1_1TypePtr.html">TypePtr</a>           </td>
          <td>(</td>
          <td class="paramtype">TYPE *const &nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">D&nbsp;</td>
          <td class="paramname"> <em>d</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates <a class="el" href="classisis_1_1data_1_1TypePtr.html" title="Generic class for type (and length) - aware pointers.">TypePtr</a> from a pointer of type TYPE. 
<p>
The pointers are automatically deleted by an copy of d and should not be used outside once used here (this does not apply, if d does not delete). D must implement operator()(TYPE *p). <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>the pointer to the used array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>the length of the used array in elements (<a class="el" href="classisis_1_1data_1_1TypePtr.html" title="Generic class for type (and length) - aware pointers.">TypePtr</a> does NOT check for length), </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>d</em>&nbsp;</td><td>the deleter to be used when the <a class="el" href="namespaceisis_1_1data.html">data</a> shall be deleted ( d() is called then ) </td></tr>
  </table>
</dl>

<p>Definition at line <a class="el" href="typeptr_8hpp-source.html#l00149">149</a> of file <a class="el" href="typeptr_8hpp-source.html">typeptr.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="bcc81630f2b9c36e5b310e409c111cb4"></a><!-- doxytag: member="isis::data::TypePtr::~TypePtr" ref="bcc81630f2b9c36e5b310e409c111cb4" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classisis_1_1data_1_1TypePtr.html">isis::data::TypePtr</a>&lt; TYPE &gt;::~<a class="el" href="classisis_1_1data_1_1TypePtr.html">TypePtr</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="typeptr_8hpp-source.html#l00152">152</a> of file <a class="el" href="typeptr_8hpp-source.html">typeptr.hpp</a>.</p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="3e7099af6b522b8c2fd2f1368bc39e6f"></a><!-- doxytag: member="isis::data::TypePtr::bytes_per_elem" ref="3e7099af6b522b8c2fd2f1368bc39e6f" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classisis_1_1data_1_1TypePtr.html">isis::data::TypePtr</a>&lt; TYPE &gt;::bytes_per_elem           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Implements <a class="el" href="classisis_1_1data_1_1__internal_1_1TypePtrBase.html#d080904ddbd79f3e2ca48c9620f97826">isis::data::_internal::TypePtrBase</a>.</p>

<p>Definition at line <a class="el" href="typeptr_8hpp-source.html#l00250">250</a> of file <a class="el" href="typeptr_8hpp-source.html">typeptr.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="40cfef72e22073b680ae132290466d7a"></a><!-- doxytag: member="isis::data::TypePtr::clone" ref="40cfef72e22073b680ae132290466d7a" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TypePtrBase* <a class="el" href="classisis_1_1data_1_1TypePtr.html">isis::data::TypePtr</a>&lt; TYPE &gt;::clone           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a <a class="el" href="classisis_1_1data_1_1TypePtr.html" title="Generic class for type (and length) - aware pointers.">TypePtr</a> of the same type pointing at the same address. 
<p>

<p>Implements <a class="el" href="classisis_1_1data_1_1__internal_1_1TypePtrBase.html#1939b02abcd3c3dc6acbfdca61210c56">isis::data::_internal::TypePtrBase</a>.</p>

<p>Definition at line <a class="el" href="typeptr_8hpp-source.html#l00073">73</a> of file <a class="el" href="typeptr_8hpp-source.html">typeptr.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="9da817b44c06ec8ea3a516fabbcbb818"></a><!-- doxytag: member="isis::data::TypePtr::cloneToMem" ref="9da817b44c06ec8ea3a516fabbcbb818" args="(size_t length) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TypePtrBase::Reference <a class="el" href="classisis_1_1data_1_1TypePtr.html">isis::data::TypePtr</a>&lt; TYPE &gt;::cloneToMem           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>length</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new <a class="el" href="classisis_1_1data_1_1TypePtr.html" title="Generic class for type (and length) - aware pointers.">TypePtr</a>, of the same type, but differnent size in memory. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>length of the new memory block in elements of the given TYPE </td></tr>
  </table>
</dl>

<p>Implements <a class="el" href="classisis_1_1data_1_1__internal_1_1TypePtrBase.html#c4099cb2034c8dea74ce45933fadea1b">isis::data::_internal::TypePtrBase</a>.</p>

<p>Definition at line <a class="el" href="typeptr_8hpp-source.html#l00247">247</a> of file <a class="el" href="typeptr_8hpp-source.html">typeptr.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="208be5b0d5ac9173cf0fb1c0b5caf80d"></a><!-- doxytag: member="isis::data::TypePtr::cmp" ref="208be5b0d5ac9173cf0fb1c0b5caf80d" args="(size_t start, size_t end, const _internal::TypePtrBase &amp;dst, size_t dst_start) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classisis_1_1data_1_1TypePtr.html">isis::data::TypePtr</a>&lt; TYPE &gt;::cmp           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classisis_1_1data_1_1__internal_1_1TypePtrBase.html">_internal::TypePtrBase</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>dst_start</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Implements <a class="el" href="classisis_1_1data_1_1__internal_1_1TypePtrBase.html#50e690bbbf1a590b633a5f4a69ee5252">isis::data::_internal::TypePtrBase</a>.</p>

<p>Definition at line <a class="el" href="typeptr_8hpp-source.html#l00171">171</a> of file <a class="el" href="typeptr_8hpp-source.html">typeptr.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="233d18b292dfae29e1e786f61d2bda0d"></a><!-- doxytag: member="isis::data::TypePtr::copyFromMem" ref="233d18b292dfae29e1e786f61d2bda0d" args="(const TYPE *const src, size_t length)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classisis_1_1data_1_1TypePtr.html">isis::data::TypePtr</a>&lt; TYPE &gt;::copyFromMem           </td>
          <td>(</td>
          <td class="paramtype">const TYPE *const &nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy elements from raw memory. 
<p>

<p>Definition at line <a class="el" href="typeptr_8hpp-source.html#l00155">155</a> of file <a class="el" href="typeptr_8hpp-source.html">typeptr.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="ad7acfd8d6d30cab55931b5f5999e0bb"></a><!-- doxytag: member="isis::data::TypePtr::copyToMem" ref="ad7acfd8d6d30cab55931b5f5999e0bb" args="(size_t start, size_t end, TYPE *const dst) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classisis_1_1data_1_1TypePtr.html">isis::data::TypePtr</a>&lt; TYPE &gt;::copyToMem           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TYPE *const &nbsp;</td>
          <td class="paramname"> <em>dst</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy elements within a range [start,end] to raw memory. 
<p>

<p>Definition at line <a class="el" href="typeptr_8hpp-source.html#l00163">163</a> of file <a class="el" href="typeptr_8hpp-source.html">typeptr.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="3325b528c8adb1161f9fc4f0dd113456"></a><!-- doxytag: member="isis::data::TypePtr::getMinMax" ref="3325b528c8adb1161f9fc4f0dd113456" args="(util::TypeReference &amp;min, util::TypeReference &amp;max) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classisis_1_1data_1_1TypePtr.html">isis::data::TypePtr</a>&lt; TYPE &gt;::getMinMax           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classisis_1_1util_1_1__internal_1_1TypeReference.html">util::TypeReference</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classisis_1_1util_1_1__internal_1_1TypeReference.html">util::TypeReference</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>max</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get minimum/maximum from a <a class="el" href="classisis_1_1data_1_1TypePtr.html" title="Generic class for type (and length) - aware pointers.">TypePtr</a>. <p>
The parameters are reverences to the current maximum/minimum found. max will be replaced by a value from the array if:<ul>
<li>max is empty</li><li>max is less than that value from the array</li></ul>
<p>
min will be replaced by a value from the array if:<ul>
<li>min is empty</li><li>min is greater than that value from the array</li></ul>
<p>
Note, that min/max will also adopt the type of the value. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>max</em>&nbsp;</td><td>TypeBase::Reference for the current greatest value </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>min</em>&nbsp;</td><td>TypeBase::Reference for the current lowest value </td></tr>
  </table>
</dl>
 
<p>Implements <a class="el" href="classisis_1_1data_1_1__internal_1_1TypePtrBase.html#27da3b2fac9ae5bee7b4b8aef160712f">isis::data::_internal::TypePtrBase</a>.</p>

<p>Definition at line <a class="el" href="typeptr_8hpp-source.html#l00254">254</a> of file <a class="el" href="typeptr_8hpp-source.html">typeptr.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="6a0e5ca9d1e95a6815a76eb0a2046314"></a><!-- doxytag: member="isis::data::TypePtr::getRawAddress" ref="6a0e5ca9d1e95a6815a76eb0a2046314" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const boost::weak_ptr&lt;void&gt; <a class="el" href="classisis_1_1data_1_1TypePtr.html">isis::data::TypePtr</a>&lt; TYPE &gt;::getRawAddress           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Implements <a class="el" href="classisis_1_1data_1_1__internal_1_1TypePtrBase.html#ca2b62915e3d6785dbac2d2a22c7427f">isis::data::_internal::TypePtrBase</a>.</p>

<p>Definition at line <a class="el" href="typeptr_8hpp-source.html#l00070">70</a> of file <a class="el" href="typeptr_8hpp-source.html">typeptr.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="496dae890517e1d79a5df2f78df94a85"></a><!-- doxytag: member="isis::data::TypePtr::operator boost::shared_ptr&lt; TYPE &gt; &amp;" ref="496dae890517e1d79a5df2f78df94a85" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisis_1_1data_1_1TypePtr.html">isis::data::TypePtr</a>&lt; TYPE &gt;::operator boost::shared_ptr&lt; TYPE &gt; &amp;           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Implicit conversion to boost::shared_ptr&lt;TYPE&gt; The returned smart pointer will be part of the reference-counting and will correctly delete the <a class="el" href="namespaceisis_1_1data.html">data</a> (using the given deleter) if required. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>boost::shared_ptr&lt;TYPE&gt; handling same <a class="el" href="namespaceisis_1_1data.html">data</a> as the object. </dd></dl>

<p>Definition at line <a class="el" href="typeptr_8hpp-source.html#l00244">244</a> of file <a class="el" href="typeptr_8hpp-source.html">typeptr.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="f4a7b61430f49e2b1a1e1d8648270b51"></a><!-- doxytag: member="isis::data::TypePtr::operator const boost::shared_ptr&lt; TYPE &gt; &amp;" ref="f4a7b61430f49e2b1a1e1d8648270b51" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classisis_1_1data_1_1TypePtr.html">isis::data::TypePtr</a>&lt; TYPE &gt;::operator const boost::shared_ptr&lt; TYPE &gt; &amp;           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="typeptr_8hpp-source.html#l00245">245</a> of file <a class="el" href="typeptr_8hpp-source.html">typeptr.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="f316888e2504a72140833fbf80e3227a"></a><!-- doxytag: member="isis::data::TypePtr::operator[]" ref="f316888e2504a72140833fbf80e3227a" args="(size_t idx) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const TYPE&amp; <a class="el" href="classisis_1_1data_1_1TypePtr.html">isis::data::TypePtr</a>&lt; TYPE &gt;::operator[]           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>idx</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="typeptr_8hpp-source.html#l00235">235</a> of file <a class="el" href="typeptr_8hpp-source.html">typeptr.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="13d1295cbbab2124a6b6c00fe332132c"></a><!-- doxytag: member="isis::data::TypePtr::operator[]" ref="13d1295cbbab2124a6b6c00fe332132c" args="(size_t idx)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TYPE&amp; <a class="el" href="classisis_1_1data_1_1TypePtr.html">isis::data::TypePtr</a>&lt; TYPE &gt;::operator[]           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>idx</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reference element at at given index. 
<p>
If index is invalid, behaviour is undefined. Probably it will crash. <dl class="return" compact><dt><b>Returns:</b></dt><dd>reference to element at at given index. </dd></dl>

<p>Definition at line <a class="el" href="typeptr_8hpp-source.html#l00232">232</a> of file <a class="el" href="typeptr_8hpp-source.html">typeptr.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="05fef130b711778ae0e18b1da61a6e62"></a><!-- doxytag: member="isis::data::TypePtr::splice" ref="05fef130b711778ae0e18b1da61a6e62" args="(size_t size) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classisis_1_1util_1_1__internal_1_1TypeReference.html">Reference</a>&gt; <a class="el" href="classisis_1_1data_1_1TypePtr.html">isis::data::TypePtr</a>&lt; TYPE &gt;::splice           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Split up into cheap copies of given length. 
<p>
This will create TypePtr's which will point at elements within this <a class="el" href="namespaceisis_1_1data.html">data</a> block.<ul>
<li>They will have a distance of size and therefore have the have the same length (exept the last one which will point an the rest).</li><li>They will use a special proxy-reference-counting (If at least one of them is still used, the whole original <a class="el" href="classisis_1_1data_1_1TypePtr.html" title="Generic class for type (and length) - aware pointers.">TypePtr</a> will be kept). <dl class="return" compact><dt><b>Returns:</b></dt><dd>a vector of ceil(<a class="el" href="classisis_1_1data_1_1__internal_1_1TypePtrBase.html#3b3dd4f4c9fea72ddefce62c6e69cb65">len()</a>/size) not intersecting TypePtrBase::Reference's of the length&lt;=size. </dd></dl>
</li></ul>

<p>Implements <a class="el" href="classisis_1_1data_1_1__internal_1_1TypePtrBase.html#9bfea660089df38a7e408d97402b0c12">isis::data::_internal::TypePtrBase</a>.</p>

<p>Definition at line <a class="el" href="typeptr_8hpp-source.html#l00269">269</a> of file <a class="el" href="typeptr_8hpp-source.html">typeptr.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="10b53968f191a0b23737d4950f5dfae7"></a><!-- doxytag: member="isis::data::TypePtr::staticName" ref="10b53968f191a0b23737d4950f5dfae7" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static std::string <a class="el" href="classisis_1_1data_1_1TypePtr.html">isis::data::TypePtr</a>&lt; TYPE &gt;::staticName           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the name of the type </dd></dl>
 
<p>Definition at line <a class="el" href="typeptr_8hpp-source.html#l00223">223</a> of file <a class="el" href="typeptr_8hpp-source.html">typeptr.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="b204bcc65e1e81f9f8454af7e118990e"></a><!-- doxytag: member="isis::data::TypePtr::toString" ref="b204bcc65e1e81f9f8454af7e118990e" args="(bool labeled=false) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string <a class="el" href="classisis_1_1data_1_1TypePtr.html">isis::data::TypePtr</a>&lt; TYPE &gt;::toString           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>labeled</em> = <code>false</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the value represented as text. </dd></dl>
 
<p>Implements <a class="el" href="classisis_1_1util_1_1__internal_1_1GenericType.html#dc131509306a4ed5a49214dc2f7c36db">isis::util::_internal::GenericType</a>.</p>

<p>Definition at line <a class="el" href="typeptr_8hpp-source.html#l00200">200</a> of file <a class="el" href="typeptr_8hpp-source.html">typeptr.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="9763c03ae6d4d2ae12411937dcc071dc"></a><!-- doxytag: member="isis::data::TypePtr::typeID" ref="9763c03ae6d4d2ae12411937dcc071dc" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned short <a class="el" href="classisis_1_1data_1_1TypePtr.html">isis::data::TypePtr</a>&lt; TYPE &gt;::typeID           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the id of its actual type </dd></dl>
 
<p>Implements <a class="el" href="classisis_1_1util_1_1__internal_1_1GenericType.html#bddf0ad6c69b2a13dfd3c1bd453438b2">isis::util::_internal::GenericType</a>.</p>

<p>Definition at line <a class="el" href="typeptr_8hpp-source.html#l00219">219</a> of file <a class="el" href="typeptr_8hpp-source.html">typeptr.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="df227c719e70f691efac15a2522d292e"></a><!-- doxytag: member="isis::data::TypePtr::typeName" ref="df227c719e70f691efac15a2522d292e" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string <a class="el" href="classisis_1_1data_1_1TypePtr.html">isis::data::TypePtr</a>&lt; TYPE &gt;::typeName           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the name of its actual type </dd></dl>
 
<p>Implements <a class="el" href="classisis_1_1util_1_1__internal_1_1GenericType.html#816d03f5ac84cb52f4122d4e09391d03">isis::util::_internal::GenericType</a>.</p>

<p>Definition at line <a class="el" href="typeptr_8hpp-source.html#l00215">215</a> of file <a class="el" href="typeptr_8hpp-source.html">typeptr.hpp</a>.</p>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="9c0439afbff4e6ff5a3a68d326d8bdef"></a><!-- doxytag: member="isis::data::TypePtr::staticID" ref="9c0439afbff4e6ff5a3a68d326d8bdef" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const unsigned short <a class="el" href="classisis_1_1data_1_1TypePtr.html">isis::data::TypePtr</a>&lt; TYPE &gt;::<a class="el" href="classisis_1_1data_1_1TypePtr.html#9c0439afbff4e6ff5a3a68d326d8bdef">staticID</a> = util::_internal::TypeId&lt;TYPE&gt;::value &lt;&lt; 8<code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="typeptr_8hpp-source.html#l00077">77</a> of file <a class="el" href="typeptr_8hpp-source.html">typeptr.hpp</a>.</p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>/SCR/isis/lib/Core/DataStorage/<a class="el" href="typeptr_8hpp-source.html">typeptr.hpp</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Tue Dec 14 17:52:45 2010 for ISIS Core Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
